{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":".home-feature { justify-content: space-between !important; align-items: center !important; display: flex !important; margin-top: 3rem !important; margin-bottom: 3rem !important; } anabel anabel Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Get Started Guides View guides that explain the concepts and components of anabel . API Documentation Peruse a comprehensive list of functions provided by anabel , with detailed explanations of their interfaces. Gallery Walk through some examples of the various analysis procedures that anabel provides. Inelasticity Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Partial Differential Equations Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Reliability Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.","title":"Home"},{"location":"site-info/","text":"Project Information This website was generated with the Elstir static site generator, a fork of MkDocs which uses Pandoc as the backend. The theme uses Bootstrap and is heavily adapted from Bootswatch . Additional sources of inspiration for the layout of this site include Numba , Pandas , and Codecov . This website and corresponding project is in a very early stage of development and has not yet been licensed. The content of this website (including without limitation the text, computer code, artwork, photographs, images, audio material, video material and audio-visual material on this website) is owned by the author. For the time being, any redistribution or reproduction of part or all of the contents in any form is prohibited other than the following: You may view this website and the material on this website on a computer or mobile device via a web browser; You may copy and store this website and the material on this website in your web browser cache memory; You may print pages from this website for your own use. You may not distribute or commercially exploit the content. Nor may you transmit it or store it in any other website or other form of electronic retrieval system. The automated and/or systematic collection of data from this website is prohibited. License This project is not yet licensed. Disclaimer THE SOFTWARE IS PROVIDED \u201cAS IS,\u201d WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Project Information"},{"location":"api/latest/","text":"Modeling API The high-level modeling API is composed of six modules.","title":"API"},{"location":"api/latest/assemble/","text":"Assemblers Core model building classes. Classes class Assembler ( ndm: int, ndf: int) Basic assembler class An assembler is typically characterized by collections of nodes, elements and parameters. Parameters ndm :\u2002 int number of model dimensions ndf :\u2002 int number of degrees of freedom (dofs) at each node Subclasses Model class Model ( ndm: int, ndf: int) Basic structural model class Parameters ndm :\u2002 int number of model dimensions ndf :\u2002 int number of degrees of freedom (dofs) at each node Ancestors Assembler Subclasses anabel.assemble.Domain SkeletalModel rModel Instance variables var NOS : int Degree of static indeterminacy var basic_forces : numpy.ndarray var cforces : numpy.ndarray var eforces Array of elastic element forces var idx_c var idx_e Indices of elastic basic (not plastic) forces var idx_f var idx_i var idx_x var nQ var ne : int number of elements in model var nf : int Number of free model degrees of freedom var nn : int Number of nodes in model var nq Number of basic element forces var nr : int number of constrained dofs in model var nt : int Total number of model degrees of freedom. var nv Number of basic deformation variables var rdnt_forces : numpy.ndarray var rdofs Sequence of restrained dofs in model var rel Methods def add_element ( self, element) Add a general element to model Parameters element :\u2002 emme.elements.Element def add_elements ( self, elements) Add a general element to model Parameters element :\u2002 emme.elements.Element def assemble_force ( self, elem=None, **kwds) \u2011> Callable A simple force composer for skeletal truss structures. def beam ( self, tag: str, iNode, jNode, mat=None, sec=None, Qpl=None, **kwds) Create and add a beam object to model Parameters tag :\u2002 str string used for identifying object iNode :\u2002 emme.Node or str node object at element i-end jNode :\u2002 emme.Node or str node object at element j-end mat :\u2002 emme.Material sec :\u2002 emme.Section def boun ( self, node, ones) def clean ( self, keep=None) def compose ( self, resp='d', jit=True, **kwds) def compose_displ ( self, solver=None, solver_opts={}, elem=None, jit_force=True, **kwds) dynamically creates functions collect_loads and collect_coord . def compose_force ( self, jit=True, **kwds) def compose_param ( self, jit_force=True, **kwds) def displ ( self, val) def elem ( self, elem, nodes, tag) def fix ( self, node, dirn=['x', 'y', 'rz']) Define a fixed boundary condition at specified degrees of freedom of the supplied node Parameters node :\u2002 emme.Node dirn :\u2002 Sequence[String] def frame ( self, bays, stories, column_mat=None, column_sec=None, girder_mat=None, girder_sec=None) Macro for generating rectangular building frames Parameters bays :\u2002 tuple tuple containing bay width, and number of bays stories :\u2002 tuple tuple column_mat: def girder ( self, nodes, mats=None, xsecs=None, story=None) def hinge ( self, elem, node) def load ( self, obj, *args, pattern=None, **kwds) Apply a load to a model object Claudio Perez 2021-04-01 def load_node ( self, node, load, **kwds) Claudio Perez 2021-04-01 def load_state ( self, state) def material ( self, tag: str, E: float) def node ( self, tag: str, x: float, y=None, z=None, mass: float = None) Add a new emme.Node object to the model Parameters x , y , z :\u2002 float Node coordinates. def numDOF ( self) def param ( self, *param_names, shape=0, dtype=builtins.float, default=None) Add a parameter to a model. created 2021-03-31 def pin ( self, *nodes) Create a pinned reaction by fixing all translational degrees of freedom at the specified nodes. Parameters node :\u2002 emme.Node def redundant ( self, elem: object, nature) nature: def roller ( self, node) Create a roller reaction at specified node def state ( self, method='Linear') def taprod ( self, tag: str, iNode, jNode, mat=None, xsec=None, Qpl=None, A=None, E=None) Construct a tapered rod element with variable E and A values. def truss ( self, tag: str, iNode, jNode, elem=None, mat=None, xsec=None, Qpl=None, A=None, E=None) def truss3d ( self, tag: str, iNode, jNode, mat=None, xsec=None) Add an emme.Truss3d object to model Parameters def update ( self, U) def xsection ( self, tag: str, A: float, I: float) class SkeletalModel ( ndm: int, ndf: int) Basic structural model class Parameters ndm :\u2002 int number of model dimensions ndf :\u2002 int number of degrees of freedom (dofs) at each node Ancestors Model Assembler Inherited members Model : NOS add_element add_elements assemble_force beam compose_displ eforces fix frame idx_e load load_node ne nf nn node nq nr nt nv param pin rdofs redundant roller taprod truss3d class rModel ( ndm, ndf) Basic structural model class Parameters ndm :\u2002 int number of model dimensions ndf :\u2002 int number of degrees of freedom (dofs) at each node Ancestors Model Assembler Instance variables var cforces var nv Returns number of element deformations in model var triv_forces list of trivial axial forces Methods def isortho ( self, elem) def numDOF ( self) def numdofs ( self) Inherited members Model : NOS add_element add_elements assemble_force beam compose_displ eforces fix frame idx_e load load_node ne nf nn node nq nr nt param pin rdofs redundant roller taprod truss3d","title":"anabel.assemble"},{"location":"api/latest/graphics/","text":"Functions def plot_displ ( model, displ, ax=None, fig=None, scale=None, color=None, chords=False, **kwds) Claudio Perez 2021-04-02 def plot_moments ( state: object, ax=None, scale: float = None, color: str = None, chords: bool = False) Plot moment distribution from a frame model analysis. Only works for 2D models. def plot_skeletal ( Model, ax=None, label=False)","title":"anabel.graphics"},{"location":"api/latest/matrices/","text":"Matrix API This module provides functions and classes for constructing various structural analysis matrices. Functions def A_matrix ( Domain, matrix=None) Returns a Kinematic_matrix object def AssemblyTensor ( Model) def Aub_matrix ( model, alpha) Return the interaction upperbound matrix def B_matrix ( model, matrix=None, rng=None) Returns a Static_matrix object def Bh_matrix ( model) Returns a Static_matrix object def F_matrix ( Domain) Returns a Flexibility_matrix object def Fs_matrix ( model, Roption=True) Returns a Flexibility_matrix object def K_matrix ( Model) Returns a Stiffness_matrix object def K_tensor ( Model, U=None) Returns a Stiffness_matrix object def Ks_matrix ( model) Returns a Flexibility_matrix object def Kt_matrix ( Model, State) Returns a Stiffness_matrix object def Localize ( U_vector, P_vector, model=None) def P0_vector ( model) def P_vector ( model, vector=None) def Pw_vector ( model) def Q0_vector ( model) Returns a vector of initial element forces def Q_vector ( model, vector=None) Returns a iForce_vector object def Qp_vector ( model) Returns a vector of element plastic capacities def Qpl_vector ( model) Returns a vector of element plastic capacities def U_vector ( model, vector=None) Returns a Displacement_vector object def V0_vector ( model) Returns a Deformation_vector object def V_vector ( model, vector=None) Returns a Deformation_vector object def del_zeros ( mat) def elem_dofs ( Elem) def nB_matrix ( model, rng=None) Returns a Static_matrix object def transfer_vars ( item1, item2) Classes class Deformation_vector ( arry, model, row_data, Vector=None) ndarray(shape, dtype=float, buffer=None, offset=0, strides=None, order=None) An array object represents a multidimensional, homogeneous array of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, or something else, etc.) Arrays should be constructed using array , zeros or empty (refer to the See Also section below). The parameters given here refer to a low-level method ( ndarray(\u2026) ) for instantiating an array. For more information, refer to the numpy module and examine the methods and attributes of an array. Parameters (for the new method; see Notes below) shape :\u2002 tuple of ints Shape of created array. dtype :\u2002 data-type , optional Any object that can be interpreted as a numpy data type. buffer :\u2002 object exposing buffer interface , optional Used to fill the array with data. offset :\u2002 int , optional Offset of array data in buffer. strides :\u2002 tuple of ints , optional Strides of data in memory. order :\u2002 {'C', 'F'} , optional Row-major (C-style) or column-major (Fortran-style) order. Attributes T :\u2002 ndarray Transpose of the array. data :\u2002 buffer The array\u2019s elements, in memory. dtype :\u2002 dtype object Describes the format of the elements in the array. flags :\u2002 dict Dictionary containing information related to memory use, e.g., \u2018C_CONTIGUOUS,\u2019 \u2018OWNDATA,\u2019 \u2018WRITEABLE,\u2019 etc. flat :\u2002 numpy.flatiter object Flattened version of the array as an iterator. The iterator allows assignments, e.g., x.flat = 3 (See ndarray.flat for assignment examples; TODO). imag :\u2002 ndarray Imaginary part of the array. real :\u2002 ndarray Real part of the array. size :\u2002 int Number of elements in the array. itemsize :\u2002 int The memory use of each array element in bytes. nbytes :\u2002 int The total number of bytes required to store the array data, i.e., itemsize * size . ndim :\u2002 int The array\u2019s number of dimensions. shape :\u2002 tuple of ints Shape of the array. strides :\u2002 tuple of ints The step-size required to move from one element to the next in memory. For example, a contiguous (3, 4) array of type int16 in C-order has strides (8, 2) . This implies that to move from element to element in memory requires jumps of 2 bytes. To move from row-to-row, one needs to jump 8 bytes at a time ( 2 * 4 ). ctypes :\u2002 ctypes object Class containing properties of the array needed for interaction with ctypes. base :\u2002 ndarray If the array is a view into another array, that array is its base (unless that array is also a view). The base array is where the array data is actually stored. See Also array Construct an array. zeros Create an array, each element of which is zero. empty Create an array, but leave its allocated memory unchanged (i.e., it contains \u201cgarbage\u201d). dtype Create a data-type. Notes There are two modes of creating an array using __new__ : If buffer is None, then only shape , dtype , and order are used. If buffer is an object exposing the buffer interface, then all keywords are interpreted. No __init__ method is needed because the array is fully initialized after the __new__ method. Examples These examples illustrate the low-level ndarray constructor. Refer to the See Also section above for easier ways of constructing an ndarray. First mode, buffer is None: >>> np.ndarray(shape=(2,2), dtype=float, order='F') array([[0.0e+000, 0.0e+000], # random [ nan, 2.5e-323]]) Second mode: >>> np.ndarray((2,), buffer=np.array([1,2,3]), ... offset=np.int_().itemsize, ... dtype=int) # offset = 1*itemsize, i.e. skip first element array([2, 3]) Ancestors Structural_Vector numpy.ndarray Class variables var tag Instance variables var c Removes rows corresponding to element hinges/releases var i Removes rows corresponding to redundant forces var x Removes rows of corresponding to primary forces class Diag_matrix ( arry, rc_data, model) Block diagonal matrix of element flexibility/stiffness matrices for structural model this class represents the block diagonal matrix of element flexibility or stiffness matrices for a structural model. Parameters model Ancestors Structural_Matrix numpy.ndarray Class variables var tag Instance variables var c Removes columns corresponding to element hinges/releases Inherited members Structural_Matrix : del_zeros ker lns nls rank remove round class Displacement_vector ( Kinematic_matrix, Vector=None) ndarray(shape, dtype=float, buffer=None, offset=0, strides=None, order=None) An array object represents a multidimensional, homogeneous array of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, or something else, etc.) Arrays should be constructed using array , zeros or empty (refer to the See Also section below). The parameters given here refer to a low-level method ( ndarray(\u2026) ) for instantiating an array. For more information, refer to the numpy module and examine the methods and attributes of an array. Parameters (for the new method; see Notes below) shape :\u2002 tuple of ints Shape of created array. dtype :\u2002 data-type , optional Any object that can be interpreted as a numpy data type. buffer :\u2002 object exposing buffer interface , optional Used to fill the array with data. offset :\u2002 int , optional Offset of array data in buffer. strides :\u2002 tuple of ints , optional Strides of data in memory. order :\u2002 {'C', 'F'} , optional Row-major (C-style) or column-major (Fortran-style) order. Attributes T :\u2002 ndarray Transpose of the array. data :\u2002 buffer The array\u2019s elements, in memory. dtype :\u2002 dtype object Describes the format of the elements in the array. flags :\u2002 dict Dictionary containing information related to memory use, e.g., \u2018C_CONTIGUOUS,\u2019 \u2018OWNDATA,\u2019 \u2018WRITEABLE,\u2019 etc. flat :\u2002 numpy.flatiter object Flattened version of the array as an iterator. The iterator allows assignments, e.g., x.flat = 3 (See ndarray.flat for assignment examples; TODO). imag :\u2002 ndarray Imaginary part of the array. real :\u2002 ndarray Real part of the array. size :\u2002 int Number of elements in the array. itemsize :\u2002 int The memory use of each array element in bytes. nbytes :\u2002 int The total number of bytes required to store the array data, i.e., itemsize * size . ndim :\u2002 int The array\u2019s number of dimensions. shape :\u2002 tuple of ints Shape of the array. strides :\u2002 tuple of ints The step-size required to move from one element to the next in memory. For example, a contiguous (3, 4) array of type int16 in C-order has strides (8, 2) . This implies that to move from element to element in memory requires jumps of 2 bytes. To move from row-to-row, one needs to jump 8 bytes at a time ( 2 * 4 ). ctypes :\u2002 ctypes object Class containing properties of the array needed for interaction with ctypes. base :\u2002 ndarray If the array is a view into another array, that array is its base (unless that array is also a view). The base array is where the array data is actually stored. See Also array Construct an array. zeros Create an array, each element of which is zero. empty Create an array, but leave its allocated memory unchanged (i.e., it contains \u201cgarbage\u201d). dtype Create a data-type. Notes There are two modes of creating an array using __new__ : If buffer is None, then only shape , dtype , and order are used. If buffer is an object exposing the buffer interface, then all keywords are interpreted. No __init__ method is needed because the array is fully initialized after the __new__ method. Examples These examples illustrate the low-level ndarray constructor. Refer to the See Also section above for easier ways of constructing an ndarray. First mode, buffer is None: >>> np.ndarray(shape=(2,2), dtype=float, order='F') array([[0.0e+000, 0.0e+000], # random [ nan, 2.5e-323]]) Second mode: >>> np.ndarray((2,), buffer=np.array([1,2,3]), ... offset=np.int_().itemsize, ... dtype=int) # offset = 1*itemsize, i.e. skip first element array([2, 3]) Ancestors column_vector Structural_Vector numpy.ndarray Class variables var tag Instance variables var f Removes rows corresponding to fixed dofs class Flexibility_matrix ( model, Roption=True) Parameters model Ancestors Structural_Matrix numpy.ndarray Class variables var tag Instance variables var c Removes rows corresponding to element hinges/releases Inherited members Structural_Matrix : del_zeros ker lns nls rank remove round class Kinematic_matrix ( model, matrix=None, rng=None) Class for the kinematic matrix of a structural model with 2d/3d truss and 2d frame elements the function forms the kinematic matrix A for all degrees of freedom and all element deformations of the structural model specified in data structure MODEL the function is currently limited to 2d/3d truss and 2d frame elements Returns Kinematic matrix Ancestors Structural_Matrix numpy.ndarray Class variables var ranges Instance variables var c Removes rows corresponding to element hinges/releases var c0 var d Removes columns corresponding to free dofs var e var f Removes columns corresponding to fixed dofs var i Removes rows corresponding to redundant forces var o Methods def combine ( self, component) Inherited members Structural_Matrix : del_zeros ker lns nls rank remove round class Mass_matrix ( mat) ndarray(shape, dtype=float, buffer=None, offset=0, strides=None, order=None) An array object represents a multidimensional, homogeneous array of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, or something else, etc.) Arrays should be constructed using array , zeros or empty (refer to the See Also section below). The parameters given here refer to a low-level method ( ndarray(\u2026) ) for instantiating an array. For more information, refer to the numpy module and examine the methods and attributes of an array. Parameters (for the new method; see Notes below) shape :\u2002 tuple of ints Shape of created array. dtype :\u2002 data-type , optional Any object that can be interpreted as a numpy data type. buffer :\u2002 object exposing buffer interface , optional Used to fill the array with data. offset :\u2002 int , optional Offset of array data in buffer. strides :\u2002 tuple of ints , optional Strides of data in memory. order :\u2002 {'C', 'F'} , optional Row-major (C-style) or column-major (Fortran-style) order. Attributes T :\u2002 ndarray Transpose of the array. data :\u2002 buffer The array\u2019s elements, in memory. dtype :\u2002 dtype object Describes the format of the elements in the array. flags :\u2002 dict Dictionary containing information related to memory use, e.g., \u2018C_CONTIGUOUS,\u2019 \u2018OWNDATA,\u2019 \u2018WRITEABLE,\u2019 etc. flat :\u2002 numpy.flatiter object Flattened version of the array as an iterator. The iterator allows assignments, e.g., x.flat = 3 (See ndarray.flat for assignment examples; TODO). imag :\u2002 ndarray Imaginary part of the array. real :\u2002 ndarray Real part of the array. size :\u2002 int Number of elements in the array. itemsize :\u2002 int The memory use of each array element in bytes. nbytes :\u2002 int The total number of bytes required to store the array data, i.e., itemsize * size . ndim :\u2002 int The array\u2019s number of dimensions. shape :\u2002 tuple of ints Shape of the array. strides :\u2002 tuple of ints The step-size required to move from one element to the next in memory. For example, a contiguous (3, 4) array of type int16 in C-order has strides (8, 2) . This implies that to move from element to element in memory requires jumps of 2 bytes. To move from row-to-row, one needs to jump 8 bytes at a time ( 2 * 4 ). ctypes :\u2002 ctypes object Class containing properties of the array needed for interaction with ctypes. base :\u2002 ndarray If the array is a view into another array, that array is its base (unless that array is also a view). The base array is where the array data is actually stored. See Also array Construct an array. zeros Create an array, each element of which is zero. empty Create an array, but leave its allocated memory unchanged (i.e., it contains \u201cgarbage\u201d). dtype Create a data-type. Notes There are two modes of creating an array using __new__ : If buffer is None, then only shape , dtype , and order are used. If buffer is an object exposing the buffer interface, then all keywords are interpreted. No __init__ method is needed because the array is fully initialized after the __new__ method. Examples These examples illustrate the low-level ndarray constructor. Refer to the See Also section above for easier ways of constructing an ndarray. First mode, buffer is None: >>> np.ndarray(shape=(2,2), dtype=float, order='F') array([[0.0e+000, 0.0e+000], # random [ nan, 2.5e-323]]) Second mode: >>> np.ndarray((2,), buffer=np.array([1,2,3]), ... offset=np.int_().itemsize, ... dtype=int) # offset = 1*itemsize, i.e. skip first element array([2, 3]) Ancestors Structural_Matrix numpy.ndarray Class variables var tag Instance variables var f var m Inherited members Structural_Matrix : del_zeros ker lns nls rank remove round class Static_matrix ( model, matrix=None, rng=None) B_MATRIX static matrix of structural model with 2d/3d truss and 2d frame elements the function forms the static matrix B for all degrees of freedom and all basic forces of the structural model specified in data structure MODEL; the function is currently limited to 2d/3d truss and 2d frame elements Parameters model :\u2002 emme.Model object Partitions ========================================================================================= B.f : nf x ntq B.c : nf x nq B.fc : nf x nq B.i : ni x nq B.x : nx x nq where: ni: number of primary (non-redundant) forces. nq: number of total, continuous forces. nx: number of redundant forces. Ancestors Structural_Matrix numpy.ndarray Class variables var ranges Instance variables var bari var barx var barxi var c var c0 var d Removes rows corresponding to free dofs var f var fc var i Removes rows of B_matrix corresponding to primary (non-redundant) forces var o Remove columns corresponding to element force releases, then delete zeros var x Removes rows of B_matrix corresponding to primary (non-redundant) forces Inherited members Structural_Matrix : del_zeros ker lns nls rank remove round class Stiffness_matrix ( arry, model, Roption=None) \u2026 Parameters ============ model Ancestors Structural_Matrix numpy.ndarray Class variables var tag Instance variables var f Inherited members Structural_Matrix : del_zeros ker lns nls rank remove round class Structural_Matrix ( mat) ndarray(shape, dtype=float, buffer=None, offset=0, strides=None, order=None) An array object represents a multidimensional, homogeneous array of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, or something else, etc.) Arrays should be constructed using array , zeros or empty (refer to the See Also section below). The parameters given here refer to a low-level method ( ndarray(\u2026) ) for instantiating an array. For more information, refer to the numpy module and examine the methods and attributes of an array. Parameters (for the new method; see Notes below) shape :\u2002 tuple of ints Shape of created array. dtype :\u2002 data-type , optional Any object that can be interpreted as a numpy data type. buffer :\u2002 object exposing buffer interface , optional Used to fill the array with data. offset :\u2002 int , optional Offset of array data in buffer. strides :\u2002 tuple of ints , optional Strides of data in memory. order :\u2002 {'C', 'F'} , optional Row-major (C-style) or column-major (Fortran-style) order. Attributes T :\u2002 ndarray Transpose of the array. data :\u2002 buffer The array\u2019s elements, in memory. dtype :\u2002 dtype object Describes the format of the elements in the array. flags :\u2002 dict Dictionary containing information related to memory use, e.g., \u2018C_CONTIGUOUS,\u2019 \u2018OWNDATA,\u2019 \u2018WRITEABLE,\u2019 etc. flat :\u2002 numpy.flatiter object Flattened version of the array as an iterator. The iterator allows assignments, e.g., x.flat = 3 (See ndarray.flat for assignment examples; TODO). imag :\u2002 ndarray Imaginary part of the array. real :\u2002 ndarray Real part of the array. size :\u2002 int Number of elements in the array. itemsize :\u2002 int The memory use of each array element in bytes. nbytes :\u2002 int The total number of bytes required to store the array data, i.e., itemsize * size . ndim :\u2002 int The array\u2019s number of dimensions. shape :\u2002 tuple of ints Shape of the array. strides :\u2002 tuple of ints The step-size required to move from one element to the next in memory. For example, a contiguous (3, 4) array of type int16 in C-order has strides (8, 2) . This implies that to move from element to element in memory requires jumps of 2 bytes. To move from row-to-row, one needs to jump 8 bytes at a time ( 2 * 4 ). ctypes :\u2002 ctypes object Class containing properties of the array needed for interaction with ctypes. base :\u2002 ndarray If the array is a view into another array, that array is its base (unless that array is also a view). The base array is where the array data is actually stored. See Also array Construct an array. zeros Create an array, each element of which is zero. empty Create an array, but leave its allocated memory unchanged (i.e., it contains \u201cgarbage\u201d). dtype Create a data-type. Notes There are two modes of creating an array using __new__ : If buffer is None, then only shape , dtype , and order are used. If buffer is an object exposing the buffer interface, then all keywords are interpreted. No __init__ method is needed because the array is fully initialized after the __new__ method. Examples These examples illustrate the low-level ndarray constructor. Refer to the See Also section above for easier ways of constructing an ndarray. First mode, buffer is None: >>> np.ndarray(shape=(2,2), dtype=float, order='F') array([[0.0e+000, 0.0e+000], # random [ nan, 2.5e-323]]) Second mode: >>> np.ndarray((2,), buffer=np.array([1,2,3]), ... offset=np.int_().itemsize, ... dtype=int) # offset = 1*itemsize, i.e. skip first element array([2, 3]) Ancestors numpy.ndarray Subclasses Diag_matrix Flexibility_matrix Kinematic_matrix Mass_matrix Static_matrix Stiffness_matrix nKinematic_matrix nStatic_matrix Class variables var c_cidx var c_ridx var column_data var row_data var tag Instance variables var c var df var disp var inv var ker Return a basis for the kernel (nullspace) of a matrix. var lns Return a basis for the left nullspace of a matrix. var nls return a basis for the nullspace of matrix. var rank Return the rank of a matrix Methods def add_cols ( self, component) def add_rows ( self, component) def del_zeros ( self) Delete rows and columns of a matrix with all zeros def get ( self, row_name, col_name) def lu ( self) def remove ( self, component) Remove items by looking up column_data/row_data def round ( self, num) a.round(decimals=0, out=None) Return a with each element rounded to the given number of decimals. Refer to numpy.around for full documentation. See Also numpy.around equivalent function def rows ( self, component) class Structural_Vector ( mat) ndarray(shape, dtype=float, buffer=None, offset=0, strides=None, order=None) An array object represents a multidimensional, homogeneous array of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, or something else, etc.) Arrays should be constructed using array , zeros or empty (refer to the See Also section below). The parameters given here refer to a low-level method ( ndarray(\u2026) ) for instantiating an array. For more information, refer to the numpy module and examine the methods and attributes of an array. Parameters (for the new method; see Notes below) shape :\u2002 tuple of ints Shape of created array. dtype :\u2002 data-type , optional Any object that can be interpreted as a numpy data type. buffer :\u2002 object exposing buffer interface , optional Used to fill the array with data. offset :\u2002 int , optional Offset of array data in buffer. strides :\u2002 tuple of ints , optional Strides of data in memory. order :\u2002 {'C', 'F'} , optional Row-major (C-style) or column-major (Fortran-style) order. Attributes T :\u2002 ndarray Transpose of the array. data :\u2002 buffer The array\u2019s elements, in memory. dtype :\u2002 dtype object Describes the format of the elements in the array. flags :\u2002 dict Dictionary containing information related to memory use, e.g., \u2018C_CONTIGUOUS,\u2019 \u2018OWNDATA,\u2019 \u2018WRITEABLE,\u2019 etc. flat :\u2002 numpy.flatiter object Flattened version of the array as an iterator. The iterator allows assignments, e.g., x.flat = 3 (See ndarray.flat for assignment examples; TODO). imag :\u2002 ndarray Imaginary part of the array. real :\u2002 ndarray Real part of the array. size :\u2002 int Number of elements in the array. itemsize :\u2002 int The memory use of each array element in bytes. nbytes :\u2002 int The total number of bytes required to store the array data, i.e., itemsize * size . ndim :\u2002 int The array\u2019s number of dimensions. shape :\u2002 tuple of ints Shape of the array. strides :\u2002 tuple of ints The step-size required to move from one element to the next in memory. For example, a contiguous (3, 4) array of type int16 in C-order has strides (8, 2) . This implies that to move from element to element in memory requires jumps of 2 bytes. To move from row-to-row, one needs to jump 8 bytes at a time ( 2 * 4 ). ctypes :\u2002 ctypes object Class containing properties of the array needed for interaction with ctypes. base :\u2002 ndarray If the array is a view into another array, that array is its base (unless that array is also a view). The base array is where the array data is actually stored. See Also array Construct an array. zeros Create an array, each element of which is zero. empty Create an array, but leave its allocated memory unchanged (i.e., it contains \u201cgarbage\u201d). dtype Create a data-type. Notes There are two modes of creating an array using __new__ : If buffer is None, then only shape , dtype , and order are used. If buffer is an object exposing the buffer interface, then all keywords are interpreted. No __init__ method is needed because the array is fully initialized after the __new__ method. Examples These examples illustrate the low-level ndarray constructor. Refer to the See Also section above for easier ways of constructing an ndarray. First mode, buffer is None: >>> np.ndarray(shape=(2,2), dtype=float, order='F') array([[0.0e+000, 0.0e+000], # random [ nan, 2.5e-323]]) Second mode: >>> np.ndarray((2,), buffer=np.array([1,2,3]), ... offset=np.int_().itemsize, ... dtype=int) # offset = 1*itemsize, i.e. skip first element array([2, 3]) Ancestors numpy.ndarray Subclasses Deformation_vector column_vector iForce_vector nDisplacement_vector nForce_vector row_vector Class variables var column_data var row_data var subs var tag Instance variables var df var disp var symb Methods def get ( self, key) def rows ( self, component) def set_item ( self, key, value) class column_vector ( Matrix, Vector=None) ndarray(shape, dtype=float, buffer=None, offset=0, strides=None, order=None) An array object represents a multidimensional, homogeneous array of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, or something else, etc.) Arrays should be constructed using array , zeros or empty (refer to the See Also section below). The parameters given here refer to a low-level method ( ndarray(\u2026) ) for instantiating an array. For more information, refer to the numpy module and examine the methods and attributes of an array. Parameters (for the new method; see Notes below) shape :\u2002 tuple of ints Shape of created array. dtype :\u2002 data-type , optional Any object that can be interpreted as a numpy data type. buffer :\u2002 object exposing buffer interface , optional Used to fill the array with data. offset :\u2002 int , optional Offset of array data in buffer. strides :\u2002 tuple of ints , optional Strides of data in memory. order :\u2002 {'C', 'F'} , optional Row-major (C-style) or column-major (Fortran-style) order. Attributes T :\u2002 ndarray Transpose of the array. data :\u2002 buffer The array\u2019s elements, in memory. dtype :\u2002 dtype object Describes the format of the elements in the array. flags :\u2002 dict Dictionary containing information related to memory use, e.g., \u2018C_CONTIGUOUS,\u2019 \u2018OWNDATA,\u2019 \u2018WRITEABLE,\u2019 etc. flat :\u2002 numpy.flatiter object Flattened version of the array as an iterator. The iterator allows assignments, e.g., x.flat = 3 (See ndarray.flat for assignment examples; TODO). imag :\u2002 ndarray Imaginary part of the array. real :\u2002 ndarray Real part of the array. size :\u2002 int Number of elements in the array. itemsize :\u2002 int The memory use of each array element in bytes. nbytes :\u2002 int The total number of bytes required to store the array data, i.e., itemsize * size . ndim :\u2002 int The array\u2019s number of dimensions. shape :\u2002 tuple of ints Shape of the array. strides :\u2002 tuple of ints The step-size required to move from one element to the next in memory. For example, a contiguous (3, 4) array of type int16 in C-order has strides (8, 2) . This implies that to move from element to element in memory requires jumps of 2 bytes. To move from row-to-row, one needs to jump 8 bytes at a time ( 2 * 4 ). ctypes :\u2002 ctypes object Class containing properties of the array needed for interaction with ctypes. base :\u2002 ndarray If the array is a view into another array, that array is its base (unless that array is also a view). The base array is where the array data is actually stored. See Also array Construct an array. zeros Create an array, each element of which is zero. empty Create an array, but leave its allocated memory unchanged (i.e., it contains \u201cgarbage\u201d). dtype Create a data-type. Notes There are two modes of creating an array using __new__ : If buffer is None, then only shape , dtype , and order are used. If buffer is an object exposing the buffer interface, then all keywords are interpreted. No __init__ method is needed because the array is fully initialized after the __new__ method. Examples These examples illustrate the low-level ndarray constructor. Refer to the See Also section above for easier ways of constructing an ndarray. First mode, buffer is None: >>> np.ndarray(shape=(2,2), dtype=float, order='F') array([[0.0e+000, 0.0e+000], # random [ nan, 2.5e-323]]) Second mode: >>> np.ndarray((2,), buffer=np.array([1,2,3]), ... offset=np.int_().itemsize, ... dtype=int) # offset = 1*itemsize, i.e. skip first element array([2, 3]) Ancestors Structural_Vector numpy.ndarray Subclasses Displacement_vector class iForce_vector ( arry, model, row_data, Vector=None) ndarray(shape, dtype=float, buffer=None, offset=0, strides=None, order=None) An array object represents a multidimensional, homogeneous array of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, or something else, etc.) Arrays should be constructed using array , zeros or empty (refer to the See Also section below). The parameters given here refer to a low-level method ( ndarray(\u2026) ) for instantiating an array. For more information, refer to the numpy module and examine the methods and attributes of an array. Parameters (for the new method; see Notes below) shape :\u2002 tuple of ints Shape of created array. dtype :\u2002 data-type , optional Any object that can be interpreted as a numpy data type. buffer :\u2002 object exposing buffer interface , optional Used to fill the array with data. offset :\u2002 int , optional Offset of array data in buffer. strides :\u2002 tuple of ints , optional Strides of data in memory. order :\u2002 {'C', 'F'} , optional Row-major (C-style) or column-major (Fortran-style) order. Attributes T :\u2002 ndarray Transpose of the array. data :\u2002 buffer The array\u2019s elements, in memory. dtype :\u2002 dtype object Describes the format of the elements in the array. flags :\u2002 dict Dictionary containing information related to memory use, e.g., \u2018C_CONTIGUOUS,\u2019 \u2018OWNDATA,\u2019 \u2018WRITEABLE,\u2019 etc. flat :\u2002 numpy.flatiter object Flattened version of the array as an iterator. The iterator allows assignments, e.g., x.flat = 3 (See ndarray.flat for assignment examples; TODO). imag :\u2002 ndarray Imaginary part of the array. real :\u2002 ndarray Real part of the array. size :\u2002 int Number of elements in the array. itemsize :\u2002 int The memory use of each array element in bytes. nbytes :\u2002 int The total number of bytes required to store the array data, i.e., itemsize * size . ndim :\u2002 int The array\u2019s number of dimensions. shape :\u2002 tuple of ints Shape of the array. strides :\u2002 tuple of ints The step-size required to move from one element to the next in memory. For example, a contiguous (3, 4) array of type int16 in C-order has strides (8, 2) . This implies that to move from element to element in memory requires jumps of 2 bytes. To move from row-to-row, one needs to jump 8 bytes at a time ( 2 * 4 ). ctypes :\u2002 ctypes object Class containing properties of the array needed for interaction with ctypes. base :\u2002 ndarray If the array is a view into another array, that array is its base (unless that array is also a view). The base array is where the array data is actually stored. See Also array Construct an array. zeros Create an array, each element of which is zero. empty Create an array, but leave its allocated memory unchanged (i.e., it contains \u201cgarbage\u201d). dtype Create a data-type. Notes There are two modes of creating an array using __new__ : If buffer is None, then only shape , dtype , and order are used. If buffer is an object exposing the buffer interface, then all keywords are interpreted. No __init__ method is needed because the array is fully initialized after the __new__ method. Examples These examples illustrate the low-level ndarray constructor. Refer to the See Also section above for easier ways of constructing an ndarray. First mode, buffer is None: >>> np.ndarray(shape=(2,2), dtype=float, order='F') array([[0.0e+000, 0.0e+000], # random [ nan, 2.5e-323]]) Second mode: >>> np.ndarray((2,), buffer=np.array([1,2,3]), ... offset=np.int_().itemsize, ... dtype=int) # offset = 1*itemsize, i.e. skip first element array([2, 3]) Ancestors Structural_Vector numpy.ndarray Class variables var tag Instance variables var c Remove rows corresponding to element hinges/releases var i Removes rows corresponding to redundant forces var x Remove rows of corresponding to primary forces class nDisplacement_vector ( arry, model, row_data, Vector=None) ndarray(shape, dtype=float, buffer=None, offset=0, strides=None, order=None) An array object represents a multidimensional, homogeneous array of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, or something else, etc.) Arrays should be constructed using array , zeros or empty (refer to the See Also section below). The parameters given here refer to a low-level method ( ndarray(\u2026) ) for instantiating an array. For more information, refer to the numpy module and examine the methods and attributes of an array. Parameters (for the new method; see Notes below) shape :\u2002 tuple of ints Shape of created array. dtype :\u2002 data-type , optional Any object that can be interpreted as a numpy data type. buffer :\u2002 object exposing buffer interface , optional Used to fill the array with data. offset :\u2002 int , optional Offset of array data in buffer. strides :\u2002 tuple of ints , optional Strides of data in memory. order :\u2002 {'C', 'F'} , optional Row-major (C-style) or column-major (Fortran-style) order. Attributes T :\u2002 ndarray Transpose of the array. data :\u2002 buffer The array\u2019s elements, in memory. dtype :\u2002 dtype object Describes the format of the elements in the array. flags :\u2002 dict Dictionary containing information related to memory use, e.g., \u2018C_CONTIGUOUS,\u2019 \u2018OWNDATA,\u2019 \u2018WRITEABLE,\u2019 etc. flat :\u2002 numpy.flatiter object Flattened version of the array as an iterator. The iterator allows assignments, e.g., x.flat = 3 (See ndarray.flat for assignment examples; TODO). imag :\u2002 ndarray Imaginary part of the array. real :\u2002 ndarray Real part of the array. size :\u2002 int Number of elements in the array. itemsize :\u2002 int The memory use of each array element in bytes. nbytes :\u2002 int The total number of bytes required to store the array data, i.e., itemsize * size . ndim :\u2002 int The array\u2019s number of dimensions. shape :\u2002 tuple of ints Shape of the array. strides :\u2002 tuple of ints The step-size required to move from one element to the next in memory. For example, a contiguous (3, 4) array of type int16 in C-order has strides (8, 2) . This implies that to move from element to element in memory requires jumps of 2 bytes. To move from row-to-row, one needs to jump 8 bytes at a time ( 2 * 4 ). ctypes :\u2002 ctypes object Class containing properties of the array needed for interaction with ctypes. base :\u2002 ndarray If the array is a view into another array, that array is its base (unless that array is also a view). The base array is where the array data is actually stored. See Also array Construct an array. zeros Create an array, each element of which is zero. empty Create an array, but leave its allocated memory unchanged (i.e., it contains \u201cgarbage\u201d). dtype Create a data-type. Notes There are two modes of creating an array using __new__ : If buffer is None, then only shape , dtype , and order are used. If buffer is an object exposing the buffer interface, then all keywords are interpreted. No __init__ method is needed because the array is fully initialized after the __new__ method. Examples These examples illustrate the low-level ndarray constructor. Refer to the See Also section above for easier ways of constructing an ndarray. First mode, buffer is None: >>> np.ndarray(shape=(2,2), dtype=float, order='F') array([[0.0e+000, 0.0e+000], # random [ nan, 2.5e-323]]) Second mode: >>> np.ndarray((2,), buffer=np.array([1,2,3]), ... offset=np.int_().itemsize, ... dtype=int) # offset = 1*itemsize, i.e. skip first element array([2, 3]) Ancestors Structural_Vector numpy.ndarray Class variables var tag Instance variables var f Removes rows corresponding to fixed dofs class nForce_vector ( arry, model, row_data, Vector=None) ndarray(shape, dtype=float, buffer=None, offset=0, strides=None, order=None) An array object represents a multidimensional, homogeneous array of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, or something else, etc.) Arrays should be constructed using array , zeros or empty (refer to the See Also section below). The parameters given here refer to a low-level method ( ndarray(\u2026) ) for instantiating an array. For more information, refer to the numpy module and examine the methods and attributes of an array. Parameters (for the new method; see Notes below) shape :\u2002 tuple of ints Shape of created array. dtype :\u2002 data-type , optional Any object that can be interpreted as a numpy data type. buffer :\u2002 object exposing buffer interface , optional Used to fill the array with data. offset :\u2002 int , optional Offset of array data in buffer. strides :\u2002 tuple of ints , optional Strides of data in memory. order :\u2002 {'C', 'F'} , optional Row-major (C-style) or column-major (Fortran-style) order. Attributes T :\u2002 ndarray Transpose of the array. data :\u2002 buffer The array\u2019s elements, in memory. dtype :\u2002 dtype object Describes the format of the elements in the array. flags :\u2002 dict Dictionary containing information related to memory use, e.g., \u2018C_CONTIGUOUS,\u2019 \u2018OWNDATA,\u2019 \u2018WRITEABLE,\u2019 etc. flat :\u2002 numpy.flatiter object Flattened version of the array as an iterator. The iterator allows assignments, e.g., x.flat = 3 (See ndarray.flat for assignment examples; TODO). imag :\u2002 ndarray Imaginary part of the array. real :\u2002 ndarray Real part of the array. size :\u2002 int Number of elements in the array. itemsize :\u2002 int The memory use of each array element in bytes. nbytes :\u2002 int The total number of bytes required to store the array data, i.e., itemsize * size . ndim :\u2002 int The array\u2019s number of dimensions. shape :\u2002 tuple of ints Shape of the array. strides :\u2002 tuple of ints The step-size required to move from one element to the next in memory. For example, a contiguous (3, 4) array of type int16 in C-order has strides (8, 2) . This implies that to move from element to element in memory requires jumps of 2 bytes. To move from row-to-row, one needs to jump 8 bytes at a time ( 2 * 4 ). ctypes :\u2002 ctypes object Class containing properties of the array needed for interaction with ctypes. base :\u2002 ndarray If the array is a view into another array, that array is its base (unless that array is also a view). The base array is where the array data is actually stored. See Also array Construct an array. zeros Create an array, each element of which is zero. empty Create an array, but leave its allocated memory unchanged (i.e., it contains \u201cgarbage\u201d). dtype Create a data-type. Notes There are two modes of creating an array using __new__ : If buffer is None, then only shape , dtype , and order are used. If buffer is an object exposing the buffer interface, then all keywords are interpreted. No __init__ method is needed because the array is fully initialized after the __new__ method. Examples These examples illustrate the low-level ndarray constructor. Refer to the See Also section above for easier ways of constructing an ndarray. First mode, buffer is None: >>> np.ndarray(shape=(2,2), dtype=float, order='F') array([[0.0e+000, 0.0e+000], # random [ nan, 2.5e-323]]) Second mode: >>> np.ndarray((2,), buffer=np.array([1,2,3]), ... offset=np.int_().itemsize, ... dtype=int) # offset = 1*itemsize, i.e. skip first element array([2, 3]) Ancestors Structural_Vector numpy.ndarray Class variables var tag Instance variables var d Removes rows corresponding to free dofs var f class nKinematic_matrix ( arry, model, rcdata) Class for the kinematic matrix of a structural model with 2d/3d truss and 2d frame elements the function forms the kinematic matrix A for all degrees of freedom and all element deformations of the structural model specified in data structure MODEL the function is currently limited to 2d/3d truss and 2d frame elements Returns Kinematic matrix Ancestors Structural_Matrix numpy.ndarray Class variables var ranges Instance variables var c Removes rows corresponding to element hinges/releases var c0 var d Removes columns corresponding to free dofs var e var f Removes columns corresponding to fixed dofs var i Removes rows corresponding to redundant forces var o Methods def combine ( self, component) Inherited members Structural_Matrix : del_zeros ker lns nls rank remove round class nStatic_matrix ( arry, model, rcdata) ndarray(shape, dtype=float, buffer=None, offset=0, strides=None, order=None) An array object represents a multidimensional, homogeneous array of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, or something else, etc.) Arrays should be constructed using array , zeros or empty (refer to the See Also section below). The parameters given here refer to a low-level method ( ndarray(\u2026) ) for instantiating an array. For more information, refer to the numpy module and examine the methods and attributes of an array. Parameters (for the new method; see Notes below) shape :\u2002 tuple of ints Shape of created array. dtype :\u2002 data-type , optional Any object that can be interpreted as a numpy data type. buffer :\u2002 object exposing buffer interface , optional Used to fill the array with data. offset :\u2002 int , optional Offset of array data in buffer. strides :\u2002 tuple of ints , optional Strides of data in memory. order :\u2002 {'C', 'F'} , optional Row-major (C-style) or column-major (Fortran-style) order. Attributes T :\u2002 ndarray Transpose of the array. data :\u2002 buffer The array\u2019s elements, in memory. dtype :\u2002 dtype object Describes the format of the elements in the array. flags :\u2002 dict Dictionary containing information related to memory use, e.g., \u2018C_CONTIGUOUS,\u2019 \u2018OWNDATA,\u2019 \u2018WRITEABLE,\u2019 etc. flat :\u2002 numpy.flatiter object Flattened version of the array as an iterator. The iterator allows assignments, e.g., x.flat = 3 (See ndarray.flat for assignment examples; TODO). imag :\u2002 ndarray Imaginary part of the array. real :\u2002 ndarray Real part of the array. size :\u2002 int Number of elements in the array. itemsize :\u2002 int The memory use of each array element in bytes. nbytes :\u2002 int The total number of bytes required to store the array data, i.e., itemsize * size . ndim :\u2002 int The array\u2019s number of dimensions. shape :\u2002 tuple of ints Shape of the array. strides :\u2002 tuple of ints The step-size required to move from one element to the next in memory. For example, a contiguous (3, 4) array of type int16 in C-order has strides (8, 2) . This implies that to move from element to element in memory requires jumps of 2 bytes. To move from row-to-row, one needs to jump 8 bytes at a time ( 2 * 4 ). ctypes :\u2002 ctypes object Class containing properties of the array needed for interaction with ctypes. base :\u2002 ndarray If the array is a view into another array, that array is its base (unless that array is also a view). The base array is where the array data is actually stored. See Also array Construct an array. zeros Create an array, each element of which is zero. empty Create an array, but leave its allocated memory unchanged (i.e., it contains \u201cgarbage\u201d). dtype Create a data-type. Notes There are two modes of creating an array using __new__ : If buffer is None, then only shape , dtype , and order are used. If buffer is an object exposing the buffer interface, then all keywords are interpreted. No __init__ method is needed because the array is fully initialized after the __new__ method. Examples These examples illustrate the low-level ndarray constructor. Refer to the See Also section above for easier ways of constructing an ndarray. First mode, buffer is None: >>> np.ndarray(shape=(2,2), dtype=float, order='F') array([[0.0e+000, 0.0e+000], # random [ nan, 2.5e-323]]) Second mode: >>> np.ndarray((2,), buffer=np.array([1,2,3]), ... offset=np.int_().itemsize, ... dtype=int) # offset = 1*itemsize, i.e. skip first element array([2, 3]) Ancestors Structural_Matrix numpy.ndarray Class variables var ranges Instance variables var bari var barx var barxi var c Removes columns corresponding to element hinges/releases var c0 var d Removes rows corresponding to free dofs var f var fc var i Removes rows of B_matrix corresponding to redundant forces var o Remove columns corresponding to element force releases, then delete zeros var x Removes rows of B_matrix corresponding to primary (non-redundant) forces Inherited members Structural_Matrix : del_zeros ker lns nls rank remove round class row_vector ( Matrix) ndarray(shape, dtype=float, buffer=None, offset=0, strides=None, order=None) An array object represents a multidimensional, homogeneous array of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, or something else, etc.) Arrays should be constructed using array , zeros or empty (refer to the See Also section below). The parameters given here refer to a low-level method ( ndarray(\u2026) ) for instantiating an array. For more information, refer to the numpy module and examine the methods and attributes of an array. Parameters (for the new method; see Notes below) shape :\u2002 tuple of ints Shape of created array. dtype :\u2002 data-type , optional Any object that can be interpreted as a numpy data type. buffer :\u2002 object exposing buffer interface , optional Used to fill the array with data. offset :\u2002 int , optional Offset of array data in buffer. strides :\u2002 tuple of ints , optional Strides of data in memory. order :\u2002 {'C', 'F'} , optional Row-major (C-style) or column-major (Fortran-style) order. Attributes T :\u2002 ndarray Transpose of the array. data :\u2002 buffer The array\u2019s elements, in memory. dtype :\u2002 dtype object Describes the format of the elements in the array. flags :\u2002 dict Dictionary containing information related to memory use, e.g., \u2018C_CONTIGUOUS,\u2019 \u2018OWNDATA,\u2019 \u2018WRITEABLE,\u2019 etc. flat :\u2002 numpy.flatiter object Flattened version of the array as an iterator. The iterator allows assignments, e.g., x.flat = 3 (See ndarray.flat for assignment examples; TODO). imag :\u2002 ndarray Imaginary part of the array. real :\u2002 ndarray Real part of the array. size :\u2002 int Number of elements in the array. itemsize :\u2002 int The memory use of each array element in bytes. nbytes :\u2002 int The total number of bytes required to store the array data, i.e., itemsize * size . ndim :\u2002 int The array\u2019s number of dimensions. shape :\u2002 tuple of ints Shape of the array. strides :\u2002 tuple of ints The step-size required to move from one element to the next in memory. For example, a contiguous (3, 4) array of type int16 in C-order has strides (8, 2) . This implies that to move from element to element in memory requires jumps of 2 bytes. To move from row-to-row, one needs to jump 8 bytes at a time ( 2 * 4 ). ctypes :\u2002 ctypes object Class containing properties of the array needed for interaction with ctypes. base :\u2002 ndarray If the array is a view into another array, that array is its base (unless that array is also a view). The base array is where the array data is actually stored. See Also array Construct an array. zeros Create an array, each element of which is zero. empty Create an array, but leave its allocated memory unchanged (i.e., it contains \u201cgarbage\u201d). dtype Create a data-type. Notes There are two modes of creating an array using __new__ : If buffer is None, then only shape , dtype , and order are used. If buffer is an object exposing the buffer interface, then all keywords are interpreted. No __init__ method is needed because the array is fully initialized after the __new__ method. Examples These examples illustrate the low-level ndarray constructor. Refer to the See Also section above for easier ways of constructing an ndarray. First mode, buffer is None: >>> np.ndarray(shape=(2,2), dtype=float, order='F') array([[0.0e+000, 0.0e+000], # random [ nan, 2.5e-323]]) Second mode: >>> np.ndarray((2,), buffer=np.array([1,2,3]), ... offset=np.int_().itemsize, ... dtype=int) # offset = 1*itemsize, i.e. skip first element array([2, 3]) Ancestors Structural_Vector numpy.ndarray","title":"anabel.matrices"},{"location":"api/latest/sections/","text":"Section Modeling High-level section modeling API. Functions def Composite_Section ( Y, DY, DZ, quad, y_shift=0.0, mat=None) def I_Sect ( b, d, alpha, beta, quad, yref=0.0, MatData=None) def TC_Sect ( d, bf, tw, quad, yref=0.0, tf=None, ymf=None, MatData=None, **kwds) def T_Sect ( d, quad, b=None, bf=None, tf=None, tw=None, alpha=None, beta=None, yref=0.0, MatData=None) def W_Sect ( b, d, alpha, beta, quadf, quadw, yref=0.0, MatData=None) def ei ( y, epsa, kappa) def epsi ( y, epsa, kappa) def load_aisc ( SectionName, props='') Load cross section properties from AISC database. props: A list of AISC properties, or one of the following: - \u2018simple\u2019: A , Ix , Zx def section2d ( yi, dA, nIP, mat, **kwds) Generate a section response function Studies Classes class Rectangle ( b, d, quad=None, yref=0.0, mat=None, **kwds) Rectangular cross section Ancestors Section class Section Subclasses Rectangle Tee Methods def assemble ( self) class Tee ( d=None, quad=None, b=None, bf=None, tf=None, tw=None, alpha=None, beta=None, yref=0.0, mat=None) Ancestors Section","title":"anabel.sections"},{"location":"api/latest/template/","text":"Templating. Functions def assemble ( f) def generator ( dim: Union[int, Tuple[Tuple[int, int]]] = None, statevar: str = 'state', main: str = 'main', jacx: str = 'jacx', form: str = 'x,y,s=s,p=p,**e->x,y,s', params: str = 'params', dimvar: str = None, origin: tuple = None, order: int = 0, **kwargs) \u2011> Callable Decorator that wraps a basic local map generator. Attributes origin : A structure containing arguments which may act as an \u2018origin\u2019 for the target function. shape : tuple Description of the shape of the dual and primal spaces. Generated Arguments _expose_closure : bool Expose closed-over local variables as an attribute. _jit : bool If True {.python}, JIT-compiles the target function Studies Structural dynamics ( elle-0008 ) def generator_no2 ( ) def F(): name = \u201cmy-element\u201d def main(x, y, state, **kwds, _name=name): pass def get_unspecified_parameters ( func, recurse=False) created 2021-03-31 def serialize ( f) Requires JAX def template ( dim: Union[int, Tuple[Tuple[int, int]]] = None, statevar: str = 'state', main: str = 'main', jacx: str = 'jacx', form: str = 'x,y,s=s,p=p,**e->x,y,s', params: str = 'params', dimvar: str = None, origin: tuple = None, order: int = 0, **kwargs) \u2011> Callable Decorator that wraps a basic local map generator. Attributes origin : A structure containing arguments which may act as an \u2018origin\u2019 for the target function. shape : tuple Description of the shape of the dual and primal spaces. Generated Arguments _expose_closure : bool Expose closed-over local variables as an attribute. _jit : bool If True {.python}, JIT-compiles the target function Studies Structural dynamics ( elle-0008 ) def wrap ( f, *args, **kwds) Wrap a pre-defined function to act as a local dual map. Classes class Dual","title":"anabel.template"},{"location":"gallery/","text":"Galleries","title":"Galleries"},{"location":"gallery/dynamics/","text":"Examples in Dynamics","title":"Dynamics"},{"location":"gallery/dynamics/225_HW09_P1/","text":"Modal Analysis - Beam import ema as em import matplotlib.pyplot as plt import numpy as np % config InlineBackend.figure_format = 'svg' L = 1 Mass = 100 n = 8 # adjust number of nodes along beam nf = 2 + (n - 2 ) * 2 nt = 3 * n - (n - 1 ) DOFs = [[nt - 2 , 0 , 0 ] for i in range (n)] # Build Model mdl = em.rModel( 2 , 3 ) nd = mdl.nodes for i in range (n): if i == 0 : mass = None DOFs[i][ 1 ] = nf + 2 DOFs[i][ 2 ] = nf - 1 elif i == n - 1 : mass = None DOFs[i][ 1 ] = nf + 3 DOFs[i][ 2 ] = nf else : mass = Mass / (n - 1 ) DOFs[i][ 1 ] = i DOFs[i][ 2 ] = i + (n - 2 ) mdl.node( str (i + 1 ), i * L / (n - 1 ), 0.0 , mass = mass) mdl.girder(nd) mdl.pin(nd[ 0 ]) mdl.fix(nd[ - 1 ], [ 'y' ]) mdl.DOF = DOFs fig, ax = plt.subplots() em.plot_beam(mdl, ax) svg K = em.K_matrix(mdl) M = em.Mass_matrix(mdl) shapes = em.analysis.ModalAnalysis(mdl) # shapes2 = em.analysis.ModalAnalysis(mdl2) U = em.U_vector(em.A_matrix(mdl)) colors = [ 'r' , 'b' , 'g' , 'y' , 'grey' , 'pink' ] # fig, ax = plt.subplots() for i, shape in enumerate (shapes[ 1 ]): U[ 0 :n - 2 ] = shape em.plot_modes(mdl, U, ax, color = colors[i], label = str (i + 1 )) plt.legend() ; No handles with labels found to put in legend. svg","title":"Modal Analysis - Beam"},{"location":"gallery/dynamics/225_HW09_P2v2/","text":"Modal analysis - 1r import ema as em import matplotlib.pyplot as plt import numpy as np % config InlineBackend.figure_format = 'svg' mdl = em.rModel( 2 , 3 ) n = mdl.dnodes e = mdl.delems w = 24 h = 12 mdl.frame(( 1 ,w), ( 3 ,h)) for node in n.values(): mdl.fix(node, 'rz' ) n[ '4' ].mass = 1 n[ '6' ].mass = 1 n[ '8' ].mass = 0.5 mdl.fix(n[ '1' ], [ 'x' , 'y' ]) mdl.fix(n[ '2' ], [ 'x' , 'y' ]) mdl.DOF = [[ 10 , 11 , 12 ], [ 13 , 14 , 15 ], [ 1 , 11 , 4 ], [ 1 , 14 , 5 ], [ 2 , 11 , 6 ], [ 2 , 14 , 7 ], [ 3 , 11 , 8 ], [ 3 , 14 , 9 ]] Part a) K = em.K_matrix(mdl) M = em.Mass_matrix(mdl) K.f * h ** 3 0 1 2 0 48.0 -24.0 0.0 1 -24.0 48.0 -24.0 2 0.0 -24.0 24.0 M.f $u_{{1}}$ $u_{{2}}$ $u_{{3}}$ $u_{{1}}$ 1.0 0.0 0.0 $u_{{2}}$ 0.0 1.0 0.0 $u_{{3}}$ 0.0 0.0 0.5 Part b) shapes = em.analysis.ModalAnalysis(mdl) shapes (array([0.05183404+0.j, 0.02777778+0.j, 0.00372152+0.j]), array([[ 4.08248290e-01, -8.16496581e-01, -4.08248290e-01], [-7.07106781e-01, -3.10316769e-16, -7.07106781e-01], [ 8.16496581e-01, 8.16496581e-01, -8.16496581e-01]])) U = em.U_vector(em.A_matrix(mdl)) colors = [ 'b' , 'y' , 'pink' ] fig, ax = plt.subplots( 1 , 3 ) for i, shape in enumerate (shapes[ 1 ].T): U[ 0 : 3 ] = shape em.plot_modes(mdl, U, ax[i], color = colors[i], label = str (i + 1 )) plt.legend() ; No handles with labels found to put in legend. svg Part c) Verify orthogonality phis = np.around(shapes[ 1 ], 7 ) phis array([[ 0.4082483, -0.8164966, -0.4082483], [-0.7071068, -0. , -0.7071068], [ 0.8164966, 0.8164966, -0.8164966]]) print (phis[:, 0 ] @ M.f @ phis[:, 1 ]) 0.0 print (phis[:, 0 ] @ M.f @ phis[:, 2 ]) 3.2475700462164525e-09 print (phis[:, 1 ] @ M.f @ phis[:, 2 ]) 0.0 Part d) Normalize modes. Each mode shape is normalized so that when multiplied by the problem variable, \\(\\frac{1}{\\sqrt{m}}\\) , they will generate a modal mass matrix, \\(M_n\\) , equal to the identity matrix. phi_n = np.zeros(( 3 , 3 )) phi_n[:, 0 ] = phis[:, 0 ] / ((phis[:, 0 ] @ M.f @ phis[:, 0 ])) ** ( 1 / 2 ) print (phi_n[:, 0 ]) phi_n[:, 0 ].T @ M.f @ phi_n[:, 0 ] [ 0.40824829 -0.70710678 0.81649658] C:\\Users\\claud\\Anaconda3\\lib\\site-packages\\IPython\\core\\formatters.py:371: FormatterWarning: text/html formatter returned invalid type <class 'ema.utilities.Structural_Vector'> (expected <class 'str'>) for object: Structural_Vector(1.) FormatterWarning Structural_Vector(1.) phi_n[:, 1 ] = phis[:, 1 ] / ((phis[:, 1 ] @ M.f @ phis[:, 1 ])) ** ( 1 / 2 ) print (phi_n[:, 1 ]) phi_n[:, 1 ].T @ M.f @ phi_n[:, 1 ] [-0.81649658 -0. 0.81649658] Structural_Vector(1.) phi_n[:, 2 ] = phis[:, 2 ] / ((phis[:, 2 ] @ M.f @ phis[:, 2 ])) ** ( 1 / 2 ) print (phi_n[:, 2 ]) phi_n[:, 2 ].T @ M.f @ phi_n[:, 2 ] [-0.40824829 -0.70710678 -0.81649658] Structural_Vector(1.) Id = np.around(phi_n.T @ M.f @ phi_n, 7 ) Id array([[ 1., 0., 0.], [ 0., 1., -0.], [ 0., -0., 1.]])","title":"Modal Analysis - 1r"},{"location":"gallery/dynamics/225_HW11_P2/","text":"Problem 2 (see Ex 9.6) # Remove import ema as em import matplotlib.pyplot as plt import numpy as np % config InlineBackend.figure_format = 'svg' # used to make plots look nicer from ema_examples.dynamics import E09_06 from ema.utilities.ipyutils import disp_sbs from scipy.linalg import eig L = 1 mass = 1 EI = 1 / 12 mdl = E09_06(L = L, m = mass, EI = EI) fig, ax = plt.subplots() em.plot_structure(mdl, ax) mdl.DOF [[7, 8, 9], [1, 2, 3], [4, 5, 6]] svg m, K = em.Mass_matrix(mdl), em.K_matrix(mdl) m[ 0 , 0 ] = 3. * mass m[ 1 , 1 ] = 1. * mass m[ 2 :, 2 :] = 0 * mass disp_sbs(m.f.df, K.f.df) $u_{{1}}$ $u_{{2}}$ $u_{{3}}$ $u_{{4}}$ $u_{{5}}$ $u_{{6}}$ $u_{{1}}$ 3.0 0.0 0.0 0.0 0.0 0.0 $u_{{2}}$ 0.0 1.0 0.0 0.0 0.0 0.0 $u_{{3}}$ 0.0 0.0 0.0 0.0 0.0 0.0 $u_{{4}}$ 0.0 0.0 0.0 0.0 0.0 0.0 $u_{{5}}$ 0.0 0.0 0.0 0.0 0.0 0.0 $u_{{6}}$ 0.0 0.0 0.0 0.0 0.0 0.0 $1$ $2$ $3$ $4$ $5$ $6$ $P_{1}$ 8334.333333 0.000000 0.500000 -8333.333333 0.0 0.000000 $P_{2}$ 0.000000 8334.333333 0.500000 0.000000 -1.0 0.500000 $P_{3}$ 0.500000 0.500000 0.666667 0.000000 -0.5 0.166667 $P_{4}$ -8333.333333 0.000000 0.000000 8333.333333 0.0 0.000000 $P_{5}$ 0.000000 -1.000000 -0.500000 0.000000 1.0 -0.500000 $P_{6}$ 0.000000 0.500000 0.166667 0.000000 -0.5 0.333333 # k, m = em.analysis.StaticCondensation(k.f, m.f, idxs=[3,4]) k = em.analysis.kStaticCondensation(K.f, idxs = [ 3 , 4 ]) # disp_sbs(k.df) k $4$ $5$ $4$ 0.571384 0.214267 $5$ 0.214267 0.142849 m = m[ 0 : 2 , 0 : 2 ] freq2, Phi = eig(m, k) Phi / 0.57293852 array([[-1. , -0.75123369], [-1.4305171 , 1.57544505]]) M = Phi.T @ m @ Phi K = Phi.T @ k @ Phi M Structural_Vector([[ 1.65651710e+00, -1.11022302e-16], [ 0.00000000e+00, 1.37050677e+00]]) a) Modal expansion of earthquake forces \\[\\mathrm{p}_{\\mathrm{eff}}(t)=-\\mathrm{m} \\iota \\ddot{u}_{g}(t)\\] \\[\\mathbf{m} \\iota=\\sum_{n=1}^{N} \\mathbf{s}_{n}=\\sum_{n=1}^{N} \\Gamma_{n} \\mathbf{m} \\phi_{n}\\] I = N = 2 iota = np.array([ 0 , 1 ]) Ln = np.array([ sum (Phi.T[n,i] * sum (m[i,j] * iota[j] for j in range (I)) for i in range (I)) for n in range (N)]) Ln = Phi.T @ m @ iota Ln Structural_Vector([-0.81959835, 0.90263316]) gamma = np.array([Ln[n] / M[n,n] for n in range (N)]) gamma array([-0.49477204, 0.65861269]) sn = [gamma[n] * (m @ Phi[:,n]) for n in range (N)] sn [Structural_Vector([0.85042189, 0.40551435]), Structural_Vector([-0.85042189, 0.59448565])]","title":"Problem 2"},{"location":"gallery/dynamics/225_HW11_P3-2/","text":"Time History Analysis: MDF Frame import ema as em import matplotlib.pyplot as plt import numpy as np % config InlineBackend.figure_format = 'svg' # used to make plots look nicer from ema_examples.dynamics import P09_07 from ema.utilities.ipyutils import disp_sbs ft = 12 h = 12 * ft m = 80 / 386.4 E = 29000 I = 1000 EI = E * I RHA = False N = I = 3 mdl = P09_07(h = h, m = m, EI = EI) # fig, ax = plt.subplots() # em.plot_structure(mdl, ax) m, k = em.Mass_matrix(mdl), em.K_matrix(mdl) k, m = em.analysis.StaticCondensation(k, m) disp_sbs(m.df, k.df) $u_{1}$ $u_{2}$ $u_{3}$ $u_{1}$ 0.207039 0.000000 0.00000 $u_{2}$ 0.000000 0.207039 0.00000 $u_{3}$ 0.000000 0.000000 0.10352 $1$ $2$ $3$ $P_{1}$ 466.177984 -233.088992 0.000000 $P_{2}$ -233.088992 466.177984 -233.088992 $P_{3}$ 0.000000 -233.088992 233.088992 The function ema.analysis.ModalAnalysis wraps a scipy routine for solving the eigenvalue problem. freq2, Phi = em.analysis.ModalAnalysis(mdl, norm = 'last' ) Phi array([[ 5.00000000e-01, -1.00000000e+00, 5.00000000e-01], [ 8.66025404e-01, 2.28035323e-16, -8.66025404e-01], [ 1.00000000e+00, 1.00000000e+00, 1.00000000e+00]]) omega = np.array([np.sqrt(np.real(freq)) for freq in freq2]) omega array([17.36843442, 47.45144529, 64.81987972]) M = Phi.T @ m @ Phi K = Phi.T @ k @ Phi Modal expansion of earthquake forces \\[\\mathrm{p}_{\\mathrm{eff}}(t)=-\\mathrm{m} \\iota \\ddot{u}_{g}(t)\\] \\[\\mathbf{m} \\iota=\\sum_{n=1}^{N} \\mathbf{s}_{n}=\\sum_{n=1}^{N} \\Gamma_{n} \\mathbf{m} \\phi_{n}\\] I = N = 3 iota = np.ones(I) L = np.array([ sum (Phi.T[n,i] * sum (m[i,j] * iota[j] for j in range (I)) for i in range (I)) for n in range (N)]) L = Phi.T @ m @ iota L Structural_Vector([ 0.38634066, -0.10351967, 0.02773801]) gamma = np.array([L[n] / M[n,n] for n in range (N)]) gamma array([ 1.24401694, -0.33333333, 0.0893164 ]) s = np.array([gamma[n] * (m @ Phi.T[n]) for n in range (N)]).T s array([[ 1.28780221e-01, 6.90131125e-02, 9.24600388e-03], [ 2.23053886e-01, -1.57374274e-17, -1.60145485e-02], [ 1.28780221e-01, -3.45065562e-02, 9.24600388e-03]]) a) Determine \\(A_n\\) and \\(D_n\\) # Values read from response spectrum: D = np.array([ 0.877 , 0.10 , 0.04 ]) # inches D array([0.877, 0.1 , 0.04 ]) # if RHA: D = [] u = [] for i, w in enumerate (omega): zeta = 0.05 t, d = em.analysis.ElcentroRHA(zeta, w) D.append( max (d)) u.append([t,d]) print (D) [0.923352660303864, 0.09304519274915218, 0.03763691127115581] Plot modes: fig2, ax2 = plt.subplots() em.plot_structure(mdl, ax2) for i in range ( 3 ): plt.plot( 10 * u[i][ 0 ], 200 + 300 * u[i][ 1 ], linewidth = 0.5 ) plt.show() svg A = np.array([D[n] * omega[n] ** 2 for n in range (N)]) A array([278.54088513, 209.50424621, 158.13587895]) b) Modal response quantities Floor displacements Un = np.array([[gamma[n] * Phi[i,n] * D[n] for n in range (N)] for i in range (I)]) Un array([[ 5.74333174e-01, 3.10150642e-02, 1.68079666e-03], [ 9.94774237e-01, -7.07253019e-18, -2.91122522e-03], [ 1.14866635e+00, -3.10150642e-02, 3.36159333e-03]]) Story shears Vin = np.array([[ sum (s[j,n] * A[n] for j in range (i, I)) for n in range (N)] for i in range (I)]) Vin array([[133.87074037, 7.22927006, 0.3917752 ], [ 98.0001836 , -7.22927006, -1.07034975], [ 35.87055677, -7.22927006, 1.46212495]]) Floor and base moments M_base = np.array([ sum (s[i,n] * h * (i + 1 ) * A[n] for i in range (I)) for n in range (N)]) M_base # kip-inch array([38554.77322731, -1041.01488801, 112.8312575 ]) H = [h * (i + 1 ) for i in range (I)] H [144, 288, 432] M_floor = np.array([[ sum ((H[j] - h * (i + 1 )) * s[j,n] * A[n] for j in range (i,N)) for n in range (N)] for i in range (I)]) M_floor # kip-inch array([[19277.38661365, -2082.02977602, 56.41562875], [ 5165.36017531, -1041.01488801, 210.54599284], [ 0. , 0. , 0. ]]) c) Peak modal response combination For well-seperated modal frequencies, the SRSS method is employed. def ro(rno): return np.sqrt( sum (rn ** 2 for rn in rno)) Floor displacements text ro(Un.T) array([0.57517246, 0.9947785 , 1.14908991]) Story shears ro(Vin.T) array([134.06636775, 98.27229508, 36.62099122]) Floor and base overturning moments ro(M_base) 38568.98989471707 ro(M_floor) array([19957.41918167, 2327.78005518, 217.97325126])","title":"Time History Analysis - MDF Frame"},{"location":"gallery/matrix_analysis/","text":"Examples in Matrix Analysis","title":"Matrix Analysis"},{"location":"gallery/matrix_analysis/220_HW06_P1/","text":"Hyperstatic Truss - Compatibility import ema as em import matplotlib.pyplot as plt import numpy as np % config InlineBackend.figure_format = 'svg' mdl = em.Model( 2 , 2 ) n = mdl.dnodes e = mdl.delems mdl.node( '1' , 0.0 , 0.0 ) mdl.node( '2' , 8.0 , 0.0 ) mdl.node( '3' , 4.0 , 3.0 ) mdl.node( '4' , 4.0 , 6.0 ) mdl.truss( 'a' , n[ '1' ], n[ '3' ]) mdl.truss( 'b' , n[ '2' ], n[ '3' ]) mdl.truss( 'c' , n[ '1' ], n[ '4' ]) mdl.truss( 'd' , n[ '3' ], n[ '4' ]) mdl.truss( 'e' , n[ '2' ], n[ '4' ]) mdl.fix(n[ '1' ], [ 'x' , 'y' ]) mdl.fix(n[ '2' ], [ 'x' , 'y' ]) mdl.numDOF() [[5, 6], [7, 8], [1, 2], [3, 4]] fig1, ax1 = plt.subplots( 1 , 1 ) em.plot_structure(mdl, ax1) svg Part 1 Static-Kinematic Matrix Equivalence \\[V = A_f U_f\\] A = em.A_matrix(mdl) B = em.B_matrix(mdl) \\[P_f = B_f Q\\] B.f $a_1$ $b_1$ $c_1$ $d_1$ $e_1$ $1$ 0.8 -0.8 0.00000 -0.0 0.00000 $2$ 0.6 0.6 0.00000 -1.0 0.00000 $3$ 0.0 0.0 0.55470 0.0 -0.55470 $4$ 0.0 0.0 0.83205 1.0 0.83205 B.f.T - A.f 0 1 2 3 0 0.0 0.0 0.0 0.0 1 0.0 0.0 0.0 0.0 2 0.0 0.0 0.0 0.0 3 0.0 0.0 0.0 0.0 4 0.0 0.0 0.0 0.0 Part 2 Member d length The kinematic matrix, \\(A_f\\) , is given below: A.f $1$ $2$ $3$ $4$ $a_1$ 0.8 0.6 0.0000 0.00000 $b_1$ -0.8 0.6 0.0000 0.00000 $c_1$ 0.0 0.0 0.5547 0.83205 $d_1$ -0.0 -1.0 0.0000 1.00000 $e_1$ 0.0 0.0 -0.5547 0.83205 And the corresponding deformation vector is: V = em.V_vector(A) V.set_item( 'b_1' , 0.1 ) V.set_item( 'c_1' , 0.2 ) V $V_{{}}$ $a_1$ 0.0 $b_1$ 0.1 $c_1$ 0.2 $d_1$ 0.0 $e_1$ 0.0 The free dof displacement vector, \\(U_f\\) , is then computed as follows: \\[ U_f = A_f^{-1}V_\\epsilon \\] Ve = V[[ 0 , 1 , 2 , 4 ]] Ae = A.f[[ 0 , 1 , 2 , 4 ],:] U = Ae.inv @ Ve U.disp \\[\\left[\\begin{matrix}-0.0625\\\\0.0833333333333333\\\\0.180277563773199\\\\0.120185042515466\\end{matrix}\\right]\\] Finally the fully deformation vector is computed from \\(V=A_fU_f\\) , which gives the necessary deformation of element d. Veh = A.f @ U Veh.disp \\[\\left[\\begin{matrix}9.25185853854297 \\cdot 10^{-19}\\\\0.1\\\\0.2\\\\0.036851709182133\\\\1.66986849470959 \\cdot 10^{-17}\\end{matrix}\\right]\\] Element d must therefore elongated by 0.037 . Satisfy Compatibility The matrix \\(\\bar{B}_x\\) is computed as follows: mdl.redundant(e[ 'd' ], '1' ) B.barx $d_1$ $a_1$ 0.833333 $b_1$ 0.833333 $c_1$ -0.600925 $d_1$ 1.000000 $e_1$ -0.600925 This is multiplied by the deformation vector as follows: residual = B.barx.T @ Veh print (residual) if residual < 10e-9 : print ( \"Compatibility is satisfied\" ) B.f.ker /- 0.56694671 B.ker /- 0.56694671","title":"Hyperstatic Truss - Compatibility"},{"location":"gallery/matrix_analysis/220_HW09_P1/","text":"Force Method - Truss import ema as em import matplotlib.pyplot as plt import numpy as np import sympy as sp % config InlineBackend.figure_format = 'svg' dm = em.Model( 2 , 2 ) # create instance of model object n = dm.dnodes e = dm.delems A1 = 10000 Ac = 20000 I = 1 dm.xsection( 'default' , A1, I) csec = dm.xsection( 'section-c' , Ac, I) n1 = dm.node( '1' , 0.0 , 0.0 ) n2 = dm.node( '2' , 16. , 0.0 ) n3 = dm.node( '3' , 8.0 , 6.0 ) n4 = dm.node( '4' , 0.0 , 6.0 ) a = dm.truss( 'a' , n3, n4) # add truss element to model object b = dm.truss( 'b' , n1, n3) c = dm.truss( 'c' , n2, n3, xsec = csec) dm.pin(n1) dm.pin(n4) dm.pin(n2) dm.numDOF() # Automatically number model dofs # em.utilities.export.FEDEAS(dm) [[3, 4], [5, 6], [1, 2], [7, 8]] prim = em.Model( 2 , 2 ) # create instance of model object np = prim.dnodes ep = prim.delems A1 = 10000 Ac = 20000 I = 1 prim.xsection( 'default' , A1, I) csec = prim.xsection( 'section-c' , Ac, I) prim.node( '1' , 0.0 , 0.0 ) prim.node( '2' , 16. , 0.0 ) prim.node( '3' , 8.0 , 6.0 ) prim.node( '4' , 0.0 , 6.0 ) prim.truss( 'a' , np[ '3' ], np[ '4' ]) # add truss element to model object prim.truss( 'c' , np[ '2' ], np[ '3' ], xsec = csec) prim.pin(np[ '1' ]) prim.pin(np[ '4' ]) prim.pin(np[ '2' ]) prim.numDOF() # Automatically number model dofs np[ '3' ].p[ 'x' ] = 30 np[ '3' ].p[ 'y' ] = 50 # Establish redundant member force dm.redundant(b, '1' ) fig, ax = plt.subplots() em.plot_structure(dm, ax) svg Part 1 : Nodal Loading Ufp = em.analysis.SolveDispl(prim) A = em.A_matrix(dm) A.f @ Ufp $V_{{fffffff}}$ $a_1$ 0.077333 $b_1$ 0.165400 $c_1$ 0.041667 b.q0[ '1' ] = 1 Uf = em.analysis.SolveDispl(dm) A = em.A_matrix(dm) A.f @ Uf $V_{{fffffffff}}$ $a_1$ -0.000361 $b_1$ -0.000718 $c_1$ -0.000141 # Create model matrices B = em.B_matrix(dm) P = em.P_vector(B) # Define nodal loading n[ '3' ].p[ 'x' ] = 30 n[ '3' ].p[ 'y' ] = 50 P.set_item( '1' , 50 ) P.set_item( '2' , 30 ) # Show full B matrix B $a_1$ $b_1$ $c_1$ $1$ 1.0 0.8 -0.8 $2$ -0.0 0.6 0.6 $3$ 0.0 -0.8 0.0 $4$ 0.0 -0.6 0.0 $5$ 0.0 0.0 0.8 $6$ 0.0 0.0 -0.6 $7$ -1.0 0.0 0.0 $8$ 0.0 0.0 0.0 # Show portion of B matrix corresponding to free dofs B.f $a_1$ $b_1$ $c_1$ $1$ 1.0 0.8 -0.8 $2$ -0.0 0.6 0.6 # Show portion of B matrix corresponding to primary system B.i $a_1$ $c_1$ $1$ 1.0 -0.8 $2$ -0.0 0.6 Find \\(Q_p\\) Qp = B.bari @ P.f Qp $Q_{{ffffff}}$ $a_1$ 90.0 $c_1$ 50.0 # create full 3x1 Qp vector from current 2x1 Qp vector Qp = em.Q_vector(B, Qp) Qp $Q_{{0}}$ $a_1$ 90.0 $b_1$ 0.0 $c_1$ 50.0 find \\((V_h)_p\\) # Initialize structure matrices A = em.A_matrix(dm) Fs = em.Fs_matrix(dm) Fs $a_1$ $b_1$ $c_1$ $a_1$ 0.0008 0.000 0.0000 $b_1$ 0.0000 0.001 0.0000 $c_1$ 0.0000 0.000 0.0005 Ve = Fs @ Qp Vhp = B.barx.T @ Ve Vhp C:\\Users\\claud\\Anaconda3\\lib\\site-packages\\IPython\\core\\formatters.py:371: FormatterWarning: text/html formatter returned invalid type <class 'ema.utilities.Structural_Vector'> (expected <class 'str'>) for object: Structural_Vector([-0.1402]) FormatterWarning Structural_Vector([-0.1402]) find \\((V_{h})_x\\) Ve_x = Fs @ B.barx Ve_x $b_1$ $a_1$ -0.00128 $b_1$ 0.00100 $c_1$ -0.00050 Vhx = B.barx.T @ Ve_x Vhx 0 0 0.003548 Qx = - Vhp / Vhx Qx C:\\Users\\claud\\Anaconda3\\lib\\site-packages\\IPython\\core\\formatters.py:371: FormatterWarning: text/html formatter returned invalid type <class 'ema.utilities.Structural_Vector'> (expected <class 'str'>) for object: Structural_Vector([[39.51521984]]) FormatterWarning Structural_Vector([[39.51521984]]) Part 2 : Thermal Loading Find \\((V_h)_p\\) # e['a'].e0['1'] = 100*2e-5 # e['b'].e0['1'] = 100*2e-5 # e['c'].e0['1'] = 100*2e-5 A = em.A_matrix(dm) A $1$ $2$ $3$ $4$ $5$ $6$ $7$ $8$ $a_1$ 1.0 -0.0 0.0 0.0 0.0 0.0 -1.0 0.0 $b_1$ 0.8 0.6 -0.8 -0.6 0.0 0.0 0.0 0.0 $c_1$ -0.8 0.6 0.0 0.0 0.8 -0.6 0.0 0.0 V0 = em.V0_vector(dm) V0 $V_{{ffffff}}$ $a_1$ 0.0 $b_1$ 0.0 $c_1$ 0.0 Vhp = B.barx.T @ V0 Vhp C:\\Users\\claud\\Anaconda3\\lib\\site-packages\\IPython\\core\\formatters.py:371: FormatterWarning: text/html formatter returned invalid type <class 'ema.utilities.Structural_Vector'> (expected <class 'str'>) for object: Structural_Vector([0.]) FormatterWarning Structural_Vector([0.]) Find \\(Q_x\\) Qx = - Vhp / Vhx Qx C:\\Users\\claud\\Anaconda3\\lib\\site-packages\\IPython\\core\\formatters.py:371: FormatterWarning: text/html formatter returned invalid type <class 'ema.utilities.Structural_Vector'> (expected <class 'str'>) for object: Structural_Vector([[-0.]]) FormatterWarning Structural_Vector([[-0.]])","title":"Force Method - Truss"},{"location":"gallery/matrix_analysis/220_HW09_P3_v2/","text":"Stiffness Method - Beam import ema as em import matplotlib.pyplot as plt import numpy as np % config InlineBackend.figure_format = 'svg' # used to make plots look nicer # Initialize model dm = em.Model( 2 , 3 ) nodes = dm.nodes n = dm.dnodes # Define section properties A = 1 Iab = 200000 Ic = 300000 xs1 = dm.xsec( 'ab' , A, Iab) xs2 = dm.xsec( 'c' , A, Ic) xsecs = [xs1, xs1, xs2] # Define nodes dm.node( '1' , 0.0 , 0.0 ) dm.node( '2' , 15. , 0.0 ) dm.node( '3' , 35. , 0.0 ) dm.node( '4' , 50. , 0.0 ) # Create beams a, b, c = dm.girder(nodes, xsecs = xsecs) # Establish fixities dm.fix(n[ '1' ], [ 'x' , 'y' ]) dm.fix(n[ '2' ], [ 'y' ]) dm.fix(n[ '3' ], [ 'y' ]) dm.fix(n[ '4' ], [ 'y' ]) # uncomment line below to automatically print FEDEASLab input script # em.utilities.export.FEDEAS(dm) dm.numDOF() # automatically number dofs and print them as list [[8, 9, 1], [2, 10, 3], [4, 11, 5], [6, 12, 7]] fig, ax = plt.subplots() em.plot_beam(dm, ax) svg Part a) Distributed Loading Determine displacements of the free dofs. # set element loads a.w[ 'y' ] = - 10 b.w[ 'y' ] = - 10 A = em.A_matrix(dm) B = em.B_matrix(dm) V0 = em.V_vector(A).o Q0 = em.Q_vector(B).o Q0 $Q_{{}}$ $a_1$ 0.000000 $a_2$ 187.500000 $a_3$ -187.500000 $b_1$ 0.000000 $b_2$ 333.333333 $b_3$ -333.333333 $c_1$ 0.000000 $c_2$ 0.000000 $c_3$ 0.000000 P0 = B.f @ Q0 P0 $P_{{}}$ $1$ 187.500000 $2$ 0.000000 $3$ 145.833333 $4$ 0.000000 $5$ -333.333333 $6$ 0.000000 $7$ 0.000000 K = em.K_matrix(dm) K.f $U_{{1}}$ $U_{{2}}$ $U_{{3}}$ $U_{{4}}$ $U_{{5}}$ $U_{{6}}$ $U_{{7}}$ $P_{{1}}$ 53333.333333 0.000000 26666.666667 0.000000 0.0 0.000000 0.0 $P_{{2}}$ 0.000000 0.116667 0.000000 -0.050000 0.0 0.000000 0.0 $P_{{3}}$ 26666.666667 0.000000 93333.333333 0.000000 20000.0 0.000000 0.0 $P_{{4}}$ 0.000000 -0.050000 0.000000 0.116667 0.0 -0.066667 0.0 $P_{{5}}$ 0.000000 0.000000 20000.000000 0.000000 120000.0 0.000000 40000.0 $P_{{6}}$ 0.000000 0.000000 0.000000 -0.066667 0.0 0.066667 0.0 $P_{{7}}$ 0.000000 0.000000 0.000000 0.000000 40000.0 0.000000 80000.0 Uf = K.f.inv @ ( - P0) Uf $U_{{}}$ $U_{{1}}$ -0.002734 $U_{{2}}$ 0.000000 $U_{{3}}$ -0.001562 $U_{{4}}$ 0.000000 $U_{{5}}$ 0.003646 $U_{{6}}$ 0.000000 $U_{{7}}$ -0.001823 Determine element basic forces V = A.f @ Uf V $V_{{}}$ $a_1$ 0.000000 $a_2$ -0.002734 $a_3$ -0.001562 $b_1$ 0.000000 $b_2$ -0.001562 $b_3$ 0.003646 $c_1$ 0.000000 $c_2$ 0.003646 $c_3$ -0.001823 Q = K.s @ V + Q0 Q 0 0 0.000000e+00 1 2.842171e-14 2 -3.437500e+02 3 0.000000e+00 4 3.437500e+02 5 -2.187500e+02 6 0.000000e+00 7 2.187500e+02 8 2.842171e-14 Part b) Thermal Loading a.w[ 'y' ] = 0.0 b.w[ 'y' ] = 0.0 b.e0[ '2' ] = - 1e-3 b.e0[ '3' ] = 1e-3 c.e0[ '2' ] = - 1e-3 c.e0[ '3' ] = 1e-3 V0 = em.V_vector(A).o V0 $V_{{0}}$ $a_1$ 0.0000 $a_2$ 0.0000 $a_3$ 0.0000 $b_1$ 0.0000 $b_2$ 0.0100 $b_3$ -0.0100 $c_1$ 0.0000 $c_2$ 0.0075 $c_3$ -0.0075 Q0 = em.Q_vector(B).o Q0 $Q_{{}}$ $a_1$ 0.0 $a_2$ 0.0 $a_3$ 0.0 $b_1$ 0.0 $b_2$ -200.0 $b_3$ 200.0 $c_1$ 0.0 $c_2$ -300.0 $c_3$ 300.0 c.f_matrix() $q_1$ $q_2$ $q_3$ $v_1$ 15.0 0.000000 0.000000 $v_2$ 0.0 0.000017 -0.000008 $v_3$ 0.0 -0.000008 0.000017","title":"Stiffness Method - Beam"},{"location":"gallery/matrix_analysis/220_HW10_P3/","text":"Problem 3 import ema as em import matplotlib.pyplot as plt import numpy as np % config InlineBackend.figure_format = 'svg' mdl = em.rModel( 2 , 3 ) mdl.material( 'default' , 1000 ) mdl.xsection( 'default' , 10000000 , 50 ) tsec = mdl.xsection( 'truss' , 20 , 1 ) n1 = mdl.node( '1' , 0.0 , 0.0 ) n2 = mdl.node( '2' , 8.0 , 0.0 ) n3 = mdl.node( '3' , 16. , 0.0 ) n4 = mdl.node( '4' , 0.0 , 6.0 ) a = mdl.beam( 'a' , n1, n2) b = mdl.beam( 'b' , n2, n3) c = mdl.beam( 'c' , n1, n4) d = mdl.truss( 'd' , n2, n4, xsec = tsec) n2.p[ 'y' ] = - 20 mdl.hinge(c, n4) mdl.roller(n1) mdl.fix(n3, [ 'x' , 'y' , 'rz' ]) mdl.fix(n4, [ 'rz' ]) # mdl.numDOF() mdl.DOF = [[ 5 , 6 , 1 ], [ 5 , 2 , 3 ], [ 5 , 7 , 8 ], [ 4 , 6 , 9 ]] # Manually number DOFs # em.utilities.export.FEDEAS(mdl) mdl.nt 9 fig, ax = plt.subplots() em.plot_structure(mdl, ax) <matplotlib.axes._subplots.AxesSubplot at 0x2094a461a88> svg K = em.K_matrix(mdl) K.f $1$ $2$ $3$ $4$ $P_{1}$ 50000.00000 -4687.50 12500.0 4166.66667 $P_{2}$ -4687.50000 3063.75 0.0 960.00000 $P_{3}$ 12500.00000 0.00 50000.0 0.00000 $P_{4}$ 4166.66667 960.00 0.0 1974.44444 Uf = em.analysis.SolveDispl(mdl) Uf $U_{{}}$ $1$ -0.002494 $2$ -0.014149 $3$ 0.000624 $4$ 0.012143 Compatibility A = em.A_matrix(mdl) V = A.f @ Uf V $V_{{}}$ $a_1$ 0.000000 $a_2$ -0.000726 $a_3$ 0.002392 $b_1$ 0.000000 $b_2$ -0.001145 $b_3$ -0.001769 $c_1$ 0.000000 $c_2$ -0.000470 $c_3$ 0.002024 $d_1$ -0.001225 mdl.redundant(b, '3' ) mdl.redundant(d, '1' ) B = em.B_matrix(mdl) np.around(B.barx, 5 ) --------------------------------------------------------------------------- LinAlgError Traceback (most recent call last) <ipython-input-10-5ef0eae70dd5> in <module> ----> 1 np.around(B.barx,5) ~\\OneDrive\\400_box\\Python\\myPackages\\ema\\matrices.py in barx(self) 550 nx = len(self.model.redundants) 551 --> 552 Bbarxi = self.barxi 553 554 Bbarx = Structural_Matrix(np.zeros((nQ,nx))) ~\\OneDrive\\400_box\\Python\\myPackages\\ema\\matrices.py in barxi(self) 541 def barxi(self): 542 Bx = self.f.x --> 543 Bbarxi = self.bari @ -Bx 544 Bbarxi.column_data = Bx.column_data 545 return Bbarxi ~\\OneDrive\\400_box\\Python\\myPackages\\ema\\matrices.py in bari(self) 568 @property 569 def bari(self): --> 570 return self.i.del_zeros().inv 571 572 @property ~\\OneDrive\\400_box\\Python\\myPackages\\ema\\matrices.py in inv(self) 212 @property 213 def inv(self): --> 214 mat = np.linalg.inv(self) 215 transfer_vars(self, mat) 216 mat.row_data = self.column_data <__array_function__ internals> in inv(*args, **kwargs) ~\\Anaconda3\\lib\\site-packages\\numpy\\linalg\\linalg.py in inv(a) 544 a, wrap = _makearray(a) 545 _assertRankAtLeast2(a) --> 546 _assertNdSquareness(a) 547 t, result_t = _commonType(a) 548 ~\\Anaconda3\\lib\\site-packages\\numpy\\linalg\\linalg.py in _assertNdSquareness(*arrays) 211 m, n = a.shape[-2:] 212 if m != n: --> 213 raise LinAlgError('Last 2 dimensions of the array must be square') 214 215 def _assertFinite(*arrays): LinAlgError: Last 2 dimensions of the array must be square B.barx ker = B.f.c.ker np.around(ker, 4 ) B.barx.T @ V K.f @ Uf Find element forces Q = K.s @ V Q --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-11-b08c858beddb> in <module> ----> 1 Q = K.s@V 2 3 Q AttributeError: 'Stiffness_matrix' object has no attribute 's' em.plot_U(mdl, Uf, ax, scale = 100 , chords = False ) svg x = np.linspace( 0 , c.L, 100 ) v_tags = [c.tag + '_2' , c.tag + '_3' ] v = [V.get(v_tags[ 0 ]),V.get(v_tags[ 1 ])] y = c.Elastic_curve(x, v, scale = 1000 , global_coord = True ) plt.plot(y[ 0 ], y[ 1 ]) [<matplotlib.lines.Line2D at 0x2094b8c7d08>] svg Uf.row_data","title":"Problem 3"},{"location":"gallery/matrix_analysis/Force_Method/","text":"The Force Method import ema as em import matplotlib.pyplot as plt import numpy as np import sympy as sp % config InlineBackend.figure_format = 'svg' dm = em.Model( 2 , 2 ) # create instance of model object n = dm.dnodes e = dm.delems A1 = 10000 Ac = 20000 I = 1 dm.xsection( 'default' , A1, I) csec = dm.xsection( 'section-c' , Ac, I) n1 = dm.node( '1' , 0.0 , 0.0 ) n2 = dm.node( '2' , 16. , 0.0 ) n3 = dm.node( '3' , 8.0 , 6.0 ) n4 = dm.node( '4' , 0.0 , 6.0 ) a = dm.truss( 'a' , n3, n4) # add truss element to model object b = dm.truss( 'b' , n1, n3) c = dm.truss( 'c' , n2, n3, xsec = csec) dm.pin(n1) dm.pin(n4) dm.pin(n2) dm.numDOF() ; prim = em.Model( 2 , 2 ) # create instance of model object np = prim.dnodes ep = prim.delems A1 = 10000 Ac = 20000 I = 1 prim.xsection( 'default' , A1, I) csec = prim.xsection( 'section-c' , Ac, I) prim.node( '1' , 0.0 , 0.0 ) prim.node( '2' , 16. , 0.0 ) prim.node( '3' , 8.0 , 6.0 ) prim.node( '4' , 0.0 , 6.0 ) prim.truss( 'a' , np[ '3' ], np[ '4' ]) # add truss element to model object prim.truss( 'c' , np[ '2' ], np[ '3' ], xsec = csec) prim.pin(np[ '1' ]) prim.pin(np[ '4' ]) prim.pin(np[ '2' ]) prim.numDOF() ; # Automatically number model dofs # Establish redundant member force dm.redundant(b, '1' ) fig, ax = plt.subplots() em.plot_structure(dm, ax) svg Part 1 : Nodal Loading A = em.A_matrix(dm) np[ '3' ].p[ 'y' ] = 30 np[ '3' ].p[ 'x' ] = 50 Up = em.analysis.SolveDispl(prim) A.f @ Up $V_{{fffff}}$ $a_1$ 0.0720 $b_1$ 0.1402 $c_1$ 0.0250 \\(U_x\\) b.q0[ '1' ] = 1 np[ '3' ].p[ 'y' ] = 0.6 np[ '3' ].p[ 'x' ] = 0.8 Ux = em.analysis.SolveDispl(prim) V0 = em.V0_vector(dm) em.plot_U(dm, Ux, ax, scale = 500 ) Ux [0.0, 0.0] [0.0, 0.0] [0.00128, 0.0025399999999999997] [0.0, 0.0] $U_{{fffffffffffffffff}}$ $1$ 0.00128 $2$ 0.00254 svg A.f @ Ux + V0 super C:\\Users\\claud\\Anaconda3\\lib\\site-packages\\IPython\\core\\formatters.py:371: FormatterWarning: text/html formatter returned invalid type <class 'ema.matvecs.Deformation_vector'> (expected <class 'str'>) for object: Deformation_vector([0.00128 , 0.003548, 0.0005 ]) FormatterWarning Deformation_vector([0.00128 , 0.003548, 0.0005 ]) # Define nodal loading b.q0[ '1' ] = 0 n[ '3' ].p[ 'y' ] = 30 n[ '3' ].p[ 'x' ] = 50 UP = em.analysis.SolveDispl(dm) UP $U_{{fffffffff}}$ $1$ 0.021421 $2$ 0.037298 A.f @ UP $V_{{fffffffff}}$ $a_1$ 0.021421 $b_1$ 0.039515 $c_1$ 0.005242","title":"The Force Method"},{"location":"gallery/plastic_analysis/","text":"Examples in Plastic Analysis","title":"Plastic Analysis"},{"location":"gallery/plastic_analysis/220_HW11_P1b/","text":"Kinematics - Kernel Analysis import ema as em import matplotlib.pyplot as plt import numpy as np % config InlineBackend.figure_format = 'svg' # used to make plots look nicerbb mdl = em.Model( 2 , 3 ) n = mdl.dnodes e = mdl.delems mdl.node( '1' , 0.0 , 0.0 ) mdl.node( '2' , 8.0 , 0.0 ) mdl.node( '3' , 8.0 , 6.0 ) mdl.node( '4' , 16.0 , 6.0 ) mdl.beam( 'a' , n[ '1' ], n[ '2' ]) mdl.beam( 'b' , n[ '2' ], n[ '3' ]) mdl.beam( 'c' , n[ '3' ], n[ '4' ]) mdl.hinge(e[ 'a' ], n[ '1' ]) mdl.hinge(e[ 'b' ], n[ '3' ]) mdl.fix(n[ '1' ], [ 'x' , 'y' , 'rz' ]) mdl.fix(n[ '4' ], [ 'y' ]) mdl.numDOF() [[9, 10, 11], [1, 2, 3], [4, 5, 6], [7, 12, 8]] em.analysis.characterize(mdl) m = 1 s = 0 fig, ax = plt.subplots( 1 , 1 ) em.plot_structure(mdl, ax) svg A = em.A_matrix(mdl) A.f $1$ $2$ $3$ $4$ $5$ $6$ $7$ $8$ $a_1$ 1.000000 0.000 0.0 0.000000 0.000 0.0 0.0 0.0 $a_2$ 0.000000 -0.125 0.0 0.000000 0.000 0.0 0.0 0.0 $a_3$ 0.000000 -0.125 1.0 0.000000 0.000 0.0 0.0 0.0 $b_1$ -0.000000 -1.000 0.0 0.000000 1.000 0.0 0.0 0.0 $b_2$ -0.166667 0.000 1.0 0.166667 -0.000 0.0 0.0 0.0 $b_3$ -0.166667 0.000 0.0 0.166667 -0.000 1.0 0.0 0.0 $c_1$ 0.000000 0.000 0.0 -1.000000 -0.000 0.0 1.0 0.0 $c_2$ 0.000000 0.000 0.0 -0.000000 0.125 1.0 0.0 0.0 $c_3$ 0.000000 0.000 0.0 -0.000000 0.125 0.0 0.0 1.0 A_cm = A.c.ker / - 0.561490 A_cm $1$ $1$ -0.000 $2$ 1.000 $3$ 0.125 $4$ -0.750 $5$ 1.000 $6$ -0.125 $7$ -0.750 $8$ -0.125 em.plot_U(mdl, A_cm, ax, scale = 1 ) 1 2 3 4 5 6 7 8 svg","title":"Kinematics - Kernel Analysis"},{"location":"gallery/plastic_analysis/220_HW11_P1br/","text":"Problem 2 (See also HW-07 Problem 1) import ema as em import matplotlib.pyplot as plt import numpy as np % config InlineBackend.figure_format = 'svg' # used to make plots look nicerbb #Remove mdl = em.rModel( 2 , 3 ) n = mdl.dnodes e = mdl.delems mdl.node( '1' , 0.0 , 0.0 ) mdl.node( '2' , 8.0 , 0.0 ) mdl.node( '3' , 8.0 , 6.0 ) mdl.node( '4' , 16.0 , 6.0 ) mdl.beam( 'a' , n[ '1' ], n[ '2' ]) mdl.beam( 'b' , n[ '2' ], n[ '3' ]) mdl.beam( 'c' , n[ '3' ], n[ '4' ]) mdl.hinge(e[ 'a' ], n[ '1' ]) mdl.hinge(e[ 'b' ], n[ '3' ]) mdl.hinge(e[ 'c' ], n[ '3' ]) mdl.hinge(e[ 'c' ], n[ '4' ]) mdl.fix(n[ '1' ], [ 'x' , 'y' , 'rz' ]) mdl.fix(n[ '2' ], [ 'rz' ]) mdl.fix(n[ '4' ], [ 'y' , 'rz' ]) # mdl.numDOF() mdl.DOF = [[ 4 , 5 , 6 ], [ 4 , 1 , 2 ], [ 3 , 1 , 7 ], [ 3 , 8 , 9 ]] em.analysis.characterize(mdl) m = 1 s = 0 fig, ax = plt.subplots() em.plot_structure(mdl, ax) svg A = em.A_matrix(mdl).remove( 'frame-axial' ) A.c $1$ $2$ $3$ $a_3$ -0.125 1.0 0.000000 $b_2$ -0.000 1.0 0.166667 ker = A.c.ker A_cm = ker / ker[ 0 ] A_cm 0 0 1.000 1 0.125 2 -0.750 em.plot_U(mdl, ker, ax, scale = 0.5 ) svg A.f @ A_cm 0 0 -1.250000e-01 1 -1.804112e-16 2 -4.394633e-17 3 -1.250000e-01 4 1.250000e-01 5 1.250000e-01","title":"Problem 2"},{"location":"gallery/plastic_analysis/220_HW11_P2/","text":"Kinematics import ema as em import matplotlib.pyplot as plt import numpy as np import sympy as sp % config InlineBackend.figure_format = 'svg' import scipy.linalg as la mdl = em.Model( 2 , 3 ) n = mdl.dnodes e = mdl.delems mdl.node( '1' , 0.0 , 0.0 ) mdl.node( '2' , 0.0 , 5.0 ) mdl.node( '3' , 4.0 , 5.0 ) mdl.node( '4' , 8.0 , 5.0 ) mdl.node( '5' , 8.0 , 0.0 ) mdl.node( '6' , 8.0 , 10. ) mdl.beam( 'a' , n[ '1' ], n[ '2' ]) mdl.beam( 'b' , n[ '2' ], n[ '3' ]) mdl.beam( 'c' , n[ '3' ], n[ '4' ]) mdl.truss( 'd' , n[ '4' ], n[ '5' ]) mdl.beam( 'e' , n[ '4' ], n[ '6' ]) mdl.hinge(e[ 'a' ], n[ '1' ]) mdl.hinge(e[ 'c' ], n[ '3' ]) mdl.hinge(e[ 'e' ], n[ '6' ]) mdl.fix(n[ '1' ], [ 'x' , 'y' , 'rz' ]) mdl.fix(n[ '5' ], [ 'x' , 'y' , 'rz' ]) mdl.fix(n[ '6' ], [ 'x' , 'y' , 'rz' ]) mdl.numDOF() em.analysis.characterize(mdl) m = 1 s = 2 fig, ax = plt.subplots() em.plot_structure(mdl, ax) svg A = em.A_matrix(mdl) A.f $1$ $2$ $3$ $4$ $5$ $6$ $7$ $8$ $9$ $a_1$ 0.0 1.00 0.0 0.0 0.00 0.0 0.0 0.00 0.0 $a_2$ 0.2 -0.00 0.0 0.0 0.00 0.0 0.0 0.00 0.0 $a_3$ 0.2 -0.00 1.0 0.0 0.00 0.0 0.0 0.00 0.0 $b_1$ -1.0 -0.00 0.0 1.0 0.00 0.0 0.0 0.00 0.0 $b_2$ -0.0 0.25 1.0 0.0 -0.25 0.0 0.0 0.00 0.0 $b_3$ -0.0 0.25 0.0 0.0 -0.25 1.0 0.0 0.00 0.0 $c_1$ 0.0 0.00 0.0 -1.0 -0.00 0.0 1.0 0.00 0.0 $c_2$ 0.0 0.00 0.0 -0.0 0.25 1.0 0.0 -0.25 0.0 $c_3$ 0.0 0.00 0.0 -0.0 0.25 0.0 0.0 -0.25 1.0 $d_1$ 0.0 0.00 0.0 0.0 0.00 0.0 -0.0 1.00 0.0 $e_1$ 0.0 0.00 0.0 0.0 0.00 0.0 -0.0 -1.00 0.0 $e_2$ 0.0 0.00 0.0 0.0 0.00 0.0 -0.2 0.00 1.0 $e_3$ 0.0 0.00 0.0 0.0 0.00 0.0 -0.2 0.00 0.0 ker = A.c.ker ker = ker. round ( 6 ) / ker[ 0 ] ker $1$ $1$ 1.000001 $2$ -0.000000 $3$ -0.200000 $4$ 1.000001 $5$ -0.799999 $6$ -0.200000 $7$ 1.000001 $8$ 0.000000 $9$ 0.200000 em.plot_U(mdl, ker, ax, scale = 1 ) svg","title":"Kinematics"},{"location":"gallery/plastic_analysis/220_HW11_P3-FullMatrix/","text":"Kinematics 3 import ema as em import numpy as np import sympy as sp import matplotlib.pyplot as plt % config InlineBackend.figure_format = 'svg' #Remove mdl = em.Model( 2 , 3 ) n = mdl.dnodes e = mdl.delems mdl.node( '1' , 0.0 , 0.0 ) mdl.node( '2' , 6.0 , 0.0 ) mdl.node( '3' , 10. , 0.0 ) mdl.node( '4' , 6.0 , 6.0 ) mdl.node( '5' , 10. , 6.0 ) mdl.node( '6' , 6.0 , 10. ) mdl.beam( 'a' , n[ '1' ], n[ '2' ]) mdl.beam( 'b' , n[ '2' ], n[ '3' ]) mdl.beam( 'c' , n[ '2' ], n[ '4' ]) mdl.beam( 'd' , n[ '4' ], n[ '5' ]) mdl.beam( 'e' , n[ '4' ], n[ '6' ]) mdl.hinge(e[ 'a' ], n[ '1' ]) mdl.hinge(e[ 'b' ], n[ '2' ]) mdl.hinge(e[ 'b' ], n[ '3' ]) mdl.hinge(e[ 'c' ], n[ '4' ]) mdl.fix(n[ '1' ], [ 'x' , 'y' , 'rz' ]) mdl.fix(n[ '3' ], [ 'x' , 'y' , 'rz' ]) mdl.fix(n[ '5' ], [ 'y' ]) mdl.fix(n[ '6' ], [ 'x' ]) mdl.numDOF() em.analysis.characterize(mdl) mdl.DOF m = 1 s = 2 [[11, 12, 13], [1, 2, 3], [14, 15, 16], [4, 5, 6], [7, 17, 8], [18, 9, 10]] #Remove fig, ax = plt.subplots( 1 , 1 ) em.plot_structure(mdl, ax) svg # Matrices B = em.B_matrix(mdl) A = em.A_matrix(mdl) # Vectors Q = em.column_vector(B) V = em.V_vector(A) 3 Find \\(A_{cm}\\) ker = A.c.ker A_cm = ker / ker[ 5 ] A_cm $1$ $1$ 0.000000 $2$ -4.000000 $3$ -0.666667 $4$ 4.000000 $5$ -4.000000 $6$ 1.000000 $7$ 4.000000 $8$ 1.000000 $9$ -4.000000 $10$ 1.000000 em.plot_U(mdl, ker, ax, scale = 1 ) svg Part 4 A_m = A.f @ A_cm A_m $1$ $a_1$ 0.000000e+00 $a_2$ 6.666667e-01 $a_3$ 0.000000e+00 $b_1$ 0.000000e+00 $b_2$ -1.666667e+00 $b_3$ -1.000000e+00 $c_1$ 0.000000e+00 $c_2$ 0.000000e+00 $c_3$ 1.666667e+00 $d_1$ 1.000000e-14 $d_2$ -1.000000e-14 $d_3$ 0.000000e+00 $e_1$ 0.000000e+00 $e_2$ -1.000000e-14 $e_3$ 0.000000e+00","title":"Kinematics 3"},{"location":"gallery/plastic_analysis/220_HW12_P2r_E2E/","text":"Event to Event Analysis (220_HW12_P2r) import ema as em import numpy as np # import sympy as sp import matplotlib.pyplot as plt % config InlineBackend.figure_format = 'svg' mdl = em.rModel( 2 , 3 ) # reduced model in 2 dimensions with 3 dofs / node n = mdl.dnodes e = mdl.delems # pre-define element properties for convenience; these can alse be assigned indiviudally. mdl.material( 'default' , E = 1000 ) mdl.xsection( 'default' , 1e6 , 50 ) xt = mdl.xsection( 'truss' , 10 , 1 ) mdl.node( '1' , 0.0 , 0.0 ) mdl.node( '2' , 8.0 , 0.0 ) mdl.node( '3' , 8.0 , 6.0 ) mdl.node( '4' , 16. , 6.0 ) mdl.node( '5' , 16. , - 4. ) # elements mdl.beam( 'a' , n[ '1' ], n[ '2' ], Qpl = [ 1e6 , 120 , 120 ]) mdl.beam( 'b' , n[ '2' ], n[ '3' ], Qpl = [ 1e6 , 120 , 120 ]) mdl.beam( 'c' , n[ '3' ], n[ '4' ], Qpl = [ 1e6 , 120 , 120 ]) mdl.beam( 'd' , n[ '4' ], n[ '5' ], Qpl = [ 1e6 , 180 , 180 ]) mdl.truss( 'e' , n[ '2' ], n[ '4' ], xsec = xt, Qpl = [ 30 ]) # Fixities mdl.fix(n[ '1' ], [ 'x' , 'y' , 'rz' ]) mdl.fix(n[ '5' ], [ 'x' , 'y' , 'rz' ]) # Loading n[ '3' ].p[ 'y' ] = - 30 n[ '3' ].p[ 'x' ] = 50 mdl.DOF = mdl.numdofs() fig, ax = plt.subplots( 1 , 1 ) em.plot_structure(mdl, ax) svg ee = em.Event2Event(mdl) ee.run() ee.lamda array([0. , 1.26346229, 1.42471482, 1.53116075, 1.70774411, 1.75555556]) ee.Q[ - 1 ] # forces at last event $Q_{{}}$ $a_1$ 0.000000 $a_2$ 120.000000 $a_3$ -82.666667 $b_1$ 0.000000 $b_2$ 82.666667 $b_3$ 120.000000 $c_1$ 0.000000 $c_2$ -120.000000 $c_3$ -120.000000 $d_1$ 0.000000 $d_2$ 120.000000 $d_3$ 180.000000 $e_1$ 30.000000 ee.U # displacement vectors at each event .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 2 3 4 5 0 0.0 -0.016180 -0.020235 -0.026011 -0.054760 -0.068836 1 0.0 -0.004619 -0.005641 -0.006943 -0.013000 -0.016213 2 0.0 0.025365 0.030523 0.039657 0.080000 0.102720 3 0.0 -0.001066 -0.001211 0.000051 0.003645 0.005404 4 0.0 0.000290 0.000409 0.000051 -0.006000 -0.008272","title":"Event to Event Analysis"},{"location":"guides/","text":"Modeling Skeletal modeling PDEs over homogeneous domains System reliability Developing Development of an isoparametric element Elle reference library. Contributing","title":"Index"},{"location":"guides/quick-start/","text":"Getting Started Installation The anabel Python package can be installed by running the following command: pip install anabel Building Models","title":"Getting Started"}]}