{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":".home-feature { justify-content: space-between !important; align-items: center !important; display: flex !important; margin-top: 3rem !important; margin-bottom: 3rem !important; } anabel anabel Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Get Started Guides View guides that explain the concepts and components of anabel . API Documentation Peruse a comprehensive list of functions provided by anabel , with detailed explanations of their interfaces. Gallery Walk through some examples of the various analysis procedures that anabel provides. Inelasticity Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Partial Differential Equations Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Reliability Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.","title":"Home"},{"location":"site-info/","text":"Project Information This website and corresponding project is in a very early stage of development and has not yet been licensed. The content of this website (including without limitation the text, computer code, artwork, photographs, images, audio material, video material and audio-visual material on this website) is owned by the author. For the time being, any redistribution or reproduction of part or all of the contents in any form is prohibited other than the following: You may view this website and the material on this website on a computer or mobile device via a web browser; You may copy and store this website and the material on this website in your web browser cache memory; You may print pages from this website for your own use. You may not distribute or commercially exploit the content. Nor may you transmit it or store it in any other website or other form of electronic retrieval system. The automated and/or systematic collection of data from this website is prohibited. This website was generated with the Elstir static site generator, a fork of MkDocs which uses Pandoc as the backend. The theme uses Bootstrap and is heavily adapted from Bootswatch . Additional sources of inspiration for the layout of this site include Numba , Pandas , and Codecov . A slightly modified version of Particle.js is used on the home page. License This project is not yet licensed. Disclaimer THE SOFTWARE IS PROVIDED \u201cAS IS,\u201d WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Project Information"},{"location":"api/latest/","text":"Modeling API The high-level modeling API is composed of six modules.","title":"API"},{"location":"api/latest/assemble/","text":"Assemblers( 2 ) Core model building classes. Classes class MeshGroup ( *args, ndm=2, ndf=1, mesh=None, **kwds) Homogeneous 2D mesh group. Parameters ndm :\u2002 int number of model dimensions ndf :\u2002 int number of degrees of freedom (dofs) at each node Ancestors anabel.assemble.UniformAssembler anabel.assemble.Assembler Static methods def read ( filename: str, *args, **kwds) Create a class instance by reading in a mesh file. This function should work with any mesh format that is supported in the external meshio Python library. Parameters filetype :\u2002 str In addition to those supported in meshio , the following formats are supported: m228 : Simple text file; see docstrings in source code of _read_m228 . Instance variables var dofs Plain DOF numbering scheme. 2021-05-07 var nr Return number of fixed degrees of freedom Methods def assemble_integral ( self, elem=None, verbose=False, **kwds) \u2011> Callable Parameters elem :\u2002 f(u,xyz) -> R^[ndf*nen] Returns f :\u2002 f(U, (xi, dV)) -> R^[nf] quad(elem(U[el], X[el])*dV def assemble_linear ( self, elem=None, verbose=False, **kwds) \u2011> Callable elem(None,xyz) -> R^[ndf*nen] Returns f :\u2002 f(U, (xi, dV)) -> R^[nf] quad(elem(None, X[el])*dV def compose ( self, elem=None, verbose=False, solver=None) Parameters elem :\u2002 Callable local function to be integrated over. solver :\u2002 str Either of the following. \u201csparse\u201d: use scipy.sparse.linalg.spsolve \u201ccg\u201d: Conjugate gradient using jax.scipy.sparse.linalg.cg None : default to anabel.backend.linalg.solve 2021-05-07 def compose_quad ( self, f=None, jit=True, verbose=False, **kwds) def norm ( self, u, h, quad) def plot ( self, values=None, func=None, scale=1.0, interact=False, savefig: str = None, **kwds) Plot mesh using pyvista interface to VTK. Pure numpy is used for generality. Claudio Perez def write ( self, filename: str, **kwds) Export mesh using meshio . class Model ( ndm: int, ndf: int) Base class for assembler objects. An assembler is typically characterized by collections of nodes, elements and parameters. The purpose of the assembler is to provide a convenient interface for interacting with and managing these entities. Basic structural model class Parameters ndm :\u2002 int number of model dimensions ndf :\u2002 int number of degrees of freedom (dofs) at each node Ancestors anabel.assemble.Assembler Subclasses anabel.assemble.Domain SkeletalGroup rModel Instance variables var NOS : int Degree of static indeterminacy var basic_forces : numpy.ndarray var cforces : numpy.ndarray var eforces Array of elastic element forces var idx_c var idx_e Indices of elastic basic (not plastic) forces var idx_f var idx_i var idx_x var nQ var ne : int number of elements in model var nf : int Number of free model degrees of freedom var nq Number of basic element forces var nr : int number of constrained dofs in model var nt : int Total number of model degrees of freedom. var nv Number of basic deformation variables var rdnt_forces : numpy.ndarray var rdofs Sequence of restrained dofs in model var rel Methods def add_element ( self, element) Add a general element to model Parameters element :\u2002 emme.elements.Element def add_elements ( self, elements) Add a general element to model Parameters element :\u2002 emme.elements.Element def assemble_force ( self, elem=None, **kwds) \u2011> Callable A simple force composer for skeletal structures. def beam ( self, tag: str, iNode, jNode, mat=None, sec=None, Qpl=None, **kwds) Create and add a beam object to model Parameters tag :\u2002 str string used for identifying object iNode :\u2002 emme.Node or str node object at element i-end jNode :\u2002 emme.Node or str node object at element j-end mat :\u2002 emme.Material sec :\u2002 emme.Section def boun ( self, node, ones) def clean ( self, keep=None) def compose ( self, resp='d', jit=True, verbose=False, **kwds) def compose_displ ( self, solver=None, solver_opts={}, elem=None, jit_force=True, **kwds) dynamically creates functions collect_loads and collect_coord . def compose_force ( self, jit=True, **kwds) def compose_param ( self, jit_force=True, verbose=False, **kwds) def displ ( self, val) def elem ( self, elem, nodes, tag) def fix ( self, node, dirn=['x', 'y', 'rz']) Define a fixed boundary condition at specified degrees of freedom of the supplied node Parameters node :\u2002 anabel.Node dirn :\u2002 Sequence[String] def frame ( self, bays, stories, column_mat=None, column_sec=None, girder_mat=None, girder_sec=None) Macro for generating rectangular building frames Parameters bays :\u2002 tuple tuple containing bay width, and number of bays stories :\u2002 tuple tuple column_mat: def girder ( self, nodes, mats=None, xsecs=None, story=None) def hinge ( self, elem, node) def load ( self, obj, *args, pattern=None, **kwds) Apply a load to a model object Claudio Perez 2021-04-01 def load_node ( self, node, load, **kwds) Claudio Perez 2021-04-01 def load_state ( self, state) def material ( self, tag: str, E: float) def node ( self, tag: str, x: float, y=None, z=None, mass: float = None) Add a new emme.Node object to the model Parameters x , y , z :\u2002 float Node coordinates. def numDOF ( self) def pin ( self, *nodes) Create a pinned reaction by fixing all translational degrees of freedom at the specified nodes. Parameters node :\u2002 anabel.Node def redundant ( self, elem: object, nature) nature: def roller ( self, node) Create a roller reaction at specified node def state ( self, method='Linear') def taprod ( self, tag: str, iNode, jNode, mat=None, xsec=None, Qpl=None, A=None, E=None) Construct a tapered rod element with variable E and A values. def truss ( self, tag: str, iNode, jNode, elem=None, mat=None, xsec=None, Qpl=None, A=None, E=None) def truss3d ( self, tag: str, iNode, jNode, mat=None, xsec=None) Add an emme.Truss3d object to model Parameters def update ( self, U) def xsection ( self, tag: str, A: float, I: float) class SkeletalModel ( ndm: int, ndf: int) Base class for assembler objects. An assembler is typically characterized by collections of nodes, elements and parameters. The purpose of the assembler is to provide a convenient interface for interacting with and managing these entities. Basic structural model class Parameters ndm :\u2002 int number of model dimensions ndf :\u2002 int number of degrees of freedom (dofs) at each node Ancestors anabel.assemble.Assembler Subclasses anabel.assemble.Domain SkeletalGroup rModel Instance variables var NOS : int Degree of static indeterminacy var basic_forces : numpy.ndarray var cforces : numpy.ndarray var eforces Array of elastic element forces var idx_c var idx_e Indices of elastic basic (not plastic) forces var idx_f var idx_i var idx_x var nQ var ne : int number of elements in model var nf : int Number of free model degrees of freedom var nq Number of basic element forces var nr : int number of constrained dofs in model var nt : int Total number of model degrees of freedom. var nv Number of basic deformation variables var rdnt_forces : numpy.ndarray var rdofs Sequence of restrained dofs in model var rel Methods def add_element ( self, element) Add a general element to model Parameters element :\u2002 emme.elements.Element def add_elements ( self, elements) Add a general element to model Parameters element :\u2002 emme.elements.Element def assemble_force ( self, elem=None, **kwds) \u2011> Callable A simple force composer for skeletal structures. def beam ( self, tag: str, iNode, jNode, mat=None, sec=None, Qpl=None, **kwds) Create and add a beam object to model Parameters tag :\u2002 str string used for identifying object iNode :\u2002 emme.Node or str node object at element i-end jNode :\u2002 emme.Node or str node object at element j-end mat :\u2002 emme.Material sec :\u2002 emme.Section def boun ( self, node, ones) def clean ( self, keep=None) def compose ( self, resp='d', jit=True, verbose=False, **kwds) def compose_displ ( self, solver=None, solver_opts={}, elem=None, jit_force=True, **kwds) dynamically creates functions collect_loads and collect_coord . def compose_force ( self, jit=True, **kwds) def compose_param ( self, jit_force=True, verbose=False, **kwds) def displ ( self, val) def elem ( self, elem, nodes, tag) def fix ( self, node, dirn=['x', 'y', 'rz']) Define a fixed boundary condition at specified degrees of freedom of the supplied node Parameters node :\u2002 anabel.Node dirn :\u2002 Sequence[String] def frame ( self, bays, stories, column_mat=None, column_sec=None, girder_mat=None, girder_sec=None) Macro for generating rectangular building frames Parameters bays :\u2002 tuple tuple containing bay width, and number of bays stories :\u2002 tuple tuple column_mat: def girder ( self, nodes, mats=None, xsecs=None, story=None) def hinge ( self, elem, node) def load ( self, obj, *args, pattern=None, **kwds) Apply a load to a model object Claudio Perez 2021-04-01 def load_node ( self, node, load, **kwds) Claudio Perez 2021-04-01 def load_state ( self, state) def material ( self, tag: str, E: float) def node ( self, tag: str, x: float, y=None, z=None, mass: float = None) Add a new emme.Node object to the model Parameters x , y , z :\u2002 float Node coordinates. def numDOF ( self) def pin ( self, *nodes) Create a pinned reaction by fixing all translational degrees of freedom at the specified nodes. Parameters node :\u2002 anabel.Node def redundant ( self, elem: object, nature) nature: def roller ( self, node) Create a roller reaction at specified node def state ( self, method='Linear') def taprod ( self, tag: str, iNode, jNode, mat=None, xsec=None, Qpl=None, A=None, E=None) Construct a tapered rod element with variable E and A values. def truss ( self, tag: str, iNode, jNode, elem=None, mat=None, xsec=None, Qpl=None, A=None, E=None) def truss3d ( self, tag: str, iNode, jNode, mat=None, xsec=None) Add an emme.Truss3d object to model Parameters def update ( self, U) def xsection ( self, tag: str, A: float, I: float) class SkeletalGroup ( *args, ndm=2, ndf=1, mesh=None, **kwds) Homogeneous 2D skeletal model. Basic structural model class Parameters ndm :\u2002 int number of model dimensions ndf :\u2002 int number of degrees of freedom (dofs) at each node Ancestors Model anabel.assemble.UniformAssembler anabel.assemble.Assembler Instance variables var dofs Plain DOF numbering scheme. 2021-05-16 Methods def assemble_integral ( self, verbose=False, **kwds) \u2011> Callable Parameters elem :\u2002 f(u,xyz) -> R^[ndf*nen] Returns f :\u2002 f(U, (xi, dV)) -> R^[nf] quad(elem(U[el], X[el])*dV def assemble_linear ( self, elem=None, verbose=False, **kwds) \u2011> Callable elem(None,xyz) -> R 1 Returns f :\u2002 f(U, (xi, dV)) -> R^[nf] quad(elem(None, X[el])*dV ndf*nen \u21a9\ufe0e def compose ( self, elem=None, verbose=False, solver=None) Parameters elem :\u2002 Callable local function to be integrated over. solver :\u2002 str Either of the following. \u201csparse\u201d: use scipy.sparse.linalg.spsolve \u201ccg\u201d: Conjugate gradient using jax.scipy.sparse.linalg.cg None : default to anabel.backend.linalg.solve 2021-05-07 def compose_quad ( self, f=None, jit=True, verbose=False, **kwds) Inherited members Model : NOS add_element add_elements assemble_force beam compose_displ eforces fix frame idx_e load load_node ne nf node nq nr nt nv pin rdofs redundant roller taprod truss3d class rModel ( ndm, ndf) Base class for assembler objects. An assembler is typically characterized by collections of nodes, elements and parameters. The purpose of the assembler is to provide a convenient interface for interacting with and managing these entities. Basic structural model class Parameters ndm :\u2002 int number of model dimensions ndf :\u2002 int number of degrees of freedom (dofs) at each node Ancestors Model anabel.assemble.Assembler Instance variables var cforces var nv Returns number of element deformations in model var triv_forces list of trivial axial forces Methods def isortho ( self, elem) def numDOF ( self) def numdofs ( self) Inherited members Model : NOS add_element add_elements assemble_force beam compose_displ eforces fix frame idx_e load load_node ne nf node nq nr nt pin rdofs redundant roller taprod truss3d","title":"anabel.assemble"},{"location":"api/latest/graphics/","text":"Graphics High-level model visualization library. Functions def plot_displ ( model, displ, ax=None, fig=None, scale=None, color=None, chords=False, **kwds) Claudio Perez 2021-04-02 def plot_moments ( state: object, ax=None, scale: float = None, color: str = None, chords: bool = False) Plot moment distribution from a frame model analysis. Only works for 2D models. def plot_skeletal ( Model, ax=None, label=False)","title":"anabel.graphics"},{"location":"api/latest/matrices/","text":"Matrix API This module provides functions and classes for constructing various structural analysis matrices. Functions def A_matrix ( Domain, matrix=None) Returns a Kinematic_matrix object def AssemblyTensor ( Model) def Aub_matrix ( model, alpha) Return the interaction upperbound matrix def B_matrix ( model, matrix=None, rng=None) Returns a Static_matrix object def Bh_matrix ( model) Returns a Static_matrix object def F_matrix ( Domain) Returns a Flexibility_matrix object def Fs_matrix ( model, Roption=True) Returns a Flexibility_matrix object def K_matrix ( Model) Returns a Stiffness_matrix object def K_tensor ( Model, U=None) Returns a Stiffness_matrix object def Ks_matrix ( model) Returns a Flexibility_matrix object def Kt_matrix ( Model, State) Returns a Stiffness_matrix object def Localize ( U_vector, P_vector, model=None) def P0_vector ( model) def P_vector ( model, vector=None) def Pw_vector ( model) def Q0_vector ( model) Returns a vector of initial element forces def Q_vector ( model, vector=None) Returns a iForce_vector object def Qp_vector ( model) Returns a vector of element plastic capacities def Qpl_vector ( model) Returns a vector of element plastic capacities def U_vector ( model, vector=None) Returns a Displacement_vector object def V0_vector ( model) Returns a Deformation_vector object def V_vector ( model, vector=None) Returns a Deformation_vector object def del_zeros ( mat) def elem_dofs ( Elem) def nB_matrix ( model, rng=None) Returns a Static_matrix object def transfer_vars ( item1, item2) Classes class Deformation_vector ( arry, model, row_data, Vector=None) ndarray(shape, dtype=float, buffer=None, offset=0, strides=None, order=None) An array object represents a multidimensional, homogeneous array of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, or something else, etc.) Arrays should be constructed using array , zeros or empty (refer to the See Also section below). The parameters given here refer to a low-level method ( ndarray(\u2026) ) for instantiating an array. For more information, refer to the numpy module and examine the methods and attributes of an array. Parameters (for the new method; see Notes below) shape :\u2002 tuple of ints Shape of created array. dtype :\u2002 data-type , optional Any object that can be interpreted as a numpy data type. buffer :\u2002 object exposing buffer interface , optional Used to fill the array with data. offset :\u2002 int , optional Offset of array data in buffer. strides :\u2002 tuple of ints , optional Strides of data in memory. order :\u2002 {'C', 'F'} , optional Row-major (C-style) or column-major (Fortran-style) order. Attributes T :\u2002 ndarray Transpose of the array. data :\u2002 buffer The array\u2019s elements, in memory. dtype :\u2002 dtype object Describes the format of the elements in the array. flags :\u2002 dict Dictionary containing information related to memory use, e.g., \u2018C_CONTIGUOUS,\u2019 \u2018OWNDATA,\u2019 \u2018WRITEABLE,\u2019 etc. flat :\u2002 numpy.flatiter object Flattened version of the array as an iterator. The iterator allows assignments, e.g., x.flat = 3 (See ndarray.flat for assignment examples; TODO). imag :\u2002 ndarray Imaginary part of the array. real :\u2002 ndarray Real part of the array. size :\u2002 int Number of elements in the array. itemsize :\u2002 int The memory use of each array element in bytes. nbytes :\u2002 int The total number of bytes required to store the array data, i.e., itemsize * size . ndim :\u2002 int The array\u2019s number of dimensions. shape :\u2002 tuple of ints Shape of the array. strides :\u2002 tuple of ints The step-size required to move from one element to the next in memory. For example, a contiguous (3, 4) array of type int16 in C-order has strides (8, 2) . This implies that to move from element to element in memory requires jumps of 2 bytes. To move from row-to-row, one needs to jump 8 bytes at a time ( 2 * 4 ). ctypes :\u2002 ctypes object Class containing properties of the array needed for interaction with ctypes. base :\u2002 ndarray If the array is a view into another array, that array is its base (unless that array is also a view). The base array is where the array data is actually stored. See Also array Construct an array. zeros Create an array, each element of which is zero. empty Create an array, but leave its allocated memory unchanged (i.e., it contains \u201cgarbage\u201d). dtype Create a data-type. Notes There are two modes of creating an array using __new__ : If buffer is None, then only shape , dtype , and order are used. If buffer is an object exposing the buffer interface, then all keywords are interpreted. No __init__ method is needed because the array is fully initialized after the __new__ method. Examples These examples illustrate the low-level ndarray constructor. Refer to the See Also section above for easier ways of constructing an ndarray. First mode, buffer is None: >>> np.ndarray(shape=(2,2), dtype=float, order='F') array([[0.0e+000, 0.0e+000], # random [ nan, 2.5e-323]]) Second mode: >>> np.ndarray((2,), buffer=np.array([1,2,3]), ... offset=np.int_().itemsize, ... dtype=int) # offset = 1*itemsize, i.e. skip first element array([2, 3]) Ancestors Structural_Vector numpy.ndarray Class variables var tag Instance variables var c Removes rows corresponding to element hinges/releases var i Removes rows corresponding to redundant forces var x Removes rows of corresponding to primary forces class Diag_matrix ( arry, rc_data, model) Block diagonal matrix of element flexibility/stiffness matrices for structural model this class represents the block diagonal matrix of element flexibility or stiffness matrices for a structural model. Parameters model Ancestors Structural_Matrix numpy.ndarray Class variables var tag Instance variables var c Removes columns corresponding to element hinges/releases Inherited members Structural_Matrix : del_zeros ker lns nls rank remove round class Displacement_vector ( Kinematic_matrix, Vector=None) ndarray(shape, dtype=float, buffer=None, offset=0, strides=None, order=None) An array object represents a multidimensional, homogeneous array of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, or something else, etc.) Arrays should be constructed using array , zeros or empty (refer to the See Also section below). The parameters given here refer to a low-level method ( ndarray(\u2026) ) for instantiating an array. For more information, refer to the numpy module and examine the methods and attributes of an array. Parameters (for the new method; see Notes below) shape :\u2002 tuple of ints Shape of created array. dtype :\u2002 data-type , optional Any object that can be interpreted as a numpy data type. buffer :\u2002 object exposing buffer interface , optional Used to fill the array with data. offset :\u2002 int , optional Offset of array data in buffer. strides :\u2002 tuple of ints , optional Strides of data in memory. order :\u2002 {'C', 'F'} , optional Row-major (C-style) or column-major (Fortran-style) order. Attributes T :\u2002 ndarray Transpose of the array. data :\u2002 buffer The array\u2019s elements, in memory. dtype :\u2002 dtype object Describes the format of the elements in the array. flags :\u2002 dict Dictionary containing information related to memory use, e.g., \u2018C_CONTIGUOUS,\u2019 \u2018OWNDATA,\u2019 \u2018WRITEABLE,\u2019 etc. flat :\u2002 numpy.flatiter object Flattened version of the array as an iterator. The iterator allows assignments, e.g., x.flat = 3 (See ndarray.flat for assignment examples; TODO). imag :\u2002 ndarray Imaginary part of the array. real :\u2002 ndarray Real part of the array. size :\u2002 int Number of elements in the array. itemsize :\u2002 int The memory use of each array element in bytes. nbytes :\u2002 int The total number of bytes required to store the array data, i.e., itemsize * size . ndim :\u2002 int The array\u2019s number of dimensions. shape :\u2002 tuple of ints Shape of the array. strides :\u2002 tuple of ints The step-size required to move from one element to the next in memory. For example, a contiguous (3, 4) array of type int16 in C-order has strides (8, 2) . This implies that to move from element to element in memory requires jumps of 2 bytes. To move from row-to-row, one needs to jump 8 bytes at a time ( 2 * 4 ). ctypes :\u2002 ctypes object Class containing properties of the array needed for interaction with ctypes. base :\u2002 ndarray If the array is a view into another array, that array is its base (unless that array is also a view). The base array is where the array data is actually stored. See Also array Construct an array. zeros Create an array, each element of which is zero. empty Create an array, but leave its allocated memory unchanged (i.e., it contains \u201cgarbage\u201d). dtype Create a data-type. Notes There are two modes of creating an array using __new__ : If buffer is None, then only shape , dtype , and order are used. If buffer is an object exposing the buffer interface, then all keywords are interpreted. No __init__ method is needed because the array is fully initialized after the __new__ method. Examples These examples illustrate the low-level ndarray constructor. Refer to the See Also section above for easier ways of constructing an ndarray. First mode, buffer is None: >>> np.ndarray(shape=(2,2), dtype=float, order='F') array([[0.0e+000, 0.0e+000], # random [ nan, 2.5e-323]]) Second mode: >>> np.ndarray((2,), buffer=np.array([1,2,3]), ... offset=np.int_().itemsize, ... dtype=int) # offset = 1*itemsize, i.e. skip first element array([2, 3]) Ancestors column_vector Structural_Vector numpy.ndarray Class variables var tag Instance variables var f Removes rows corresponding to fixed dofs class Flexibility_matrix ( model, Roption=True) Parameters model Ancestors Structural_Matrix numpy.ndarray Class variables var tag Instance variables var c Removes rows corresponding to element hinges/releases Inherited members Structural_Matrix : del_zeros ker lns nls rank remove round class Kinematic_matrix ( model, matrix=None, rng=None) Class for the kinematic matrix of a structural model with 2d/3d truss and 2d frame elements the function forms the kinematic matrix A for all degrees of freedom and all element deformations of the structural model specified in data structure MODEL the function is currently limited to 2d/3d truss and 2d frame elements Returns Kinematic matrix Ancestors Structural_Matrix numpy.ndarray Class variables var ranges Instance variables var c Removes rows corresponding to element hinges/releases var c0 var d Removes columns corresponding to free dofs var e var f Removes columns corresponding to fixed dofs var i Removes rows corresponding to redundant forces var o Methods def combine ( self, component) Inherited members Structural_Matrix : del_zeros ker lns nls rank remove round class Mass_matrix ( mat) ndarray(shape, dtype=float, buffer=None, offset=0, strides=None, order=None) An array object represents a multidimensional, homogeneous array of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, or something else, etc.) Arrays should be constructed using array , zeros or empty (refer to the See Also section below). The parameters given here refer to a low-level method ( ndarray(\u2026) ) for instantiating an array. For more information, refer to the numpy module and examine the methods and attributes of an array. Parameters (for the new method; see Notes below) shape :\u2002 tuple of ints Shape of created array. dtype :\u2002 data-type , optional Any object that can be interpreted as a numpy data type. buffer :\u2002 object exposing buffer interface , optional Used to fill the array with data. offset :\u2002 int , optional Offset of array data in buffer. strides :\u2002 tuple of ints , optional Strides of data in memory. order :\u2002 {'C', 'F'} , optional Row-major (C-style) or column-major (Fortran-style) order. Attributes T :\u2002 ndarray Transpose of the array. data :\u2002 buffer The array\u2019s elements, in memory. dtype :\u2002 dtype object Describes the format of the elements in the array. flags :\u2002 dict Dictionary containing information related to memory use, e.g., \u2018C_CONTIGUOUS,\u2019 \u2018OWNDATA,\u2019 \u2018WRITEABLE,\u2019 etc. flat :\u2002 numpy.flatiter object Flattened version of the array as an iterator. The iterator allows assignments, e.g., x.flat = 3 (See ndarray.flat for assignment examples; TODO). imag :\u2002 ndarray Imaginary part of the array. real :\u2002 ndarray Real part of the array. size :\u2002 int Number of elements in the array. itemsize :\u2002 int The memory use of each array element in bytes. nbytes :\u2002 int The total number of bytes required to store the array data, i.e., itemsize * size . ndim :\u2002 int The array\u2019s number of dimensions. shape :\u2002 tuple of ints Shape of the array. strides :\u2002 tuple of ints The step-size required to move from one element to the next in memory. For example, a contiguous (3, 4) array of type int16 in C-order has strides (8, 2) . This implies that to move from element to element in memory requires jumps of 2 bytes. To move from row-to-row, one needs to jump 8 bytes at a time ( 2 * 4 ). ctypes :\u2002 ctypes object Class containing properties of the array needed for interaction with ctypes. base :\u2002 ndarray If the array is a view into another array, that array is its base (unless that array is also a view). The base array is where the array data is actually stored. See Also array Construct an array. zeros Create an array, each element of which is zero. empty Create an array, but leave its allocated memory unchanged (i.e., it contains \u201cgarbage\u201d). dtype Create a data-type. Notes There are two modes of creating an array using __new__ : If buffer is None, then only shape , dtype , and order are used. If buffer is an object exposing the buffer interface, then all keywords are interpreted. No __init__ method is needed because the array is fully initialized after the __new__ method. Examples These examples illustrate the low-level ndarray constructor. Refer to the See Also section above for easier ways of constructing an ndarray. First mode, buffer is None: >>> np.ndarray(shape=(2,2), dtype=float, order='F') array([[0.0e+000, 0.0e+000], # random [ nan, 2.5e-323]]) Second mode: >>> np.ndarray((2,), buffer=np.array([1,2,3]), ... offset=np.int_().itemsize, ... dtype=int) # offset = 1*itemsize, i.e. skip first element array([2, 3]) Ancestors Structural_Matrix numpy.ndarray Class variables var tag Instance variables var f var m Inherited members Structural_Matrix : del_zeros ker lns nls rank remove round class Static_matrix ( model, matrix=None, rng=None) B_MATRIX static matrix of structural model with 2d/3d truss and 2d frame elements the function forms the static matrix B for all degrees of freedom and all basic forces of the structural model specified in data structure MODEL; the function is currently limited to 2d/3d truss and 2d frame elements Parameters model :\u2002 emme.Model object Partitions ========================================================================================= B.f : nf x ntq B.c : nf x nq B.fc : nf x nq B.i : ni x nq B.x : nx x nq where: ni: number of primary (non-redundant) forces. nq: number of total, continuous forces. nx: number of redundant forces. Ancestors Structural_Matrix numpy.ndarray Class variables var ranges Instance variables var bari var barx var barxi var c var c0 var d Removes rows corresponding to free dofs var f var fc var i Removes rows of B_matrix corresponding to primary (non-redundant) forces var o Remove columns corresponding to element force releases, then delete zeros var x Removes rows of B_matrix corresponding to primary (non-redundant) forces Inherited members Structural_Matrix : del_zeros ker lns nls rank remove round class Stiffness_matrix ( arry, model, Roption=None) \u2026 Parameters ============ model Ancestors Structural_Matrix numpy.ndarray Class variables var tag Instance variables var f Inherited members Structural_Matrix : del_zeros ker lns nls rank remove round class Structural_Matrix ( mat) ndarray(shape, dtype=float, buffer=None, offset=0, strides=None, order=None) An array object represents a multidimensional, homogeneous array of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, or something else, etc.) Arrays should be constructed using array , zeros or empty (refer to the See Also section below). The parameters given here refer to a low-level method ( ndarray(\u2026) ) for instantiating an array. For more information, refer to the numpy module and examine the methods and attributes of an array. Parameters (for the new method; see Notes below) shape :\u2002 tuple of ints Shape of created array. dtype :\u2002 data-type , optional Any object that can be interpreted as a numpy data type. buffer :\u2002 object exposing buffer interface , optional Used to fill the array with data. offset :\u2002 int , optional Offset of array data in buffer. strides :\u2002 tuple of ints , optional Strides of data in memory. order :\u2002 {'C', 'F'} , optional Row-major (C-style) or column-major (Fortran-style) order. Attributes T :\u2002 ndarray Transpose of the array. data :\u2002 buffer The array\u2019s elements, in memory. dtype :\u2002 dtype object Describes the format of the elements in the array. flags :\u2002 dict Dictionary containing information related to memory use, e.g., \u2018C_CONTIGUOUS,\u2019 \u2018OWNDATA,\u2019 \u2018WRITEABLE,\u2019 etc. flat :\u2002 numpy.flatiter object Flattened version of the array as an iterator. The iterator allows assignments, e.g., x.flat = 3 (See ndarray.flat for assignment examples; TODO). imag :\u2002 ndarray Imaginary part of the array. real :\u2002 ndarray Real part of the array. size :\u2002 int Number of elements in the array. itemsize :\u2002 int The memory use of each array element in bytes. nbytes :\u2002 int The total number of bytes required to store the array data, i.e., itemsize * size . ndim :\u2002 int The array\u2019s number of dimensions. shape :\u2002 tuple of ints Shape of the array. strides :\u2002 tuple of ints The step-size required to move from one element to the next in memory. For example, a contiguous (3, 4) array of type int16 in C-order has strides (8, 2) . This implies that to move from element to element in memory requires jumps of 2 bytes. To move from row-to-row, one needs to jump 8 bytes at a time ( 2 * 4 ). ctypes :\u2002 ctypes object Class containing properties of the array needed for interaction with ctypes. base :\u2002 ndarray If the array is a view into another array, that array is its base (unless that array is also a view). The base array is where the array data is actually stored. See Also array Construct an array. zeros Create an array, each element of which is zero. empty Create an array, but leave its allocated memory unchanged (i.e., it contains \u201cgarbage\u201d). dtype Create a data-type. Notes There are two modes of creating an array using __new__ : If buffer is None, then only shape , dtype , and order are used. If buffer is an object exposing the buffer interface, then all keywords are interpreted. No __init__ method is needed because the array is fully initialized after the __new__ method. Examples These examples illustrate the low-level ndarray constructor. Refer to the See Also section above for easier ways of constructing an ndarray. First mode, buffer is None: >>> np.ndarray(shape=(2,2), dtype=float, order='F') array([[0.0e+000, 0.0e+000], # random [ nan, 2.5e-323]]) Second mode: >>> np.ndarray((2,), buffer=np.array([1,2,3]), ... offset=np.int_().itemsize, ... dtype=int) # offset = 1*itemsize, i.e. skip first element array([2, 3]) Ancestors numpy.ndarray Subclasses Diag_matrix Flexibility_matrix Kinematic_matrix Mass_matrix Static_matrix Stiffness_matrix nKinematic_matrix nStatic_matrix Class variables var c_cidx var c_ridx var column_data var row_data var tag Instance variables var c var df var disp var inv var ker Return a basis for the kernel (nullspace) of a matrix. var lns Return a basis for the left nullspace of a matrix. var nls return a basis for the nullspace of matrix. var rank Return the rank of a matrix Methods def add_cols ( self, component) def add_rows ( self, component) def del_zeros ( self) Delete rows and columns of a matrix with all zeros def get ( self, row_name, col_name) def lu ( self) def remove ( self, component) Remove items by looking up column_data/row_data def round ( self, num) a.round(decimals=0, out=None) Return a with each element rounded to the given number of decimals. Refer to numpy.around for full documentation. See Also numpy.around equivalent function def rows ( self, component) class Structural_Vector ( mat) ndarray(shape, dtype=float, buffer=None, offset=0, strides=None, order=None) An array object represents a multidimensional, homogeneous array of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, or something else, etc.) Arrays should be constructed using array , zeros or empty (refer to the See Also section below). The parameters given here refer to a low-level method ( ndarray(\u2026) ) for instantiating an array. For more information, refer to the numpy module and examine the methods and attributes of an array. Parameters (for the new method; see Notes below) shape :\u2002 tuple of ints Shape of created array. dtype :\u2002 data-type , optional Any object that can be interpreted as a numpy data type. buffer :\u2002 object exposing buffer interface , optional Used to fill the array with data. offset :\u2002 int , optional Offset of array data in buffer. strides :\u2002 tuple of ints , optional Strides of data in memory. order :\u2002 {'C', 'F'} , optional Row-major (C-style) or column-major (Fortran-style) order. Attributes T :\u2002 ndarray Transpose of the array. data :\u2002 buffer The array\u2019s elements, in memory. dtype :\u2002 dtype object Describes the format of the elements in the array. flags :\u2002 dict Dictionary containing information related to memory use, e.g., \u2018C_CONTIGUOUS,\u2019 \u2018OWNDATA,\u2019 \u2018WRITEABLE,\u2019 etc. flat :\u2002 numpy.flatiter object Flattened version of the array as an iterator. The iterator allows assignments, e.g., x.flat = 3 (See ndarray.flat for assignment examples; TODO). imag :\u2002 ndarray Imaginary part of the array. real :\u2002 ndarray Real part of the array. size :\u2002 int Number of elements in the array. itemsize :\u2002 int The memory use of each array element in bytes. nbytes :\u2002 int The total number of bytes required to store the array data, i.e., itemsize * size . ndim :\u2002 int The array\u2019s number of dimensions. shape :\u2002 tuple of ints Shape of the array. strides :\u2002 tuple of ints The step-size required to move from one element to the next in memory. For example, a contiguous (3, 4) array of type int16 in C-order has strides (8, 2) . This implies that to move from element to element in memory requires jumps of 2 bytes. To move from row-to-row, one needs to jump 8 bytes at a time ( 2 * 4 ). ctypes :\u2002 ctypes object Class containing properties of the array needed for interaction with ctypes. base :\u2002 ndarray If the array is a view into another array, that array is its base (unless that array is also a view). The base array is where the array data is actually stored. See Also array Construct an array. zeros Create an array, each element of which is zero. empty Create an array, but leave its allocated memory unchanged (i.e., it contains \u201cgarbage\u201d). dtype Create a data-type. Notes There are two modes of creating an array using __new__ : If buffer is None, then only shape , dtype , and order are used. If buffer is an object exposing the buffer interface, then all keywords are interpreted. No __init__ method is needed because the array is fully initialized after the __new__ method. Examples These examples illustrate the low-level ndarray constructor. Refer to the See Also section above for easier ways of constructing an ndarray. First mode, buffer is None: >>> np.ndarray(shape=(2,2), dtype=float, order='F') array([[0.0e+000, 0.0e+000], # random [ nan, 2.5e-323]]) Second mode: >>> np.ndarray((2,), buffer=np.array([1,2,3]), ... offset=np.int_().itemsize, ... dtype=int) # offset = 1*itemsize, i.e. skip first element array([2, 3]) Ancestors numpy.ndarray Subclasses Deformation_vector column_vector iForce_vector nDisplacement_vector nForce_vector row_vector Class variables var column_data var row_data var subs var tag Instance variables var df var disp var symb Methods def get ( self, key) def rows ( self, component) def set_item ( self, key, value) class column_vector ( Matrix, Vector=None) ndarray(shape, dtype=float, buffer=None, offset=0, strides=None, order=None) An array object represents a multidimensional, homogeneous array of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, or something else, etc.) Arrays should be constructed using array , zeros or empty (refer to the See Also section below). The parameters given here refer to a low-level method ( ndarray(\u2026) ) for instantiating an array. For more information, refer to the numpy module and examine the methods and attributes of an array. Parameters (for the new method; see Notes below) shape :\u2002 tuple of ints Shape of created array. dtype :\u2002 data-type , optional Any object that can be interpreted as a numpy data type. buffer :\u2002 object exposing buffer interface , optional Used to fill the array with data. offset :\u2002 int , optional Offset of array data in buffer. strides :\u2002 tuple of ints , optional Strides of data in memory. order :\u2002 {'C', 'F'} , optional Row-major (C-style) or column-major (Fortran-style) order. Attributes T :\u2002 ndarray Transpose of the array. data :\u2002 buffer The array\u2019s elements, in memory. dtype :\u2002 dtype object Describes the format of the elements in the array. flags :\u2002 dict Dictionary containing information related to memory use, e.g., \u2018C_CONTIGUOUS,\u2019 \u2018OWNDATA,\u2019 \u2018WRITEABLE,\u2019 etc. flat :\u2002 numpy.flatiter object Flattened version of the array as an iterator. The iterator allows assignments, e.g., x.flat = 3 (See ndarray.flat for assignment examples; TODO). imag :\u2002 ndarray Imaginary part of the array. real :\u2002 ndarray Real part of the array. size :\u2002 int Number of elements in the array. itemsize :\u2002 int The memory use of each array element in bytes. nbytes :\u2002 int The total number of bytes required to store the array data, i.e., itemsize * size . ndim :\u2002 int The array\u2019s number of dimensions. shape :\u2002 tuple of ints Shape of the array. strides :\u2002 tuple of ints The step-size required to move from one element to the next in memory. For example, a contiguous (3, 4) array of type int16 in C-order has strides (8, 2) . This implies that to move from element to element in memory requires jumps of 2 bytes. To move from row-to-row, one needs to jump 8 bytes at a time ( 2 * 4 ). ctypes :\u2002 ctypes object Class containing properties of the array needed for interaction with ctypes. base :\u2002 ndarray If the array is a view into another array, that array is its base (unless that array is also a view). The base array is where the array data is actually stored. See Also array Construct an array. zeros Create an array, each element of which is zero. empty Create an array, but leave its allocated memory unchanged (i.e., it contains \u201cgarbage\u201d). dtype Create a data-type. Notes There are two modes of creating an array using __new__ : If buffer is None, then only shape , dtype , and order are used. If buffer is an object exposing the buffer interface, then all keywords are interpreted. No __init__ method is needed because the array is fully initialized after the __new__ method. Examples These examples illustrate the low-level ndarray constructor. Refer to the See Also section above for easier ways of constructing an ndarray. First mode, buffer is None: >>> np.ndarray(shape=(2,2), dtype=float, order='F') array([[0.0e+000, 0.0e+000], # random [ nan, 2.5e-323]]) Second mode: >>> np.ndarray((2,), buffer=np.array([1,2,3]), ... offset=np.int_().itemsize, ... dtype=int) # offset = 1*itemsize, i.e. skip first element array([2, 3]) Ancestors Structural_Vector numpy.ndarray Subclasses Displacement_vector class iForce_vector ( arry, model, row_data, Vector=None) ndarray(shape, dtype=float, buffer=None, offset=0, strides=None, order=None) An array object represents a multidimensional, homogeneous array of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, or something else, etc.) Arrays should be constructed using array , zeros or empty (refer to the See Also section below). The parameters given here refer to a low-level method ( ndarray(\u2026) ) for instantiating an array. For more information, refer to the numpy module and examine the methods and attributes of an array. Parameters (for the new method; see Notes below) shape :\u2002 tuple of ints Shape of created array. dtype :\u2002 data-type , optional Any object that can be interpreted as a numpy data type. buffer :\u2002 object exposing buffer interface , optional Used to fill the array with data. offset :\u2002 int , optional Offset of array data in buffer. strides :\u2002 tuple of ints , optional Strides of data in memory. order :\u2002 {'C', 'F'} , optional Row-major (C-style) or column-major (Fortran-style) order. Attributes T :\u2002 ndarray Transpose of the array. data :\u2002 buffer The array\u2019s elements, in memory. dtype :\u2002 dtype object Describes the format of the elements in the array. flags :\u2002 dict Dictionary containing information related to memory use, e.g., \u2018C_CONTIGUOUS,\u2019 \u2018OWNDATA,\u2019 \u2018WRITEABLE,\u2019 etc. flat :\u2002 numpy.flatiter object Flattened version of the array as an iterator. The iterator allows assignments, e.g., x.flat = 3 (See ndarray.flat for assignment examples; TODO). imag :\u2002 ndarray Imaginary part of the array. real :\u2002 ndarray Real part of the array. size :\u2002 int Number of elements in the array. itemsize :\u2002 int The memory use of each array element in bytes. nbytes :\u2002 int The total number of bytes required to store the array data, i.e., itemsize * size . ndim :\u2002 int The array\u2019s number of dimensions. shape :\u2002 tuple of ints Shape of the array. strides :\u2002 tuple of ints The step-size required to move from one element to the next in memory. For example, a contiguous (3, 4) array of type int16 in C-order has strides (8, 2) . This implies that to move from element to element in memory requires jumps of 2 bytes. To move from row-to-row, one needs to jump 8 bytes at a time ( 2 * 4 ). ctypes :\u2002 ctypes object Class containing properties of the array needed for interaction with ctypes. base :\u2002 ndarray If the array is a view into another array, that array is its base (unless that array is also a view). The base array is where the array data is actually stored. See Also array Construct an array. zeros Create an array, each element of which is zero. empty Create an array, but leave its allocated memory unchanged (i.e., it contains \u201cgarbage\u201d). dtype Create a data-type. Notes There are two modes of creating an array using __new__ : If buffer is None, then only shape , dtype , and order are used. If buffer is an object exposing the buffer interface, then all keywords are interpreted. No __init__ method is needed because the array is fully initialized after the __new__ method. Examples These examples illustrate the low-level ndarray constructor. Refer to the See Also section above for easier ways of constructing an ndarray. First mode, buffer is None: >>> np.ndarray(shape=(2,2), dtype=float, order='F') array([[0.0e+000, 0.0e+000], # random [ nan, 2.5e-323]]) Second mode: >>> np.ndarray((2,), buffer=np.array([1,2,3]), ... offset=np.int_().itemsize, ... dtype=int) # offset = 1*itemsize, i.e. skip first element array([2, 3]) Ancestors Structural_Vector numpy.ndarray Class variables var tag Instance variables var c Remove rows corresponding to element hinges/releases var i Removes rows corresponding to redundant forces var x Remove rows of corresponding to primary forces class nDisplacement_vector ( arry, model, row_data, Vector=None) ndarray(shape, dtype=float, buffer=None, offset=0, strides=None, order=None) An array object represents a multidimensional, homogeneous array of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, or something else, etc.) Arrays should be constructed using array , zeros or empty (refer to the See Also section below). The parameters given here refer to a low-level method ( ndarray(\u2026) ) for instantiating an array. For more information, refer to the numpy module and examine the methods and attributes of an array. Parameters (for the new method; see Notes below) shape :\u2002 tuple of ints Shape of created array. dtype :\u2002 data-type , optional Any object that can be interpreted as a numpy data type. buffer :\u2002 object exposing buffer interface , optional Used to fill the array with data. offset :\u2002 int , optional Offset of array data in buffer. strides :\u2002 tuple of ints , optional Strides of data in memory. order :\u2002 {'C', 'F'} , optional Row-major (C-style) or column-major (Fortran-style) order. Attributes T :\u2002 ndarray Transpose of the array. data :\u2002 buffer The array\u2019s elements, in memory. dtype :\u2002 dtype object Describes the format of the elements in the array. flags :\u2002 dict Dictionary containing information related to memory use, e.g., \u2018C_CONTIGUOUS,\u2019 \u2018OWNDATA,\u2019 \u2018WRITEABLE,\u2019 etc. flat :\u2002 numpy.flatiter object Flattened version of the array as an iterator. The iterator allows assignments, e.g., x.flat = 3 (See ndarray.flat for assignment examples; TODO). imag :\u2002 ndarray Imaginary part of the array. real :\u2002 ndarray Real part of the array. size :\u2002 int Number of elements in the array. itemsize :\u2002 int The memory use of each array element in bytes. nbytes :\u2002 int The total number of bytes required to store the array data, i.e., itemsize * size . ndim :\u2002 int The array\u2019s number of dimensions. shape :\u2002 tuple of ints Shape of the array. strides :\u2002 tuple of ints The step-size required to move from one element to the next in memory. For example, a contiguous (3, 4) array of type int16 in C-order has strides (8, 2) . This implies that to move from element to element in memory requires jumps of 2 bytes. To move from row-to-row, one needs to jump 8 bytes at a time ( 2 * 4 ). ctypes :\u2002 ctypes object Class containing properties of the array needed for interaction with ctypes. base :\u2002 ndarray If the array is a view into another array, that array is its base (unless that array is also a view). The base array is where the array data is actually stored. See Also array Construct an array. zeros Create an array, each element of which is zero. empty Create an array, but leave its allocated memory unchanged (i.e., it contains \u201cgarbage\u201d). dtype Create a data-type. Notes There are two modes of creating an array using __new__ : If buffer is None, then only shape , dtype , and order are used. If buffer is an object exposing the buffer interface, then all keywords are interpreted. No __init__ method is needed because the array is fully initialized after the __new__ method. Examples These examples illustrate the low-level ndarray constructor. Refer to the See Also section above for easier ways of constructing an ndarray. First mode, buffer is None: >>> np.ndarray(shape=(2,2), dtype=float, order='F') array([[0.0e+000, 0.0e+000], # random [ nan, 2.5e-323]]) Second mode: >>> np.ndarray((2,), buffer=np.array([1,2,3]), ... offset=np.int_().itemsize, ... dtype=int) # offset = 1*itemsize, i.e. skip first element array([2, 3]) Ancestors Structural_Vector numpy.ndarray Class variables var tag Instance variables var f Removes rows corresponding to fixed dofs class nForce_vector ( arry, model, row_data, Vector=None) ndarray(shape, dtype=float, buffer=None, offset=0, strides=None, order=None) An array object represents a multidimensional, homogeneous array of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, or something else, etc.) Arrays should be constructed using array , zeros or empty (refer to the See Also section below). The parameters given here refer to a low-level method ( ndarray(\u2026) ) for instantiating an array. For more information, refer to the numpy module and examine the methods and attributes of an array. Parameters (for the new method; see Notes below) shape :\u2002 tuple of ints Shape of created array. dtype :\u2002 data-type , optional Any object that can be interpreted as a numpy data type. buffer :\u2002 object exposing buffer interface , optional Used to fill the array with data. offset :\u2002 int , optional Offset of array data in buffer. strides :\u2002 tuple of ints , optional Strides of data in memory. order :\u2002 {'C', 'F'} , optional Row-major (C-style) or column-major (Fortran-style) order. Attributes T :\u2002 ndarray Transpose of the array. data :\u2002 buffer The array\u2019s elements, in memory. dtype :\u2002 dtype object Describes the format of the elements in the array. flags :\u2002 dict Dictionary containing information related to memory use, e.g., \u2018C_CONTIGUOUS,\u2019 \u2018OWNDATA,\u2019 \u2018WRITEABLE,\u2019 etc. flat :\u2002 numpy.flatiter object Flattened version of the array as an iterator. The iterator allows assignments, e.g., x.flat = 3 (See ndarray.flat for assignment examples; TODO). imag :\u2002 ndarray Imaginary part of the array. real :\u2002 ndarray Real part of the array. size :\u2002 int Number of elements in the array. itemsize :\u2002 int The memory use of each array element in bytes. nbytes :\u2002 int The total number of bytes required to store the array data, i.e., itemsize * size . ndim :\u2002 int The array\u2019s number of dimensions. shape :\u2002 tuple of ints Shape of the array. strides :\u2002 tuple of ints The step-size required to move from one element to the next in memory. For example, a contiguous (3, 4) array of type int16 in C-order has strides (8, 2) . This implies that to move from element to element in memory requires jumps of 2 bytes. To move from row-to-row, one needs to jump 8 bytes at a time ( 2 * 4 ). ctypes :\u2002 ctypes object Class containing properties of the array needed for interaction with ctypes. base :\u2002 ndarray If the array is a view into another array, that array is its base (unless that array is also a view). The base array is where the array data is actually stored. See Also array Construct an array. zeros Create an array, each element of which is zero. empty Create an array, but leave its allocated memory unchanged (i.e., it contains \u201cgarbage\u201d). dtype Create a data-type. Notes There are two modes of creating an array using __new__ : If buffer is None, then only shape , dtype , and order are used. If buffer is an object exposing the buffer interface, then all keywords are interpreted. No __init__ method is needed because the array is fully initialized after the __new__ method. Examples These examples illustrate the low-level ndarray constructor. Refer to the See Also section above for easier ways of constructing an ndarray. First mode, buffer is None: >>> np.ndarray(shape=(2,2), dtype=float, order='F') array([[0.0e+000, 0.0e+000], # random [ nan, 2.5e-323]]) Second mode: >>> np.ndarray((2,), buffer=np.array([1,2,3]), ... offset=np.int_().itemsize, ... dtype=int) # offset = 1*itemsize, i.e. skip first element array([2, 3]) Ancestors Structural_Vector numpy.ndarray Class variables var tag Instance variables var d Removes rows corresponding to free dofs var f class nKinematic_matrix ( arry, model, rcdata) Class for the kinematic matrix of a structural model with 2d/3d truss and 2d frame elements the function forms the kinematic matrix A for all degrees of freedom and all element deformations of the structural model specified in data structure MODEL the function is currently limited to 2d/3d truss and 2d frame elements Returns Kinematic matrix Ancestors Structural_Matrix numpy.ndarray Class variables var ranges Instance variables var c Removes rows corresponding to element hinges/releases var c0 var d Removes columns corresponding to free dofs var e var f Removes columns corresponding to fixed dofs var i Removes rows corresponding to redundant forces var o Methods def combine ( self, component) Inherited members Structural_Matrix : del_zeros ker lns nls rank remove round class nStatic_matrix ( arry, model, rcdata) ndarray(shape, dtype=float, buffer=None, offset=0, strides=None, order=None) An array object represents a multidimensional, homogeneous array of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, or something else, etc.) Arrays should be constructed using array , zeros or empty (refer to the See Also section below). The parameters given here refer to a low-level method ( ndarray(\u2026) ) for instantiating an array. For more information, refer to the numpy module and examine the methods and attributes of an array. Parameters (for the new method; see Notes below) shape :\u2002 tuple of ints Shape of created array. dtype :\u2002 data-type , optional Any object that can be interpreted as a numpy data type. buffer :\u2002 object exposing buffer interface , optional Used to fill the array with data. offset :\u2002 int , optional Offset of array data in buffer. strides :\u2002 tuple of ints , optional Strides of data in memory. order :\u2002 {'C', 'F'} , optional Row-major (C-style) or column-major (Fortran-style) order. Attributes T :\u2002 ndarray Transpose of the array. data :\u2002 buffer The array\u2019s elements, in memory. dtype :\u2002 dtype object Describes the format of the elements in the array. flags :\u2002 dict Dictionary containing information related to memory use, e.g., \u2018C_CONTIGUOUS,\u2019 \u2018OWNDATA,\u2019 \u2018WRITEABLE,\u2019 etc. flat :\u2002 numpy.flatiter object Flattened version of the array as an iterator. The iterator allows assignments, e.g., x.flat = 3 (See ndarray.flat for assignment examples; TODO). imag :\u2002 ndarray Imaginary part of the array. real :\u2002 ndarray Real part of the array. size :\u2002 int Number of elements in the array. itemsize :\u2002 int The memory use of each array element in bytes. nbytes :\u2002 int The total number of bytes required to store the array data, i.e., itemsize * size . ndim :\u2002 int The array\u2019s number of dimensions. shape :\u2002 tuple of ints Shape of the array. strides :\u2002 tuple of ints The step-size required to move from one element to the next in memory. For example, a contiguous (3, 4) array of type int16 in C-order has strides (8, 2) . This implies that to move from element to element in memory requires jumps of 2 bytes. To move from row-to-row, one needs to jump 8 bytes at a time ( 2 * 4 ). ctypes :\u2002 ctypes object Class containing properties of the array needed for interaction with ctypes. base :\u2002 ndarray If the array is a view into another array, that array is its base (unless that array is also a view). The base array is where the array data is actually stored. See Also array Construct an array. zeros Create an array, each element of which is zero. empty Create an array, but leave its allocated memory unchanged (i.e., it contains \u201cgarbage\u201d). dtype Create a data-type. Notes There are two modes of creating an array using __new__ : If buffer is None, then only shape , dtype , and order are used. If buffer is an object exposing the buffer interface, then all keywords are interpreted. No __init__ method is needed because the array is fully initialized after the __new__ method. Examples These examples illustrate the low-level ndarray constructor. Refer to the See Also section above for easier ways of constructing an ndarray. First mode, buffer is None: >>> np.ndarray(shape=(2,2), dtype=float, order='F') array([[0.0e+000, 0.0e+000], # random [ nan, 2.5e-323]]) Second mode: >>> np.ndarray((2,), buffer=np.array([1,2,3]), ... offset=np.int_().itemsize, ... dtype=int) # offset = 1*itemsize, i.e. skip first element array([2, 3]) Ancestors Structural_Matrix numpy.ndarray Class variables var ranges Instance variables var bari var barx var barxi var c Removes columns corresponding to element hinges/releases var c0 var d Removes rows corresponding to free dofs var f var fc var i Removes rows of B_matrix corresponding to redundant forces var o Remove columns corresponding to element force releases, then delete zeros var x Removes rows of B_matrix corresponding to primary (non-redundant) forces Inherited members Structural_Matrix : del_zeros ker lns nls rank remove round class row_vector ( Matrix) ndarray(shape, dtype=float, buffer=None, offset=0, strides=None, order=None) An array object represents a multidimensional, homogeneous array of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, or something else, etc.) Arrays should be constructed using array , zeros or empty (refer to the See Also section below). The parameters given here refer to a low-level method ( ndarray(\u2026) ) for instantiating an array. For more information, refer to the numpy module and examine the methods and attributes of an array. Parameters (for the new method; see Notes below) shape :\u2002 tuple of ints Shape of created array. dtype :\u2002 data-type , optional Any object that can be interpreted as a numpy data type. buffer :\u2002 object exposing buffer interface , optional Used to fill the array with data. offset :\u2002 int , optional Offset of array data in buffer. strides :\u2002 tuple of ints , optional Strides of data in memory. order :\u2002 {'C', 'F'} , optional Row-major (C-style) or column-major (Fortran-style) order. Attributes T :\u2002 ndarray Transpose of the array. data :\u2002 buffer The array\u2019s elements, in memory. dtype :\u2002 dtype object Describes the format of the elements in the array. flags :\u2002 dict Dictionary containing information related to memory use, e.g., \u2018C_CONTIGUOUS,\u2019 \u2018OWNDATA,\u2019 \u2018WRITEABLE,\u2019 etc. flat :\u2002 numpy.flatiter object Flattened version of the array as an iterator. The iterator allows assignments, e.g., x.flat = 3 (See ndarray.flat for assignment examples; TODO). imag :\u2002 ndarray Imaginary part of the array. real :\u2002 ndarray Real part of the array. size :\u2002 int Number of elements in the array. itemsize :\u2002 int The memory use of each array element in bytes. nbytes :\u2002 int The total number of bytes required to store the array data, i.e., itemsize * size . ndim :\u2002 int The array\u2019s number of dimensions. shape :\u2002 tuple of ints Shape of the array. strides :\u2002 tuple of ints The step-size required to move from one element to the next in memory. For example, a contiguous (3, 4) array of type int16 in C-order has strides (8, 2) . This implies that to move from element to element in memory requires jumps of 2 bytes. To move from row-to-row, one needs to jump 8 bytes at a time ( 2 * 4 ). ctypes :\u2002 ctypes object Class containing properties of the array needed for interaction with ctypes. base :\u2002 ndarray If the array is a view into another array, that array is its base (unless that array is also a view). The base array is where the array data is actually stored. See Also array Construct an array. zeros Create an array, each element of which is zero. empty Create an array, but leave its allocated memory unchanged (i.e., it contains \u201cgarbage\u201d). dtype Create a data-type. Notes There are two modes of creating an array using __new__ : If buffer is None, then only shape , dtype , and order are used. If buffer is an object exposing the buffer interface, then all keywords are interpreted. No __init__ method is needed because the array is fully initialized after the __new__ method. Examples These examples illustrate the low-level ndarray constructor. Refer to the See Also section above for easier ways of constructing an ndarray. First mode, buffer is None: >>> np.ndarray(shape=(2,2), dtype=float, order='F') array([[0.0e+000, 0.0e+000], # random [ nan, 2.5e-323]]) Second mode: >>> np.ndarray((2,), buffer=np.array([1,2,3]), ... offset=np.int_().itemsize, ... dtype=int) # offset = 1*itemsize, i.e. skip first element array([2, 3]) Ancestors Structural_Vector numpy.ndarray","title":"anabel.matrices"},{"location":"api/latest/sections/","text":"Section Modeling High-level section modeling API. Functions def Composite_Section ( Y, DY, DZ, quad, y_shift=0.0, mat=None) def I_Sect ( b, d, alpha, beta, quad, yref=0.0, MatData=None) def TC_Sect ( d, bf, tw, quad, yref=0.0, tf=None, ymf=None, MatData=None, **kwds) ____________ | | | | ----| |---- | | | | | | ---- def T_Sect ( d, quad, b=None, bf=None, tf=None, tw=None, alpha=None, beta=None, yref=0.0, MatData=None) _____________ | | ------------- | | | | | | ----- def W_Sect ( b, d, alpha, beta, quadf, quadw, yref=0.0, MatData=None) def ei ( y, epsa, kappa) def epsi ( y, epsa, kappa) def load_aisc ( SectionName, props='') Load cross section properties from AISC database. props: A list of AISC properties, or one of the following: - \u2018simple\u2019: A , Ix , Zx def section2d ( yi, dA, nIP, mat, **kwds) Generate a section response function Studies Classes class CompositeSection ( Y, DY, DZ, quad, y_shift=0.0, mat=None) Ancestors Section Subclasses Rectangle Tee Methods def plot ( self, show_properties=True, plain=False, show_quad=True, show_dims=True, annotate=True) Plot a composite cross section. class Rectangle ( b, d, quad=None, yref=0.0, mat=None, **kwds) Rectangular cross section Ancestors CompositeSection Section VerticalSection Inherited members CompositeSection : plot class Section Subclasses CompositeSection Methods def assemble ( self) class Tee ( d=None, quad=None, b=None, bf=None, tf=None, tw=None, alpha=None, beta=None, yref=None, mat=None) bf _____________ | | tf ------------- | | | | | | ----- tw Parameters tf,tw, bf, d: float shape parameters Ancestors CompositeSection Section VerticalSection Methods def annotate ( self, ax) def properties ( self) Inherited members CompositeSection : plot class VerticalSection Subclasses Rectangle Tee Methods def plot_limit ( self, fy=1.0, **kwds) def plot_yield ( self, fy=1.0, **kwds)","title":"anabel.sections"},{"location":"api/latest/template/","text":"Templating Wrappers, decorators and utilities for constructing expression templates. Functions def assemble ( f) def generator ( dim: Union[int, Tuple[Tuple[int, int]]] = None, statevar: str = 'state', main: str = 'main', jacx: str = 'jacx', form: str = 'x,y,s=s,p=p,**e->x,y,s', params: str = 'params', dimvar: str = None, origin: tuple = None, order: int = 0, **kwargs) \u2011> Callable Decorator that wraps a basic local map generator. Attributes origin : A structure containing arguments which may act as an \u2018origin\u2019 for the target function. shape : tuple Description of the shape of the dual and primal spaces. Generated Arguments _expose_closure : bool Expose closed-over local variables as an attribute. _jit : bool If True {.python}, JIT-compiles the target function Studies Structural dynamics ( elle-0008 ) def generator_no2 ( ) def F(): name = \u201cmy-element\u201d def main(x, y, state, **kwds, _name=name): pass def get_unspecified_parameters ( func, recurse=False) created 2021-03-31 def serialize ( f) Requires JAX def template ( dim: Union[int, Tuple[Tuple[int, int]]] = None, statevar: str = 'state', main: str = 'main', jacx: str = 'jacx', form: str = 'x,y,s=s,p=p,**e->x,y,s', params: str = 'params', dimvar: str = None, origin: tuple = None, order: int = 0, **kwargs) \u2011> Callable Decorator that wraps a basic local map generator. Attributes origin : A structure containing arguments which may act as an \u2018origin\u2019 for the target function. shape : tuple Description of the shape of the dual and primal spaces. Generated Arguments _expose_closure : bool Expose closed-over local variables as an attribute. _jit : bool If True {.python}, JIT-compiles the target function Studies Structural dynamics ( elle-0008 ) def wrap ( f, *args, **kwds) Wrap a pre-defined function to act as a local dual map. Classes class Dual","title":"anabel.template"},{"location":"api/latest/transient/","text":"Transient General transformations and utilities for transient modeling. Functions def linear_hot ( f, df) Add a linear higher order term to a function Examples First define some matrices >> A = jnp.array([[ 1.0 , 0.0 , 0.0 ], [ 0.0 , 4.0 , 2.0 ], [ 0.0 , 2.0 , 4.0 ]]) >> B = jnp.array([[ - 0.23939017 , 0.58743526 , - 0.77305379 ], [ 0.81921268 , - 0.30515101 , - 0.48556508 ], [ - 0.52113619 , - 0.74953498 , - 0.40818426 ]]) >> C = A @ B Next define a linear function, f: x -> Ax : >> f = anon.dual.wrap( lambda x, * args, ** kwds: x, A @ x, {}, dim = 3 ) Create a new function with a linear higher order term ( ff: x,dx -> f(x) + Bdx ) >> ff = linear_hot(f, B) >> x = dx = jnp.ones(( 3 , 1 )) >> f(x) (DeviceArray([[ 1. ], [ 1. ], [ 1. ]], dtype = float32), DeviceArray([[ 1. ], [ 6. ], [ 6. ]], dtype = float32), {}) >> ff((x, dx)) ((DeviceArray([[ 1. ], [ 1. ], [ 1. ]], dtype = float32), DeviceArray([[ 1. ], [ 1. ], [ 1. ]], dtype = float32)), DeviceArray([[ 0.57499135 ], [ 6.0284967 ], [ 4.3211446 ]], dtype = float32), {}) Studies elle-0008","title":"anabel.transient"},{"location":"gallery/","text":"Galleries","title":"Galleries"},{"location":"gallery/dynamics/","text":"Examples in Dynamics","title":"Dynamics"},{"location":"gallery/dynamics/225_HW09_P1/","text":"Modal Analysis - Beam import ema as em import matplotlib.pyplot as plt import numpy as np % config InlineBackend.figure_format = 'svg' L = 1 Mass = 100 n = 8 # adjust number of nodes along beam nf = 2 + (n - 2 ) * 2 nt = 3 * n - (n - 1 ) DOFs = [[nt - 2 , 0 , 0 ] for i in range (n)] # Build Model mdl = em.rModel( 2 , 3 ) nd = mdl.nodes for i in range (n): if i == 0 : mass = None DOFs[i][ 1 ] = nf + 2 DOFs[i][ 2 ] = nf - 1 elif i == n - 1 : mass = None DOFs[i][ 1 ] = nf + 3 DOFs[i][ 2 ] = nf else : mass = Mass / (n - 1 ) DOFs[i][ 1 ] = i DOFs[i][ 2 ] = i + (n - 2 ) mdl.node( str (i + 1 ), i * L / (n - 1 ), 0.0 , mass = mass) mdl.girder(nd) mdl.pin(nd[ 0 ]) mdl.fix(nd[ - 1 ], [ 'y' ]) mdl.DOF = DOFs fig, ax = plt.subplots() em.plot_beam(mdl, ax) svg K = em.K_matrix(mdl) M = em.Mass_matrix(mdl) shapes = em.analysis.ModalAnalysis(mdl) # shapes2 = em.analysis.ModalAnalysis(mdl2) U = em.U_vector(em.A_matrix(mdl)) colors = [ 'r' , 'b' , 'g' , 'y' , 'grey' , 'pink' ] # fig, ax = plt.subplots() for i, shape in enumerate (shapes[ 1 ]): U[ 0 :n - 2 ] = shape em.plot_modes(mdl, U, ax, color = colors[i], label = str (i + 1 )) plt.legend() ; No handles with labels found to put in legend. svg","title":"Modal Analysis - Beam"},{"location":"gallery/dynamics/225_HW09_P2v2/","text":"Modal analysis - 1r import ema as em import matplotlib.pyplot as plt import numpy as np % config InlineBackend.figure_format = 'svg' mdl = em.rModel( 2 , 3 ) n = mdl.dnodes e = mdl.delems w = 24 h = 12 mdl.frame(( 1 ,w), ( 3 ,h)) for node in n.values(): mdl.fix(node, 'rz' ) n[ '4' ].mass = 1 n[ '6' ].mass = 1 n[ '8' ].mass = 0.5 mdl.fix(n[ '1' ], [ 'x' , 'y' ]) mdl.fix(n[ '2' ], [ 'x' , 'y' ]) mdl.DOF = [[ 10 , 11 , 12 ], [ 13 , 14 , 15 ], [ 1 , 11 , 4 ], [ 1 , 14 , 5 ], [ 2 , 11 , 6 ], [ 2 , 14 , 7 ], [ 3 , 11 , 8 ], [ 3 , 14 , 9 ]] Part a) K = em.K_matrix(mdl) M = em.Mass_matrix(mdl) K.f * h ** 3 0 1 2 0 48.0 -24.0 0.0 1 -24.0 48.0 -24.0 2 0.0 -24.0 24.0 M.f $u_{{1}}$ $u_{{2}}$ $u_{{3}}$ $u_{{1}}$ 1.0 0.0 0.0 $u_{{2}}$ 0.0 1.0 0.0 $u_{{3}}$ 0.0 0.0 0.5 Part b) shapes = em.analysis.ModalAnalysis(mdl) shapes (array([0.05183404+0.j, 0.02777778+0.j, 0.00372152+0.j]), array([[ 4.08248290e-01, -8.16496581e-01, -4.08248290e-01], [-7.07106781e-01, -3.10316769e-16, -7.07106781e-01], [ 8.16496581e-01, 8.16496581e-01, -8.16496581e-01]])) U = em.U_vector(em.A_matrix(mdl)) colors = [ 'b' , 'y' , 'pink' ] fig, ax = plt.subplots( 1 , 3 ) for i, shape in enumerate (shapes[ 1 ].T): U[ 0 : 3 ] = shape em.plot_modes(mdl, U, ax[i], color = colors[i], label = str (i + 1 )) plt.legend() ; No handles with labels found to put in legend. svg Part c) Verify orthogonality phis = np.around(shapes[ 1 ], 7 ) phis array([[ 0.4082483, -0.8164966, -0.4082483], [-0.7071068, -0. , -0.7071068], [ 0.8164966, 0.8164966, -0.8164966]]) print (phis[:, 0 ] @ M.f @ phis[:, 1 ]) 0.0 print (phis[:, 0 ] @ M.f @ phis[:, 2 ]) 3.2475700462164525e-09 print (phis[:, 1 ] @ M.f @ phis[:, 2 ]) 0.0 Part d) Normalize modes. Each mode shape is normalized so that when multiplied by the problem variable, \\(\\frac{1}{\\sqrt{m}}\\) , they will generate a modal mass matrix, \\(M_n\\) , equal to the identity matrix. phi_n = np.zeros(( 3 , 3 )) phi_n[:, 0 ] = phis[:, 0 ] / ((phis[:, 0 ] @ M.f @ phis[:, 0 ])) ** ( 1 / 2 ) print (phi_n[:, 0 ]) phi_n[:, 0 ].T @ M.f @ phi_n[:, 0 ] [ 0.40824829 -0.70710678 0.81649658] C:\\Users\\claud\\Anaconda3\\lib\\site-packages\\IPython\\core\\formatters.py:371: FormatterWarning: text/html formatter returned invalid type <class 'ema.utilities.Structural_Vector'> (expected <class 'str'>) for object: Structural_Vector(1.) FormatterWarning Structural_Vector(1.) phi_n[:, 1 ] = phis[:, 1 ] / ((phis[:, 1 ] @ M.f @ phis[:, 1 ])) ** ( 1 / 2 ) print (phi_n[:, 1 ]) phi_n[:, 1 ].T @ M.f @ phi_n[:, 1 ] [-0.81649658 -0. 0.81649658] Structural_Vector(1.) phi_n[:, 2 ] = phis[:, 2 ] / ((phis[:, 2 ] @ M.f @ phis[:, 2 ])) ** ( 1 / 2 ) print (phi_n[:, 2 ]) phi_n[:, 2 ].T @ M.f @ phi_n[:, 2 ] [-0.40824829 -0.70710678 -0.81649658] Structural_Vector(1.) Id = np.around(phi_n.T @ M.f @ phi_n, 7 ) Id array([[ 1., 0., 0.], [ 0., 1., -0.], [ 0., -0., 1.]])","title":"Modal Analysis - 1r"},{"location":"gallery/dynamics/225_HW11_P2/","text":"Problem 2 (see Ex 9.6) # Remove import ema as em import matplotlib.pyplot as plt import numpy as np % config InlineBackend.figure_format = 'svg' # used to make plots look nicer from ema_examples.dynamics import E09_06 from ema.utilities.ipyutils import disp_sbs from scipy.linalg import eig L = 1 mass = 1 EI = 1 / 12 mdl = E09_06(L = L, m = mass, EI = EI) fig, ax = plt.subplots() em.plot_structure(mdl, ax) mdl.DOF [[7, 8, 9], [1, 2, 3], [4, 5, 6]] svg m, K = em.Mass_matrix(mdl), em.K_matrix(mdl) m[ 0 , 0 ] = 3. * mass m[ 1 , 1 ] = 1. * mass m[ 2 :, 2 :] = 0 * mass disp_sbs(m.f.df, K.f.df) $u_{{1}}$ $u_{{2}}$ $u_{{3}}$ $u_{{4}}$ $u_{{5}}$ $u_{{6}}$ $u_{{1}}$ 3.0 0.0 0.0 0.0 0.0 0.0 $u_{{2}}$ 0.0 1.0 0.0 0.0 0.0 0.0 $u_{{3}}$ 0.0 0.0 0.0 0.0 0.0 0.0 $u_{{4}}$ 0.0 0.0 0.0 0.0 0.0 0.0 $u_{{5}}$ 0.0 0.0 0.0 0.0 0.0 0.0 $u_{{6}}$ 0.0 0.0 0.0 0.0 0.0 0.0 $1$ $2$ $3$ $4$ $5$ $6$ $P_{1}$ 8334.333333 0.000000 0.500000 -8333.333333 0.0 0.000000 $P_{2}$ 0.000000 8334.333333 0.500000 0.000000 -1.0 0.500000 $P_{3}$ 0.500000 0.500000 0.666667 0.000000 -0.5 0.166667 $P_{4}$ -8333.333333 0.000000 0.000000 8333.333333 0.0 0.000000 $P_{5}$ 0.000000 -1.000000 -0.500000 0.000000 1.0 -0.500000 $P_{6}$ 0.000000 0.500000 0.166667 0.000000 -0.5 0.333333 # k, m = em.analysis.StaticCondensation(k.f, m.f, idxs=[3,4]) k = em.analysis.kStaticCondensation(K.f, idxs = [ 3 , 4 ]) # disp_sbs(k.df) k $4$ $5$ $4$ 0.571384 0.214267 $5$ 0.214267 0.142849 m = m[ 0 : 2 , 0 : 2 ] freq2, Phi = eig(m, k) Phi / 0.57293852 array([[-1. , -0.75123369], [-1.4305171 , 1.57544505]]) M = Phi.T @ m @ Phi K = Phi.T @ k @ Phi M Structural_Vector([[ 1.65651710e+00, -1.11022302e-16], [ 0.00000000e+00, 1.37050677e+00]]) a) Modal expansion of earthquake forces \\[\\mathrm{p}_{\\mathrm{eff}}(t)=-\\mathrm{m} \\iota \\ddot{u}_{g}(t)\\] \\[\\mathbf{m} \\iota=\\sum_{n=1}^{N} \\mathbf{s}_{n}=\\sum_{n=1}^{N} \\Gamma_{n} \\mathbf{m} \\phi_{n}\\] I = N = 2 iota = np.array([ 0 , 1 ]) Ln = np.array([ sum (Phi.T[n,i] * sum (m[i,j] * iota[j] for j in range (I)) for i in range (I)) for n in range (N)]) Ln = Phi.T @ m @ iota Ln Structural_Vector([-0.81959835, 0.90263316]) gamma = np.array([Ln[n] / M[n,n] for n in range (N)]) gamma array([-0.49477204, 0.65861269]) sn = [gamma[n] * (m @ Phi[:,n]) for n in range (N)] sn [Structural_Vector([0.85042189, 0.40551435]), Structural_Vector([-0.85042189, 0.59448565])]","title":"Problem 2"},{"location":"gallery/dynamics/225_HW11_P3-2/","text":"Time History Analysis: MDF Frame import ema as em import matplotlib.pyplot as plt import numpy as np % config InlineBackend.figure_format = 'svg' # used to make plots look nicer from ema_examples.dynamics import P09_07 from ema.utilities.ipyutils import disp_sbs ft = 12 h = 12 * ft m = 80 / 386.4 E = 29000 I = 1000 EI = E * I RHA = False N = I = 3 mdl = P09_07(h = h, m = m, EI = EI) # fig, ax = plt.subplots() # em.plot_structure(mdl, ax) m, k = em.Mass_matrix(mdl), em.K_matrix(mdl) k, m = em.analysis.StaticCondensation(k, m) disp_sbs(m.df, k.df) $u_{1}$ $u_{2}$ $u_{3}$ $u_{1}$ 0.207039 0.000000 0.00000 $u_{2}$ 0.000000 0.207039 0.00000 $u_{3}$ 0.000000 0.000000 0.10352 $1$ $2$ $3$ $P_{1}$ 466.177984 -233.088992 0.000000 $P_{2}$ -233.088992 466.177984 -233.088992 $P_{3}$ 0.000000 -233.088992 233.088992 The function ema.analysis.ModalAnalysis wraps a scipy routine for solving the eigenvalue problem. freq2, Phi = em.analysis.ModalAnalysis(mdl, norm = 'last' ) Phi array([[ 5.00000000e-01, -1.00000000e+00, 5.00000000e-01], [ 8.66025404e-01, 2.28035323e-16, -8.66025404e-01], [ 1.00000000e+00, 1.00000000e+00, 1.00000000e+00]]) omega = np.array([np.sqrt(np.real(freq)) for freq in freq2]) omega array([17.36843442, 47.45144529, 64.81987972]) M = Phi.T @ m @ Phi K = Phi.T @ k @ Phi Modal expansion of earthquake forces \\[\\mathrm{p}_{\\mathrm{eff}}(t)=-\\mathrm{m} \\iota \\ddot{u}_{g}(t)\\] \\[\\mathbf{m} \\iota=\\sum_{n=1}^{N} \\mathbf{s}_{n}=\\sum_{n=1}^{N} \\Gamma_{n} \\mathbf{m} \\phi_{n}\\] I = N = 3 iota = np.ones(I) L = np.array([ sum (Phi.T[n,i] * sum (m[i,j] * iota[j] for j in range (I)) for i in range (I)) for n in range (N)]) L = Phi.T @ m @ iota L Structural_Vector([ 0.38634066, -0.10351967, 0.02773801]) gamma = np.array([L[n] / M[n,n] for n in range (N)]) gamma array([ 1.24401694, -0.33333333, 0.0893164 ]) s = np.array([gamma[n] * (m @ Phi.T[n]) for n in range (N)]).T s array([[ 1.28780221e-01, 6.90131125e-02, 9.24600388e-03], [ 2.23053886e-01, -1.57374274e-17, -1.60145485e-02], [ 1.28780221e-01, -3.45065562e-02, 9.24600388e-03]]) a) Determine \\(A_n\\) and \\(D_n\\) # Values read from response spectrum: D = np.array([ 0.877 , 0.10 , 0.04 ]) # inches D array([0.877, 0.1 , 0.04 ]) # if RHA: D = [] u = [] for i, w in enumerate (omega): zeta = 0.05 t, d = em.analysis.ElcentroRHA(zeta, w) D.append( max (d)) u.append([t,d]) print (D) [0.923352660303864, 0.09304519274915218, 0.03763691127115581] Plot modes: fig2, ax2 = plt.subplots() em.plot_structure(mdl, ax2) for i in range ( 3 ): plt.plot( 10 * u[i][ 0 ], 200 + 300 * u[i][ 1 ], linewidth = 0.5 ) plt.show() svg A = np.array([D[n] * omega[n] ** 2 for n in range (N)]) A array([278.54088513, 209.50424621, 158.13587895]) b) Modal response quantities Floor displacements Un = np.array([[gamma[n] * Phi[i,n] * D[n] for n in range (N)] for i in range (I)]) Un array([[ 5.74333174e-01, 3.10150642e-02, 1.68079666e-03], [ 9.94774237e-01, -7.07253019e-18, -2.91122522e-03], [ 1.14866635e+00, -3.10150642e-02, 3.36159333e-03]]) Story shears Vin = np.array([[ sum (s[j,n] * A[n] for j in range (i, I)) for n in range (N)] for i in range (I)]) Vin array([[133.87074037, 7.22927006, 0.3917752 ], [ 98.0001836 , -7.22927006, -1.07034975], [ 35.87055677, -7.22927006, 1.46212495]]) Floor and base moments M_base = np.array([ sum (s[i,n] * h * (i + 1 ) * A[n] for i in range (I)) for n in range (N)]) M_base # kip-inch array([38554.77322731, -1041.01488801, 112.8312575 ]) H = [h * (i + 1 ) for i in range (I)] H [144, 288, 432] M_floor = np.array([[ sum ((H[j] - h * (i + 1 )) * s[j,n] * A[n] for j in range (i,N)) for n in range (N)] for i in range (I)]) M_floor # kip-inch array([[19277.38661365, -2082.02977602, 56.41562875], [ 5165.36017531, -1041.01488801, 210.54599284], [ 0. , 0. , 0. ]]) c) Peak modal response combination For well-seperated modal frequencies, the SRSS method is employed. def ro(rno): return np.sqrt( sum (rn ** 2 for rn in rno)) Floor displacements text ro(Un.T) array([0.57517246, 0.9947785 , 1.14908991]) Story shears ro(Vin.T) array([134.06636775, 98.27229508, 36.62099122]) Floor and base overturning moments ro(M_base) 38568.98989471707 ro(M_floor) array([19957.41918167, 2327.78005518, 217.97325126])","title":"Time History Analysis - MDF Frame"},{"location":"gallery/elle-0020/","text":"Inelasticity in Frames The elle-002x series of studies are centered around a 2D reinforced concrete portal frame. Contents elle-0020 : Static Analysis of a Linear Frame This Jupyter notebook uses a beam element from the elle.beam2d library. elle-0020-oo This Jupyter notebook uses the default beam element applied by the emme.SkeletalModel generator. elle-0021 : Transient Analysis of a Geometrically Nonlinear Frame Model Components Structure The structure is depicted in fig. \u00bffig:frame? Girders T-girders with the following properties: Columns Square \\(30\\times 30\\) concrete columns fixed at the base.","title":"Inelasticity in Frames"},{"location":"gallery/elle-0020/elle-0020-oo/","text":"import anon #anon.conf.config.update('jax_disable_jit', True) import elle.sections import emme as em # column_section = em.aisc.load(\"w14x159\") # girder_section = em.aisc.load(\"w33x130\") column_section = { \"A\" : 576.0 , \"I\" : 27_648.0 } girder_section = { \"A\" : 684.0 , \"I\" : 34_383.8 } # Create a model Assembler model = em.SkeletalModel(ndm = 2 ,ndf = 3 ) # Set up nodes E = 3.6e3 ft = 12 B, H = 30. * ft, 13. * ft model.node( \"1\" , 0. , 0. ) model.node( \"2\" , 0. , H ) model.node( \"3\" , B / 2 , H ) model.node( \"4\" , B , H ) model.node( \"5\" , B , 0. ) model.beam( \"a\" , \"1\" , \"2\" , ** column_section,E = E) model.beam( \"b\" , \"2\" , \"3\" , ** girder_section,E = E) model.beam( \"c\" , \"3\" , \"4\" , ** girder_section,E = E) model.beam( \"d\" , \"4\" , \"5\" , ** column_section,E = E) model.boun( \"1\" , [ 1 , 1 , 1 ]) model.boun( \"5\" , [ 1 , 1 , 1 ]) model.load( \"2\" , 20.0 , dof = \"x\" ) em.plot_structure(model) ; f = model.compose() WARNING:absl:No GPU/TPU found, falling back to CPU. (Set TF_CPP_MIN_LOG_LEVEL=0 and rerun for more info.) U = f() U DeviceArray([[ 0.0551163 ], [ 0.00024871], [-0.00029532], [ 0.05439212], [-0.00049367], [ 0.00014284], [ 0.05366794], [-0.00024871], [-0.00028435]], dtype=float64) fig, ax = em.plot_displ(model, U, scale = 1e3 ) model.delems[ \"a\" ].ke_matrix() $u_10$ $u_11$ $u_12$ $u_1$ $u_2$ $u_3$ $u_10$ 314.61083 0.00000 -2.453964e+04 -314.61083 0.00000 -2.453964e+04 $u_11$ 0.00000 13292.30769 0.000000e+00 0.00000 -13292.30769 0.000000e+00 $u_12$ -24539.64497 0.00000 2.552123e+06 24539.64497 0.00000 1.276062e+06 $u_1$ -314.61083 0.00000 2.453964e+04 314.61083 0.00000 2.453964e+04 $u_2$ 0.00000 -13292.30769 0.000000e+00 0.00000 13292.30769 0.000000e+00 $u_3$ -24539.64497 0.00000 1.276062e+06 24539.64497 0.00000 2.552123e+06 em.K_matrix(model) $1$ $2$ $3$ $4$ $5$ $6$ $7$ $8$ $9$ $10$ $11$ $12$ $13$ $14$ $15$ $P_{1}$ 13994.61083 0.00000 2.453964e+04 -13680.0 0.00000 0.000000e+00 0.00000 0.00000 0.000000e+00 -314.61083 0.00000 2.453964e+04 0.00000 0.00000 0.000000e+00 $P_{2}$ 0.00000 13547.00251 2.292253e+04 0.0 -254.69481 2.292253e+04 0.00000 0.00000 0.000000e+00 0.00000 -13292.30769 0.000000e+00 0.00000 0.00000 0.000000e+00 $P_{3}$ 24539.64497 22922.53333 5.302827e+06 0.0 -22922.53333 1.375352e+06 0.00000 0.00000 0.000000e+00 -24539.64497 0.00000 1.276062e+06 0.00000 0.00000 0.000000e+00 $P_{4}$ -13680.00000 0.00000 0.000000e+00 27360.0 0.00000 0.000000e+00 -13680.00000 0.00000 0.000000e+00 0.00000 0.00000 0.000000e+00 0.00000 0.00000 0.000000e+00 $P_{5}$ 0.00000 -254.69481 -2.292253e+04 0.0 509.38963 0.000000e+00 0.00000 -254.69481 2.292253e+04 0.00000 0.00000 0.000000e+00 0.00000 0.00000 0.000000e+00 $P_{6}$ 0.00000 22922.53333 1.375352e+06 0.0 0.00000 5.501408e+06 0.00000 -22922.53333 1.375352e+06 0.00000 0.00000 0.000000e+00 0.00000 0.00000 0.000000e+00 $P_{7}$ 0.00000 0.00000 0.000000e+00 -13680.0 0.00000 0.000000e+00 13994.61083 0.00000 2.453964e+04 0.00000 0.00000 0.000000e+00 -314.61083 0.00000 2.453964e+04 $P_{8}$ 0.00000 0.00000 0.000000e+00 0.0 -254.69481 -2.292253e+04 0.00000 13547.00251 -2.292253e+04 0.00000 0.00000 0.000000e+00 0.00000 -13292.30769 0.000000e+00 $P_{9}$ 0.00000 0.00000 0.000000e+00 0.0 22922.53333 1.375352e+06 24539.64497 -22922.53333 5.302827e+06 0.00000 0.00000 0.000000e+00 -24539.64497 0.00000 1.276062e+06 $P_{10}$ -314.61083 0.00000 -2.453964e+04 0.0 0.00000 0.000000e+00 0.00000 0.00000 0.000000e+00 314.61083 0.00000 -2.453964e+04 0.00000 0.00000 0.000000e+00 $P_{11}$ 0.00000 -13292.30769 0.000000e+00 0.0 0.00000 0.000000e+00 0.00000 0.00000 0.000000e+00 0.00000 13292.30769 0.000000e+00 0.00000 0.00000 0.000000e+00 $P_{12}$ 24539.64497 0.00000 1.276062e+06 0.0 0.00000 0.000000e+00 0.00000 0.00000 0.000000e+00 -24539.64497 0.00000 2.552123e+06 0.00000 0.00000 0.000000e+00 $P_{13}$ 0.00000 0.00000 0.000000e+00 0.0 0.00000 0.000000e+00 -314.61083 0.00000 -2.453964e+04 0.00000 0.00000 0.000000e+00 314.61083 0.00000 -2.453964e+04 $P_{14}$ 0.00000 0.00000 0.000000e+00 0.0 0.00000 0.000000e+00 0.00000 -13292.30769 0.000000e+00 0.00000 0.00000 0.000000e+00 0.00000 13292.30769 0.000000e+00 $P_{15}$ 0.00000 0.00000 0.000000e+00 0.0 0.00000 0.000000e+00 24539.64497 0.00000 1.276062e+06 0.00000 0.00000 0.000000e+00 -24539.64497 0.00000 2.552123e+06","title":"Elle 0020 oo"},{"location":"gallery/elle-0020/elle-0020/","text":"0020 {#0020} import anon # anon.conf.config.update('jax_disable_jit', True) anon.conf.config.update( \"jax_enable_x64\" , True ) import anabel.backend as anp import anabel as em import elle.sections import elle.beam2d geom_template = elle.beam2d.transform_no2(elle.beam2d.geom_no1) beam_template = elle.beam2d.resp_no1 An Assembler is an object with an .assemble() and optionally a .compose() method # Create a model Assembler model = em.SkeletalModel(ndm = 2 ,ndf = 3 ) # Define problem parameters ColumnArea = model.param( \"ColumnArea\" ) GirderArea = model.param( \"GirderArea\" ) P1 = model.param( \"P1\" ) # Define model components column_section = { \"A\" : ColumnArea, \"E\" :, \"I\" : 30 ** 4 / 12 } girder_section = { \"A\" : GirderArea, \"E\" :, \"I\" : 34_383.8 } basic_girder = beam_template( ** girder_section, E = GirderE) basic_column = beam_template( ** column_section, E = ColumnE) girder = geom_template(basic_girder) column = geom_template(basic_column) WARNING:absl:No GPU/TPU found, falling back to CPU. (Set TF_CPP_MIN_LOG_LEVEL=0 and rerun for more info.) # Set up nodes ft = 12 B, H = 30. * ft, 13. * ft model.node( \"1\" , 0. , 0. ) model.node( \"2\" , 0. , H ) model.node( \"3\" , B / 2 , H ) model.node( \"4\" , B , H ) model.node( \"5\" , B , 0. ) model.beam( \"a\" , \"1\" , \"2\" , ** column_section, elem = column) model.beam( \"b\" , \"2\" , \"3\" , ** girder_section, elem = girder) model.beam( \"c\" , \"3\" , \"4\" , ** girder_section, elem = girder) model.beam( \"d\" , \"4\" , \"5\" , ** column_section, elem = column) model.boun( \"1\" , [ 1 , 1 , 1 ]) model.boun( \"5\" , [ 1 , 1 , 1 ]) model.load( \"2\" , P1, dof = \"x\" ) model.load( \"2\" , - 2.0 , dof = \"y\" ) model.load( \"4\" , - 2.0 , dof = \"y\" ) em.plot_skeletal(model) ; f = model.compose() U = f( 3600. , 3600. , 1e3 ) U DeviceArray([[ 1.52848857], [ 0.00583992], [-0.01110097], [ 1.49259297], [-0.02807216], [ 0.0053456 ], [ 1.45669737], [-0.00603251], [-0.01047929]], dtype=float64) for i,u in enumerate (anp.array([[ 1.52848857 ], [ 0.00583992 ], [ - 0.01110097 ], [ 1.49259297 ], [ - 0.02807216 ], [ 0.0053456 ], [ 1.45669737 ], [ - 0.00603251 ], [ - 0.01047929 ]])): assert abs (U[i] - u) < 1e-7 fig, ax = em.plot_displ(model, f( 3600 , 3600 , 2e3 ),scale = 1e1 ) fig.savefig( \"/home/claudio/prnt/ms-thesis/doc/img/frame.svg\" ) df = anon.diff.jacfwd(f, None , ( 0 , 1 ),squeeze = False ) df( 29e6 , 29e6 , 20e3 ) (DeviceArray([[-8.69522599e-11], [-7.26154452e-13], [ 3.97452570e-13], [-8.69086396e-11], [-2.03656535e-13], [-1.93805278e-13], [-8.68650194e-11], [ 7.26978867e-13], [ 4.01987431e-13]], dtype=float64), DeviceArray([[-4.39052633e-11], [ 2.18353505e-13], [ 5.52927845e-13], [-4.08757761e-11], [ 2.59914899e-12], [-2.63843818e-13], [-3.78462889e-11], [-2.18353505e-13], [ 4.95168978e-13]], dtype=float64))","title":"`0020` {#0020}"},{"location":"gallery/elle-0020/elle-0021-steel/","text":"import anon anon.conf.config.update( 'jax_disable_jit' , True ) anon.conf.config.update( \"jax_enable_x64\" , True ) import anon.atom as anp import elle.sections import elle.beam2d import anabel as em geom_template = elle.beam2d.transform_no2(elle.beam2d.geom_no2) beam_template = elle.beam2d.resp_no1 An Assembler is an object with an .assemble() and optionally a .compose() method # Create a model Assembler model = em.SkeletalModel(ndm = 2 ,ndf = 3 ) # Define problem parameters ColumnE = model.param( \"ColumnE\" ) GirderE = model.param( \"GirderE\" ) P1 = model.param( \"P1\" ) # Define model components girder_section = em.aisc.load( \"w33x130\" ) column_section = em.aisc.load( \"w14x159\" ) basic_girder = beam_template( ** girder_section, E = GirderE) basic_column = beam_template( ** column_section, E = ColumnE) girder = geom_template(basic_girder) column = geom_template(basic_column) WARNING:absl:No GPU/TPU found, falling back to CPU. (Set TF_CPP_MIN_LOG_LEVEL=0 and rerun for more info.) # Set up nodes ft = 12 B, H = 30. * ft, 13. * ft model.node( \"1\" , 0. , 0. ) model.node( \"2\" , 0. , H ) model.node( \"3\" , B / 2 , H ) model.node( \"4\" , B , H ) model.node( \"5\" , B , 0. ) model.beam( \"a\" , \"1\" , \"2\" , ** column_section, elem = column) model.beam( \"b\" , \"2\" , \"3\" , ** girder_section, elem = girder) model.beam( \"c\" , \"3\" , \"4\" , ** girder_section, elem = girder) model.beam( \"d\" , \"4\" , \"5\" , ** column_section, elem = column) model.boun( \"1\" , [ 1 , 1 , 1 ]) model.boun( \"5\" , [ 1 , 1 , 1 ]) model.load( \"2\" , P1, dof = \"x\" ) model.load( \"2\" , - 2e3 , dof = \"y\" ) model.load( \"4\" , - 2e3 , dof = \"y\" ) em.plot_skeletal(model) ; f = model.compose() f( 3600. , 3600. , 2e3 ) /home/claudio/elle/numeric/elle/numeric/inverse.py:111: UserWarning: Function inversion failed to converge. warnings.warn(\"Function inversion failed to converge.\") DeviceArray([[ 0.28355172], [ 171.74283748], [ 0.84689206], [-202.66515683], [-149.92389898], [ 5.04060219], [ -14.82161937], [-148.43045677], [ 5.1556104 ]], dtype=float64) fig, ax = em.plot_displ(model, f( 29e6 , 29e6 , 20e3 ),scale = 1e3 ) /home/claudio/elle/numeric/elle/numeric/inverse.py:111: UserWarning: Function inversion failed to converge. warnings.warn(\"Function inversion failed to converge.\") df = anon.diff.jacfwd(f, None , ( 0 , 1 ),squeeze = False ) df( 29e6 , 29e6 , 20e3 ) dx: Traced<ConcreteArray([[20000.] [-2000.] [ 0.] [ 0.] [ 0.] [ 0.] [ 0.] [-2000.] [ 0.]])>with<JVPTrace(level=2/0)> with primal = DeviceArray([[20000.], [-2000.], [ 0.], [ 0.], [ 0.], [ 0.], [ 0.], [-2000.], [ 0.]], dtype=float64) tangent = Traced<ShapedArray(float64[9,1])>with<BatchTrace(level=1/0)> with val = DeviceArray([[[-0.], [-0.]], [[-0.], [-0.]], [[-0.], [-0.]], [[-0.], [-0.]], [[-0.], [-0.]], [[-0.], [-0.]], [[-0.], [-0.]], [[-0.], [-0.]], [[-0.], [-0.]]], dtype=float64) batch_dim = 1 /home/claudio/elle/numeric/elle/numeric/inverse.py:112: UserWarning: Function inversion failed to converge. warnings.warn(\"Function inversion failed to converge.\") (DeviceArray([[-2.04476205e-09], [-1.10382234e-11], [ 7.00882848e-13], [-2.04415680e-09], [-5.35148746e-12], [-2.71208496e-13], [-2.04355123e-09], [ 2.30895445e-11], [ 9.53551267e-13]], dtype=float64), DeviceArray([[-5.79214813e-10], [ 9.60734398e-13], [ 7.15495715e-12], [-5.24811184e-10], [ 3.78153916e-11], [-3.37652007e-12], [-4.70407107e-10], [-1.95779547e-12], [ 6.30254346e-12]], dtype=float64))","title":"Elle 0021 steel"},{"location":"gallery/elle-0020/elle-0021/","text":"0020 {#0020} import anon # anon.conf.config.update('jax_disable_jit', True) anon.conf.config.update( \"jax_enable_x64\" , True ) import anabel.backend as anp import anabel as em import elle.sections import elle.beam2d geom_template = elle.beam2d.transform_no2(elle.beam2d.geom_no1) beam_template = elle.beam2d.resp_no1 An Assembler is an object with an .assemble() and optionally a .compose() method # Create a model Assembler model = em.SkeletalModel(ndm = 2 ,ndf = 3 ) # Define problem parameters ColumnArea = model.param( \"ColumnArea\" ) GirderArea = model.param( \"GirderArea\" ) P1 = model.param( \"P1\" ) # Define model components column_section = { \"A\" : ColumnArea, \"E\" :, \"I\" : 30 ** 4 / 12 } girder_section = { \"A\" : GirderArea, \"E\" :, \"I\" : 34_383.8 } basic_girder = beam_template( ** girder_section, E = GirderE) basic_column = beam_template( ** column_section, E = ColumnE) girder = geom_template(basic_girder) column = geom_template(basic_column) WARNING:absl:No GPU/TPU found, falling back to CPU. (Set TF_CPP_MIN_LOG_LEVEL=0 and rerun for more info.) # Set up nodes ft = 12 B, H = 30. * ft, 13. * ft model.node( \"1\" , 0. , 0. ) model.node( \"2\" , 0. , H ) model.node( \"3\" , B / 2 , H ) model.node( \"4\" , B , H ) model.node( \"5\" , B , 0. ) model.beam( \"a\" , \"1\" , \"2\" , ** column_section, elem = column) model.beam( \"b\" , \"2\" , \"3\" , ** girder_section, elem = girder) model.beam( \"c\" , \"3\" , \"4\" , ** girder_section, elem = girder) model.beam( \"d\" , \"4\" , \"5\" , ** column_section, elem = column) model.boun( \"1\" , [ 1 , 1 , 1 ]) model.boun( \"5\" , [ 1 , 1 , 1 ]) model.load( \"2\" , P1, dof = \"x\" ) model.load( \"2\" , - 2.0 , dof = \"y\" ) model.load( \"4\" , - 2.0 , dof = \"y\" ) em.plot_skeletal(model) ; f = model.compose() U = f( 3600. , 3600. , 1e3 ) U DeviceArray([[ 1.52848857], [ 0.00583992], [-0.01110097], [ 1.49259297], [-0.02807216], [ 0.0053456 ], [ 1.45669737], [-0.00603251], [-0.01047929]], dtype=float64) for i,u in enumerate (anp.array([[ 1.52848857 ], [ 0.00583992 ], [ - 0.01110097 ], [ 1.49259297 ], [ - 0.02807216 ], [ 0.0053456 ], [ 1.45669737 ], [ - 0.00603251 ], [ - 0.01047929 ]])): assert abs (U[i] - u) < 1e-7 fig, ax = em.plot_displ(model, f( 3600 , 3600 , 2e3 ),scale = 1e1 ) fig.savefig( \"/home/claudio/prnt/ms-thesis/doc/img/frame.svg\" ) df = anon.diff.jacfwd(f, None , ( 0 , 1 ),squeeze = False ) df( 29e6 , 29e6 , 20e3 ) (DeviceArray([[-8.69522599e-11], [-7.26154452e-13], [ 3.97452570e-13], [-8.69086396e-11], [-2.03656535e-13], [-1.93805278e-13], [-8.68650194e-11], [ 7.26978867e-13], [ 4.01987431e-13]], dtype=float64), DeviceArray([[-4.39052633e-11], [ 2.18353505e-13], [ 5.52927845e-13], [-4.08757761e-11], [ 2.59914899e-12], [-2.63843818e-13], [-3.78462889e-11], [-2.18353505e-13], [ 4.95168978e-13]], dtype=float64))","title":"`0020` {#0020}"},{"location":"gallery/elle-0020/elle-0022-Copy1/","text":"import anon.conf anon.conf.config.update( 'jax_disable_jit' , True ) import anon import jax import anon.atom as anp import elle.sections import elle.beam2d import elle.springs import emme as em mat = elle.springs.isokin.no1( 60.0 , 29e3 ) # mat = elle.springs.gmp.no5(60.0,29e3) sec = elle.sections.core_v2.Rectangle geom_template = elle.beam2d.transform_no2(elle.beam2d.geom_no1) beam_template = elle.beam2d.resp_no6 An Assembler is an object with an .assemble() and optionally a .compose() method # Create a model Assembler model = em.SkeletalModel(ndm = 2 ,ndf = 3 ) # Define problem parameters P1 = model.param( \"P1\" ) # Define model components girder_section = sec(d = 60.0 , b = 18.0 ,mat = mat).assemble() column_section = sec(d = 60.0 , b = 18.0 ,mat = mat).assemble() basic_girder = beam_template( * [girder_section] * 8 , quad = { \"n\" : 8 , \"rule\" : \"mid\" }) basic_column = beam_template( * [column_section] * 8 , quad = { \"n\" : 8 , \"rule\" : \"mid\" }) girder = geom_template(basic_girder) column = geom_template(basic_column) # Set up nodes ft = 12 B, H = 30. * ft, 13. * ft model.node( \"1\" , 0. , 0. ) model.node( \"2\" , 0. , H ) model.node( \"3\" , B / 2 , H ) model.node( \"4\" , B , H ) model.node( \"5\" , B , 0. ) model.beam( \"a\" , \"1\" , \"2\" , elem = column) model.beam( \"b\" , \"2\" , \"3\" , elem = girder) model.beam( \"c\" , \"3\" , \"4\" , elem = girder) model.beam( \"d\" , \"4\" , \"5\" , elem = column) model.boun( \"1\" , [ 1 , 1 , 1 ]) model.boun( \"5\" , [ 1 , 1 , 1 ]) model.load( \"2\" , P1, dof = \"x\" ) model.load( \"2\" , - 1.0 , dof = \"y\" ) model.load( \"2\" , - 1.0 , dof = \"y\" ) em.plot_structure(model) ; f = model.compose() f( 1.0 ) [[ 1.63539291e-02] [-2.02570246e-03] [-9.55256367e-05] [ 1.50486513e-02] [-2.12649699e-03] [ 4.89535361e-05] [ 1.37433735e-02] [-3.81704943e-04] [-7.50191192e-05]] DeviceArray([[ 1.63539291e-02], [-2.02570246e-03], [-9.55256367e-05], [ 1.50486513e-02], [-2.12649699e-03], [ 4.89535361e-05], [ 1.37433735e-02], [-3.81704943e-04], [-7.50191192e-05]], dtype=float64) for i in range ( 3 ): fig, ax = em.plot_displ(model, f( 30. * i),scale = 1e1 ) [[-3.73841687e-04] [-2.39954415e-03] [ 4.79284214e-06] [-3.73841687e-04] [-1.20370370e-03] [ 7.55794337e-06] [-3.73841687e-04] [-7.86325663e-06] [ 4.79284214e-06]] [[ 0.50145928] [ 0.00881571] [-0.00300476] [ 0.46230095] [-0.0288875 ] [ 0.00124943] [ 0.42314261] [-0.01122311] [-0.00238957]] [[ 1.00329241] [ 0.02003096] [-0.00601432] [ 0.92497574] [-0.0565713 ] [ 0.00249129] [ 0.84665907] [-0.02243836] [-0.00478392]] df = anon.diff.jacfwd(f, None , ( 0 , 1 ), squeeze = False ) df( 20.0 ) --------------------------------------------------------------------------- IndexError Traceback (most recent call last) <ipython-input-21-61fb48dc13d3> in <module> ----> 1 df(20.0) ~/pkgs/anon/src/anon/diff.py in jacobian(*args, **kwds) 54 def jacobian(*args,**kwds): 55 f = lu.wrap_init(f_transformed, kwds) ---> 56 f_partial, dyn_args = argnums_partial(f, argnums, args) 57 jax.api.tree_map(partial(jax.api._check_input_dtype_jacfwd, holomorphic), dyn_args) 58 pushfwd = partial(jax.api._jvp, f_partial, dyn_args) ~/extn/jax/jax/api_util.py in argnums_partial(f, dyn_argnums, args) 103 fixed_args = tuple(unit if i in dyn_argnums else wrap_hashably(arg) 104 for i, arg in enumerate(args)) --> 105 dyn_args = tuple(args[i] for i in dyn_argnums) 106 return _argnums_partial(f, dyn_argnums, fixed_args), dyn_args 107 ~/extn/jax/jax/api_util.py in <genexpr>(.0) 103 fixed_args = tuple(unit if i in dyn_argnums else wrap_hashably(arg) 104 for i, arg in enumerate(args)) --> 105 dyn_args = tuple(args[i] for i in dyn_argnums) 106 return _argnums_partial(f, dyn_argnums, fixed_args), dyn_args 107 IndexError: tuple index out of range m","title":"elle 0022 Copy1"},{"location":"gallery/elle-0020/elle-0022/","text":"Transient Analysis of a Geometrically Nonlinear Frame import anon.conf anon.conf.config.update( 'jax_disable_jit' , True ) anon.conf.config.update( 'jax_enable_x64' , True ) import anabel import anon import jax import anon.atom as anp import elle.sections import elle.beam2d import elle.springs import anabel as em mat = elle.springs.isokin.no1( 3600.0 , 4.0 ,H0 = 36.0 ) # mat = elle.springs.gmp.no5(60.0,29e3) GirderSec = anabel.sections.Tee ColumnSec = anabel.sections.Rectangle geom_template = elle.beam2d.transform_no2(elle.beam2d.geom_no2) beam_template = elle.beam2d.resp_no6 An Assembler is an object with an .assemble() and optionally a .compose() method. # Create a model Assembler model = em.SkeletalModel(ndm = 2 ,ndf = 3 ) # Define problem parameters P1 = model.param( \"P1\" ) # Define model components girder_section = GirderSec(d = 24.0 , bf = 60.0 , tf = 6.0 , tw = 18.0 , mat = mat).assemble() column_section = ColumnSec(d = 30.0 , b = 30.0 ,mat = mat).assemble() basic_girder = beam_template( * [girder_section] * 4 , quad = { \"n\" : 4 , \"rule\" : \"lobatto\" }) # basic_column = beam_template(*[column_section]*8, quad={\"n\": 4, \"rule\": \"mid\"}) basic_column = elle.beam2d.resp_no1(A = 30.0 ** 2 ,E = 3600.0 ,I = 30 ** 4 / 12 ) girder = geom_template(basic_girder) column = geom_template(basic_column) WARNING:absl:No GPU/TPU found, falling back to CPU. (Set TF_CPP_MIN_LOG_LEVEL=0 and rerun for more info.) # Set up nodes ft = 12. B, H = 30. * ft, 13. * ft model.node( \"1\" , 0. , 0. ) model.node( \"2\" , 0. , H ) model.node( \"3\" , B / 2 , H ) model.node( \"4\" , B , H ) model.node( \"5\" , B , 0. ) model.beam( \"a\" , \"1\" , \"2\" , elem = column) model.beam( \"b\" , \"2\" , \"3\" , elem = girder) model.beam( \"c\" , \"3\" , \"4\" , elem = girder) model.beam( \"d\" , \"4\" , \"5\" , elem = column) model.boun( \"1\" , [ 1 , 1 , 1 ]) model.boun( \"5\" , [ 1 , 1 , 1 ]) model.load( \"2\" , P1, dof = \"x\" ) model.load( \"2\" , - 2.0 , dof = \"y\" ) model.load( \"2\" , - 2.0 , dof = \"y\" ) em.plot_skeletal(model) ; model.dofs [[9, 10, 11], [0, 1, 2], [3, 4, 5], [6, 7, 8], [12, 13, 14]] f = model.compose() f( 1000 ) /home/claudio/elle/numeric/elle/numeric/inverse.py:109: UserWarning: Function inversion failed to converge. warnings.warn(\"Function inversion failed to converge.\") DeviceArray([[ 1.70610291], [ 0.02331842], [-0.01326677], [ 1.67563829], [-0.0466029 ], [ 0.00541659], [ 1.61815267], [ 0.01151919], [-0.01267151]], dtype=float64) # for i in range(3):embler objects. An assembler is typically characterized by collections of nodes, elements and parameters. The purpose of the assembler is to provide a convenient interface for interacting with and managing these entities. # fig, ax = em.plot_displ(model, f(10.*i),scale=1e2) model.cycle( 0 , 0 , 1000 , 5 , 5 , 1 ) model.build_load_path( 0 ) DeviceArray([[ 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ], [ 0. , 266.66666667, 533.33333333, 800. , 1000. , 733.33333333, 466.66666667, 200. , -0. , -266.66666667, -533.33333333, -800. , -1000. , -733.33333333, -466.66666667, -200. , 0. , 266.66666667, 533.33333333, 800. ], [ 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ], [ 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ], [ 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ], [ 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ], [ 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ], [ 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ], [ 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ], [ 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ], [ 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ], [ 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ], [ 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ], [ 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ], [ 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ]], dtype=float64) df = anon.diff.jacfwd(f, None , ( 0 , 1 ), squeeze = False )","title":"Transient Analysis of a Geometrically Nonlinear Frame"},{"location":"gallery/elle-0020/elle-0023/","text":"0023 {#0023} import anon # anon.conf.config.update('jax_disable_jit', True) anon.conf.config.update( \"jax_enable_x64\" , True ) import anabel.backend as anp import anabel as em from jax.test_util import check_grads import elle.sections import elle.beam2d geom_template = elle.beam2d.transform_no2(elle.beam2d.geom_no1) beam_template = elle.beam2d.resp_no1 An Assembler is an object with an .assemble() and optionally a .compose() method # Create a model Assembler model = em.SkeletalModel(ndm = 2 ,ndf = 3 ) # Define problem parameters ColumnArea = model.param( \"ColumnArea\" ) ColumnMOI = model.param( \"ColumnMOI\" ) GirderArea = model.param( \"GirderArea\" ) GirderMOI = model.param( \"GirderMOI\" ) P1 = model.param( \"P1\" ) # Define model components column_section = { \"A\" : ColumnArea, \"E\" : 3600.0 , \"I\" : ColumnMOI} girder_section = { \"A\" : GirderArea, \"E\" : 3600.0 , \"I\" : GirderMOI} basic_girder = beam_template( ** girder_section) basic_column = beam_template( ** column_section) girder = geom_template(basic_girder) column = geom_template(basic_column) WARNING:absl:No GPU/TPU found, falling back to CPU. (Set TF_CPP_MIN_LOG_LEVEL=0 and rerun for more info.) # Set up nodes ft = 12 B, H = 30. * ft, 13. * ft model.node( \"1\" , 0. , 0. ) model.node( \"2\" , 0. , H ) model.node( \"3\" , B / 2 , H ) model.node( \"4\" , B , H ) model.node( \"5\" , B , 0. ) model.beam( \"a\" , \"1\" , \"2\" , ** column_section, elem = column) model.beam( \"b\" , \"2\" , \"3\" , ** girder_section, elem = girder) model.beam( \"c\" , \"3\" , \"4\" , ** girder_section, elem = girder) model.beam( \"d\" , \"4\" , \"5\" , ** column_section, elem = column) model.boun( \"1\" , [ 1 , 1 , 1 ]) model.boun( \"5\" , [ 1 , 1 , 1 ]) model.load( \"2\" , P1, dof = \"x\" ) model.load( \"2\" , - 2.0 , dof = \"y\" ) model.load( \"4\" , - 2.0 , dof = \"y\" ) em.plot_skeletal(model) ; f = model.compose() U = f( 30 ** 2. , 684.0 , 1e3 ) U DeviceArray([[ 1.52848857], [ 0.00583992], [-0.01110097], [ 1.49259297], [-0.02807216], [ 0.0053456 ], [ 1.45669737], [-0.00603251], [-0.01047929]], dtype=float64) for i,u in enumerate (anp.array([[ 1.52848857 ], [ 0.00583992 ], [ - 0.01110097 ], [ 1.49259297 ], [ - 0.02807216 ], [ 0.0053456 ], [ 1.45669737 ], [ - 0.00603251 ], [ - 0.01047929 ]])): assert abs (U[i] - u) < 1e-7 fig, ax = em.plot_displ(model, f( 30 ** 2. , 684.0 , 1e3 ),scale = 2e1 ) ax.axis( \"off\" ) fig.savefig( \"/home/claudio/prnt/ms-thesis/doc/img/frame.svg\" ) df = anon.diff.jacfwd(f, None , ( 0 , 1 ), squeeze = False ) df( 30 ** 2. , 684.0 , 1e3 ) (DeviceArray([[-1.62639751e-06], [-6.48010720e-06], [ 2.08512502e-08], [-1.62639751e-06], [ 1.06995885e-07], [ 4.44669006e-08], [-1.62639751e-06], [ 6.69409896e-06], [ 2.08512502e-08]], dtype=float64), DeviceArray([[-5.15397694e-05], [-1.28712372e-20], [ 4.46315830e-07], [-3.53933002e-18], [ 4.01684247e-05], [-1.34782635e-20], [ 5.15397694e-05], [ 1.48398390e-20], [-4.46315830e-07]], dtype=float64)) check_grads(f, ( 30 ** 2. , 684.0 , 1e3 ), order = 1 ) WARNING:absl:No GPU/TPU found, falling back to CPU. (Set TF_CPP_MIN_LOG_LEVEL=0 and rerun for more info.)","title":"`0023` {#0023}"},{"location":"gallery/elle-0020/elle-0025/","text":"import elle.numeric import matplotlib.pyplot as plt plt.style.use( \"typewriter\" ) import anon.conf anon.conf.config.update( 'jax_disable_jit' , True ) anon.conf.config.update( 'jax_enable_x64' , True ) import anabel import anon import jax import anon.atom as anp import elle.sections import elle.beam2d import elle.springs import anabel as em mat = elle.springs.isokin.no1( 3600.0 , 4.0 ,H0 = 3.0 ) # mat = elle.springs.gmp.no5(60.0,29e3) GirderSec = anabel.sections.Tee ColumnSec = anabel.sections.Rectangle geom_template = elle.beam2d.transform_no2(elle.beam2d.geom_no2) beam_template = elle.beam2d.resp_no6 An Assembler is an object with an .assemble() and optionally a .compose() method # Create a model Assembler model = em.SkeletalModel(ndm = 2 ,ndf = 3 ) # Define problem parameters P1 = model.param( \"P1\" ) # Define model components girder_section = GirderSec(d = 24.0 , bf = 60.0 , tf = 6.0 , tw = 18.0 , mat = mat).assemble() column_section = ColumnSec(d = 30.0 , b = 30.0 ,mat = mat).assemble() basic_girder = beam_template( * [girder_section] * 4 , quad = { \"n\" : 4 , \"rule\" : \"lobatto\" }) # basic_column = beam_template(*[column_section]*8, quad={\"n\": 4, \"rule\": \"mid\"}) basic_column = elle.beam2d.resp_no1(A = 30.0 ** 2 ,E = 3600.0 ,I = 30 ** 4 / 12 ) girder = geom_template(basic_girder) column = geom_template(basic_column) WARNING:absl:No GPU/TPU found, falling back to CPU. (Set TF_CPP_MIN_LOG_LEVEL=0 and rerun for more info.) # Set up nodes ft = 12. B, H = 30. * ft, 13. * ft model.node( \"1\" , 0. , 0. ) model.node( \"2\" , 0. , H ) model.node( \"3\" , B / 2 , H ) model.node( \"4\" , B , H ) model.node( \"5\" , B , 0. ) model.beam( \"a\" , \"1\" , \"2\" , elem = column) model.beam( \"b\" , \"2\" , \"3\" , elem = girder) model.beam( \"c\" , \"3\" , \"4\" , elem = girder) model.beam( \"d\" , \"4\" , \"5\" , elem = column) model.boun( \"1\" , [ 1 , 1 , 1 ]) model.boun( \"5\" , [ 1 , 1 , 1 ]) model.load( \"2\" , P1, dof = \"x\" ) model.load( \"2\" , - 2.0 , dof = \"y\" ) model.load( \"2\" , - 2.0 , dof = \"y\" ) em.plot_skeletal(model) ; model.dofs [[9, 10, 11], [0, 1, 2], [3, 4, 5], [6, 7, 8], [12, 13, 14]] f = model.compose_displ() model.cycle( 0 , 0 , 3000 , 10 , 2 , 0 ) P = model.build_load_path( 0 ) F = elle.numeric.accumulate(f) X, Y, S = F(P) 0/18 1/18 2/18 /home/claudio/elle/numeric/elle/numeric/inverse.py:149: UserWarning: Function inversion failed to converge. warnings.warn(\"Function inversion failed to converge.\") 3/18 /home/claudio/elle/numeric/elle/numeric/inverse.py:149: UserWarning: Function inversion failed to converge. warnings.warn(\"Function inversion failed to converge.\") 4/18 /home/claudio/elle/numeric/elle/numeric/inverse.py:149: UserWarning: Function inversion failed to converge. warnings.warn(\"Function inversion failed to converge.\") 5/18 /home/claudio/elle/numeric/elle/numeric/inverse.py:149: UserWarning: Function inversion failed to converge. warnings.warn(\"Function inversion failed to converge.\") 6/18 /home/claudio/elle/numeric/elle/numeric/inverse.py:149: UserWarning: Function inversion failed to converge. warnings.warn(\"Function inversion failed to converge.\") 7/18 /home/claudio/elle/numeric/elle/numeric/inverse.py:149: UserWarning: Function inversion failed to converge. warnings.warn(\"Function inversion failed to converge.\") 8/18 /home/claudio/elle/numeric/elle/numeric/inverse.py:149: UserWarning: Function inversion failed to converge. warnings.warn(\"Function inversion failed to converge.\") 9/18 /home/claudio/elle/numeric/elle/numeric/inverse.py:149: UserWarning: Function inversion failed to converge. warnings.warn(\"Function inversion failed to converge.\") 10/18 /home/claudio/elle/numeric/elle/numeric/inverse.py:149: UserWarning: Function inversion failed to converge. warnings.warn(\"Function inversion failed to converge.\") 11/18 /home/claudio/elle/numeric/elle/numeric/inverse.py:149: UserWarning: Function inversion failed to converge. warnings.warn(\"Function inversion failed to converge.\") 12/18 /home/claudio/elle/numeric/elle/numeric/inverse.py:149: UserWarning: Function inversion failed to converge. warnings.warn(\"Function inversion failed to converge.\") 13/18 /home/claudio/elle/numeric/elle/numeric/inverse.py:149: UserWarning: Function inversion failed to converge. warnings.warn(\"Function inversion failed to converge.\") 14/18 /home/claudio/elle/numeric/elle/numeric/inverse.py:149: UserWarning: Function inversion failed to converge. warnings.warn(\"Function inversion failed to converge.\") 15/18 /home/claudio/elle/numeric/elle/numeric/inverse.py:149: UserWarning: Function inversion failed to converge. warnings.warn(\"Function inversion failed to converge.\") 16/18 /home/claudio/elle/numeric/elle/numeric/inverse.py:149: UserWarning: Function inversion failed to converge. warnings.warn(\"Function inversion failed to converge.\") 17/18 /home/claudio/elle/numeric/elle/numeric/inverse.py:149: UserWarning: Function inversion failed to converge. warnings.warn(\"Function inversion failed to converge.\") plt.plot(Y[:, 0 ,:],P[:, 0 ,:]) [<matplotlib.lines.Line2D at 0x7f988409aac0>] model.dofs [[9, 10, 11], [0, 1, 2], [3, 4, 5], [6, 7, 8], [12, 13, 14]]","title":"Elle 0025"},{"location":"gallery/elle-0020/opsy-0020/","text":"import openseespy.opensees as ops import openseespy.postprocessing.ops_vis as opsv import matplotlib.pyplot as plt # import opensees as ops # local compilation # import ops_vis as opsv # local ft = 12. B,H = 30 * ft, 13. * ft ops.wipe() ops.model( 'basic' , '-ndm' , 2 , '-ndf' , 3 ) Acol, Agir = 576.0 , 684.0 IzCol, IzGir = 27_648.0 , 34_383.8 E = 3600. Ep = { 1 : [E, Acol, IzCol], 2 : [E, Acol, IzCol], 3 : [E, Agir, IzGir]} ops.node( 1 , 0. , 0. ) ops.node( 2 , 0. , H) ops.node( 3 , B, 0. ) ops.node( 4 , B, H) ops.fix( 1 , 1 , 1 , 1 ) ops.fix( 3 , 1 , 1 , 1 ) ops.geomTransf( 'Linear' , 1 ) # columns ops.element( 'elasticBeamColumn' , 1 , 1 , 2 , Acol, E, IzCol, 1 ) ops.element( 'elasticBeamColumn' , 2 , 3 , 4 , Acol, E, IzCol, 1 ) # girder ops.element( 'elasticBeamColumn' , 3 , 2 , 4 , Agir, E, IzGir, 1 ) Px = 2.e+3 Wy = - 10.e+3 Wx = 0. Ew = { 3 : [ '-beamUniform' , Wy, Wx]} ops.timeSeries( 'Constant' , 1 ) ops.pattern( 'Plain' , 1 , 1 ) ops.load( 2 , Px, 0. , 0. ) # for etag in Ew: # ops.eleLoad('-ele', etag, '-type', Ew[etag][0], Ew[etag][1], # Ew[etag][2]) ops.constraints( 'Transformation' ) ops.numberer( 'RCM' ) ops.system( 'BandGeneral' ) ops.test( 'NormDispIncr' , 1.0e-6 , 6 , 2 ) ops.algorithm( 'Linear' ) ops.integrator( 'LoadControl' , 1 ) ops.analysis( 'Static' ) ops.analyze( 1 ) ops.printModel() Current Domain Information Current Time: 1 tCommitted Time: 1 NODE DATA: NumNodes: 4 numComponents: 4 Node: 1 Coordinates : 0 0 Disps: 0 0 0 unbalanced Load: 0 0 0 ID : -1 -1 -1 Node: 2 Coordinates : 0 156 Disps: 5.51163 0.0248715 -0.0295316 unbalanced Load: 2000 0 0 ID : 3 4 5 Node: 3 Coordinates : 360 0 Disps: 0 0 0 unbalanced Load: 0 0 0 ID : -1 -1 -1 Node: 4 Coordinates : 360 156 Disps: 5.36679 -0.0248715 -0.0284346 unbalanced Load: 0 0 0 ID : 0 1 2 ELEMENT DATA: NumEle: 3 numComponents: 3 ElasticBeam2d: 1 Connected Nodes: 1 2 CoordTransf: 1 mass density: 0, cMass: 0 release code: 0 End 1 Forces (P V M): -330.599 1009.32 97569.3 End 2 Forces (P V M): 330.599 -1009.32 59885.1 ElasticBeam2d: 2 Connected Nodes: 3 4 CoordTransf: 1 mass density: 0, cMass: 0 release code: 0 End 1 Forces (P V M): 330.599 990.677 95415 End 2 Forces (P V M): -330.599 -990.677 59130.7 ElasticBeam2d: 3 Connected Nodes: 2 4 CoordTransf: 1 mass density: 0, cMass: 0 release code: 0 End 1 Forces (P V M): 990.677 -330.599 -59885.1 End 2 Forces (P V M): -990.677 330.599 -59130.7 SP_Constraints: numConstraints: 6 numComponents: 6SP_Constraint: 0 Node: 1 DOF: 1 ref value: 0 current value: 0 SP_Constraint: 1 Node: 1 DOF: 2 ref value: 0 current value: 0 SP_Constraint: 2 Node: 1 DOF: 3 ref value: 0 current value: 0 SP_Constraint: 3 Node: 3 DOF: 1 ref value: 0 current value: 0 SP_Constraint: 4 Node: 3 DOF: 2 ref value: 0 current value: 0 SP_Constraint: 5 Node: 3 DOF: 3 ref value: 0 current value: 0 Pressure_Constraints: numConstraints: 0 numComponents: 0 MP_Constraints: numConstraints: 0 numComponents: 0 LOAD PATTERNS: numPatterns: 1 numComponents: 1Load Pattern: 1 Scale Factor: 1 Constant Series: factor: 1 Nodal Loads: numComponents: 1Nodal Load: 2 load : 2000 0 0 Elemental Loads: numComponents: 0 Single Point Constraints: numComponents: 0 PARAMETERS: numParameters: 0 numComponents: 0 # 1. plot model with tag lebels szer, wys = 16. , 10. fig = plt.figure(figsize = (szer / 2.54 , wys / 2.54 )) fig.subplots_adjust(left = .08 , bottom = .08 , right = .985 , top = .94 ) ax1 = plt.subplot( 111 ) opsv.plot_model() # 2. plot deformed model sfac = 80. plt.figure() # plot_defo with optional arguments # sfac = opsv.plot_defo() opsv.plot_defo(sfac, fmt_interp = 'b.-' ) opsv.plot_defo(sfac, 5 , interpFlag = 0 , fmt_nodes = 'bo-' ) opsv.plot_defo(sfac, 3 , endDispFlag = 0 , fmt_interp = 'r.--' ) opsv.plot_defo(sfac, 2 , fmt_interp = 'g.-' ) 80.0 # print(f'sfac: {sfac}') # return sfac if automatically calculated # 3. plot N, V, M forces diagrams sfacN, sfacV, sfacM = 5.e-5 , 5.e-5 , 5.e-5 plt.figure() minVal, maxVal = opsv.section_force_diagram_2d( 'N' , Ew, sfacN) plt.title( f'Axial forces, max = { maxVal :.2f} , min = { minVal :.2f} ' ) plt.figure() minVal, maxVal = opsv.section_force_diagram_2d( 'T' , Ew, sfacV) plt.title( f'Shear forces, max = { maxVal :.2f} , min = { minVal :.2f} ' ) plt.figure() minVal, maxVal = opsv.section_force_diagram_2d( 'M' , Ew, sfacM) plt.title( f'Bending moments, max = { maxVal :.2f} , min = { minVal :.2f} ' ) plt.show()","title":"Opsy 0020"},{"location":"gallery/elle-0020/opsy-0022/","text":"0020 OpenSeesPy {#0020-openseespy} This notebook is adapted from the OpenSeesPy example at this link . from openseespy.opensees import * import openseespy.opensees as ops import openseespy.postprocessing.ops_vis as opsv import matplotlib.pyplot as plt # Create ModelBuilder (with two-dimensions and 3 DOF/node) ops.wipe() ops.model( 'basic' , '-ndm' , 2 , '-ndf' , 3 ) # Create nodes # ------------ # Set parameters for overall model geometry width = 360.0 height = 144.0 # Create nodes # tag, X, Y ops.node( 1 , 0.0 , 0.0 ) ops.node( 2 , width, 0.0 ) ops.node( 3 , 0.0 , height) ops.node( 4 , width, height) # Fix supports at base of columns # tag, DX, DY, RZ ops.fix( 1 , 1 , 1 , 1 ) ops.fix( 2 , 1 , 1 , 1 ) # Define materials for nonlinear columns # ------------------------------------------ # CONCRETE tag f'c ec0 f'cu ecu # Core concrete (confined) uniaxialMaterial( 'Concrete01' , 1 , - 6.0 , - 0.004 , - 5.0 , - 0.014 ) # Cover concrete (unconfined) uniaxialMaterial( 'Concrete01' , 2 , - 5.0 , - 0.002 , 0.0 , - 0.006 ) # STEEL # Reinforcing steel fy = 60.0 ; # Yield stress E = 30000.0 ; # Young's modulus # tag fy E0 b uniaxialMaterial( 'Steel01' , 3 , fy, E, 0.01 ) # Define cross-section for nonlinear columns # ------------------------------------------ # some parameters colWidth = 15 colDepth = 24 cover = 1.5 As = 0.60 # area of no. 7 bars # some variables derived from the parameters y1 = colDepth / 2.0 z1 = colWidth / 2.0 section( 'Fiber' , 1 ) # Create the concrete core fibers patch( 'rect' , 1 , 10 , 1 , cover - y1, cover - z1, y1 - cover, z1 - cover) # Create the concrete cover fibers (top, bottom, left, right) patch( 'rect' , 2 , 10 , 1 , - y1, z1 - cover, y1, z1) patch( 'rect' , 2 , 10 , 1 , - y1, - z1, y1, cover - z1) patch( 'rect' , 2 , 2 , 1 , - y1, cover - z1, cover - y1, z1 - cover) patch( 'rect' , 2 , 2 , 1 , y1 - cover, cover - z1, y1, z1 - cover) # Create the reinforcing fibers (left, middle, right) layer( 'straight' , 3 , 3 , As, y1 - cover, z1 - cover, y1 - cover, cover - z1) layer( 'straight' , 3 , 2 , As, 0.0 , z1 - cover, 0.0 , cover - z1) layer( 'straight' , 3 , 3 , As, cover - y1, z1 - cover, cover - y1, cover - z1) # Define column elements # ---------------------- # Geometry of column elements # tag geomTransf( 'PDelta' , 1 ) # Number of integration points along length of element np = 5 # Lobatto integratoin beamIntegration( 'Lobatto' , 1 , 1 , np) # Create the coulumns using Beam-column elements # e tag ndI ndJ transfTag integrationTag eleType = 'forceBeamColumn' element(eleType, 1 , 1 , 3 , 1 , 1 ) element(eleType, 2 , 2 , 4 , 1 , 1 ) # Define beam elment # ----------------------------- # Geometry of column elements # tag geomTransf( 'Linear' , 2 ) # Create the beam element # tag, ndI, ndJ, A, E, Iz, transfTag element( 'elasticBeamColumn' , 3 , 3 , 4 , 360.0 , 4030.0 , 8640.0 , 2 ) # Define gravity loads # -------------------- # a parameter for the axial load P = 180.0 ; # 10% of axial capacity of columns # Create a Plain load pattern with a Linear TimeSeries timeSeries( 'Linear' , 1 ) pattern( 'Plain' , 1 , 1 ) # Create nodal loads at nodes 3 & 4 # nd FX, FY, MZ load( 3 , 0.0 , - P, 0.0 ) load( 4 , 0.0 , - P, 0.0 ) opsv.plot_model() # ------------------------------ # Start of analysis generation # ------------------------------ # Create the system of equation, a sparse solver with partial pivoting ops.system( 'BandGeneral' ) # Create the constraint handler, the transformation method ops.constraints( 'Transformation' ) # Create the DOF numberer, the reverse Cuthill-McKee algorithm ops.numberer( 'RCM' ) # Create the convergence test, the norm of the residual with a tolerance of # 1e-12 and a max number of iterations of 10 ops.test( 'NormDispIncr' , 1.0e-12 , 10 , 3 ) # Create the solution algorithm, a Newton-Raphson algorithm ops.algorithm( 'Newton' ) # Create the integration scheme, the LoadControl scheme using steps of 0.1 ops.integrator( 'LoadControl' , 0.1 ) # Create the analysis object ops.analysis( 'Static' ) # ------------------------------ # End of analysis generation # ------------------------------ # ------------------------------ # perform the analysis # ------------------------------ # perform the gravity load analysis, requires 10 steps to reach the load level ops.analyze( 10 ) # Print out the state of nodes 3 and 4 # print node 3 4 # Print out the state of element 1 # print ele 1 u3 = nodeDisp( 3 , 2 ) u4 = nodeDisp( 4 , 2 ) if abs (u3 + 0.0183736 ) < 1e-6 and abs (u4 + 0.0183736 ) < 1e-6 : print ( \"Passed!\" ) else : print ( \"Failed!\" ) Passed! opsv.plot_defo( 100 ) 100","title":"`0020` OpenSeesPy {#0020-openseespy}"},{"location":"gallery/elle-0020/opsy-portal/","text":"import openseespy.opensees as ops import openseespy.postprocessing.ops_vis as opsv import matplotlib.pyplot as plt # import opensees as ops # local compilation # import ops_vis as opsv # local ft = 12. B,H = 30 * ft, 13. * ft def f(E1, E2, Px): ops.wipe() ops.model( 'basic' , '-ndm' , 2 , '-ndf' , 3 ) Acol, Agir = 576.0 , 684.0 IzCol, IzGir = 27_648.0 , 34_383.8 E = 3600. Ep = { 1 : [E, Acol, IzCol], 2 : [E, Acol, IzCol], 3 : [E, Agir, IzGir]} ops.node( 1 , 0. , 0. ) ops.node( 2 , 0. , H) ops.node( 3 , B, 0. ) ops.node( 4 , B, H) ops.fix( 1 , 1 , 1 , 1 ) ops.fix( 3 , 1 , 1 , 1 ) ops.geomTransf( 'Linear' , 1 ) # columns ops.element( 'elasticBeamColumn' , 1 , 1 , 2 , Acol, E, IzCol, 1 ) ops.element( 'elasticBeamColumn' , 2 , 3 , 4 , Acol, E, IzCol, 1 ) # girder ops.element( 'elasticBeamColumn' , 3 , 2 , 4 , Agir, E, IzGir, 1 ) Px = 2.e+3 Wy = - 10.e+3 Wx = 0. Ew = { 3 : [ '-beamUniform' , Wy, Wx]} ops.timeSeries( 'Constant' , 1 ) ops.pattern( 'Plain' , 1 , 1 ) ops.load( 2 , Px, 0. , 0. ) # for etag in Ew: # ops.eleLoad('-ele', etag, '-type', Ew[etag][0], Ew[etag][1], # Ew[etag][2]) ops.constraints( 'Transformation' ) ops.numberer( 'RCM' ) ops.numberer( 'Plain' ) ops.system( 'BandGeneral' ) ops.test( 'NormDispIncr' , 1.0e-6 , 6 , 2 ) ops.algorithm( 'Linear' ) ops.integrator( 'LoadControl' , 1 ) ops.analysis( 'Static' ) ops.analyze( 1 ) ops.printModel() Current Domain Information Current Time: 1 tCommitted Time: 1 NODE DATA: NumNodes: 4 numComponents: 4 Node: 1 Coordinates : 0 0 Disps: 0 0 0 unbalanced Load: 0 0 0 ID : -1 -1 -1 Node: 2 Coordinates : 0 156 Disps: 5.51163 0.0248715 -0.0295316 unbalanced Load: 2000 0 0 ID : 3 4 5 Node: 3 Coordinates : 360 0 Disps: 0 0 0 unbalanced Load: 0 0 0 ID : -1 -1 -1 Node: 4 Coordinates : 360 156 Disps: 5.36679 -0.0248715 -0.0284346 unbalanced Load: 0 0 0 ID : 0 1 2 ELEMENT DATA: NumEle: 3 numComponents: 3 ElasticBeam2d: 1 Connected Nodes: 1 2 CoordTransf: 1 mass density: 0, cMass: 0 release code: 0 End 1 Forces (P V M): -330.599 1009.32 97569.3 End 2 Forces (P V M): 330.599 -1009.32 59885.1 ElasticBeam2d: 2 Connected Nodes: 3 4 CoordTransf: 1 mass density: 0, cMass: 0 release code: 0 End 1 Forces (P V M): 330.599 990.677 95415 End 2 Forces (P V M): -330.599 -990.677 59130.7 ElasticBeam2d: 3 Connected Nodes: 2 4 CoordTransf: 1 mass density: 0, cMass: 0 release code: 0 End 1 Forces (P V M): 990.677 -330.599 -59885.1 End 2 Forces (P V M): -990.677 330.599 -59130.7 SP_Constraints: numConstraints: 6 numComponents: 6SP_Constraint: 0 Node: 1 DOF: 1 ref value: 0 current value: 0 SP_Constraint: 1 Node: 1 DOF: 2 ref value: 0 current value: 0 SP_Constraint: 2 Node: 1 DOF: 3 ref value: 0 current value: 0 SP_Constraint: 3 Node: 3 DOF: 1 ref value: 0 current value: 0 SP_Constraint: 4 Node: 3 DOF: 2 ref value: 0 current value: 0 SP_Constraint: 5 Node: 3 DOF: 3 ref value: 0 current value: 0 Pressure_Constraints: numConstraints: 0 numComponents: 0 MP_Constraints: numConstraints: 0 numComponents: 0 LOAD PATTERNS: numPatterns: 1 numComponents: 1Load Pattern: 1 Scale Factor: 1 Constant Series: factor: 1 Nodal Loads: numComponents: 1Nodal Load: 2 load : 2000 0 0 Elemental Loads: numComponents: 0 Single Point Constraints: numComponents: 0 PARAMETERS: numParameters: 0 numComponents: 0 # 1. plot model with tag lebels szer, wys = 16. , 10. fig = plt.figure(figsize = (szer / 2.54 , wys / 2.54 )) fig.subplots_adjust(left = .08 , bottom = .08 , right = .985 , top = .94 ) ax1 = plt.subplot( 111 ) opsv.plot_model() # 2. plot deformed model sfac = 10. plt.figure() # plot_defo with optional arguments # sfac = opsv.plot_defo() opsv.plot_defo(sfac, fmt_interp = 'b.-' ) opsv.plot_defo(sfac, 5 , interpFlag = 0 , fmt_nodes = 'bo-' ) opsv.plot_defo(sfac, 3 , endDispFlag = 0 , fmt_interp = 'r.--' ) opsv.plot_defo(sfac, 2 , fmt_interp = 'g.-' ) 10.0 # print(f'sfac: {sfac}') # return sfac if automatically calculated # 3. plot N, V, M forces diagrams sfacN, sfacV, sfacM = 5.e-5 , 5.e-5 , 5.e-5 plt.figure() minVal, maxVal = opsv.section_force_diagram_2d( 'N' , Ew, sfacN) plt.title( f'Axial forces, max = { maxVal :.2f} , min = { minVal :.2f} ' ) plt.figure() minVal, maxVal = opsv.section_force_diagram_2d( 'T' , Ew, sfacV) plt.title( f'Shear forces, max = { maxVal :.2f} , min = { minVal :.2f} ' ) plt.figure() minVal, maxVal = opsv.section_force_diagram_2d( 'M' , Ew, sfacM) plt.title( f'Bending moments, max = { maxVal :.2f} , min = { minVal :.2f} ' ) plt.show()","title":"Opsy portal"},{"location":"gallery/elle-0040/","text":"Transient Heat \\(-\\alpha u_{xx} + Au = f\\) Consider the modified Poisson equation \\[ -\\alpha u_{xx} + Au = f, \\quad (0\\le x\\le 1), \\qquad u(0)=0,\\; u(1)=0, \\] where \\(\\alpha>0\\) and \\(A\\ge0\\) . Part A Multiplying by a test function \\(v\\) and integrating over the domain (applying integration by parts) yields: \\[ \\int_\\Omega -\\alpha u_{xx} v + \\gamma u v = \\int_\\Omega f v \\] \\[ \\int \\alpha u_x v_x dx - \\left. \\alpha u_x v \\right| + \\gamma \\int u v dx = \\int f v dx \\] For test functions which vanish on the boundary one obtains: \\[ \\int_\\Omega \\alpha u_x v_x + \\gamma u v = \\int_\\Omega f v \\] \\[ a(\\alpha u,v) + \\langle Au,v \\rangle = \\langle f,v\\rangle \\] Fourth-order element A fourth order isoparametric 1D element is developed by applying Lagrange interpolation over 5 equally spaced sampling points. These are plotted in fig. 1. Figure 1: Shape functions Convergence Do a convergence study for \\(\\alpha=1/100\\) , \\(A=0\\) and \\(f(x)=\\frac{\\pi^2}{100}\\sum_{k=0}^4 \\sin\\big((2k+1)\\pi x \\big)\\) . The exact integral for this problem is as follows: \\[ \\frac{1}{\\alpha 100} \\sum{\\frac{1}{(2k+1)^2}\\sin{\\left((2k+1)\\pi x\\right)} } \\] Source curve \\(f\\) and exact solution \\(u\\) Convergence study for finite element solution of steady-state problem. Part B: Transient Analysis Solve \\(u_t=\\frac1{100}u_{xx}+f(x)\\sin(\\pi t)\\) from \\(t=0\\) to \\(t=1\\) with initial condition \\(u(x,0)=0\\) and the same \\(f\\) as in part (a). Use the 4th order implicit SDIRK timestepper with Butcher array given below. The exact solution of the transient problem was derrived using the sympy CAS library. A plot is shown below for various times. Analytic solution curves FEM solution SDIRK Implementation In HW2 a Runge-Kutta algorithm was implemented for problems with the following form: \\[ \\mathbf{u}_t + B\\mathbf{u} = \\mathbf{d}(t) \\] Where \\(B\\) is a linear operator . At stage \\(i\\) of a diagonal Runge-Kutta method one has \\[ \\ell_{i}=F\\left(t_{n}+c_{i} k, \\vec{u}_{n}+k \\sum_{j=1}^{i-1} a_{i j} \\ell_{j}+k a_{i j} \\ell_{i}\\right) \\] where \\(k=\\Delta t\\) . For problems of the aforementioned form, this simplifies to \\[ \\left(I - k a_{i i} B\\right) \\ell_{i} = B \\left(\\vec{u}_{n}+k \\sum_{j=1}^{i-1} a_{i j} \\ell_{j}\\right) + d(t_n+c_i k) \\] The following data is required to set up a particular scheme for \\(\\mathbf{u}\\in \\mathbb{R}^n\\) with \\(s\\in\\mathbf{Z^+}\\) stages: \\(\\mathcal{T}\\) A Butcher tableau with zero entries above the diagonal. \\(B, \\mathbb{R}^n \\rightarrow \\mathbb{R}^n\\) : Discrete space operator \\(\\mathbf{d}, \\mathbb{R} \\rightarrow \\mathbb{R}^n\\) Source term. The problem at hand is manipulated to fit the following form: \\[\\vec{u}_{t}=-\\frac{1}{100} {M}^{-1} A \\vec{u}+\\vec{f} \\sin \\pi t\\] so that \\[ \\begin{gathered} B=\\frac{-1}{100}M^{-1}A \\\\ \\mathbf{d}=M^{-1}b\\sin{\\pi t} \\end{gathered} \\] where \\(A\\) , \\(M\\) , and \\(b\\) are the stiffness, mass and load vectors as readily produced by the implementation for Part B. \\[ \\left(M+\\frac{k a_{i i}}{100} A\\right) l_{i} = -\\frac{1}{100} A\\left(\\vec{u}_{n}+k \\sum_{j=1}^{i-1} a_{i j} \\ell_{j}\\right) + M \\vec{f} \\sin \\pi\\left(t_{n}+c_{i} k\\right) \\] The tableau \\(\\mathcal{T}\\) is given as \\[ \\begin{array}{c|ccccc} 1/4 & 1/4 \\\\ 3/4 & 1/2 & 1/4 \\\\ 11/20 & 17/50 & -1/25 & 1/4 \\\\ 1/2 & 371/1360 & -137/2720 & 15/544 & 1/4 \\\\ 1 & 25/24 & -49/48 & 125/16 & -85/12 & 1/4 \\\\ \\hline & 25/24 & -49/48 & 125/16 & -85/12 & 1/4 \\end{array} \\] \\(u(x,t) = \\sum_j u_j(t)\\phi_j(x)\\) \\[u_{t}=\\frac{1}{100} u_{x x}+f(x) \\sin \\pi t\\] let \\(u_t = \\sum_ju_{j,t}\\phi_j\\) , and \\(v=\\phi_i\\) \\[ \\langle u_{t}, v\\rangle = -\\frac{1}{100} a(u, v)+\\langle f, v\\rangle \\sin \\pi t \\] \\[ M \\vec{u}_{t}=-\\frac{1}{100} A \\vec{u} + M \\vec{f} \\sin \\pi t \\] \\[ \\vec{u}_{t}=-\\frac{1}{100} {M}^{-1} A \\vec{u}+\\vec{f} \\sin \\pi t \\] Convergence Convergence studies are presented below for time discretizations using both the SDIRK scheme provided and the Crank-Nicolson scheme. Convergence study. Convergence study for Crank-Nicolson tableau. Appendix Source Code Fourth-order Lagrange element Analytic Transient Solution","title":"Transient Heat"},{"location":"gallery/elle-0040/p2/","text":"Following [@leveque1992numerical] and beginning at the Rankine-Hugoniot condition, the following system of equations is obtained: \\[ \\begin{aligned} \\tilde{m}-\\hat{m} &=s(\\tilde{\\rho}-\\hat{\\rho}) \\\\ \\left(\\tilde{m}^{2} / \\tilde{\\rho}+a^{2} \\tilde{\\rho}\\right)-\\left(\\hat{m}^{2} / \\hat{\\rho}+a^{2} \\hat{\\rho}\\right) &=s(\\tilde{m}-\\hat{m}) \\end{aligned} \\] Graphical solution of the isothermal Riemann problem \\[ \\rho_{1} m_{0} / \\rho_{0}-a \\sqrt{\\rho_{1} / \\rho_{0}}\\left(\\rho_{1}-\\rho_{0}\\right)=\\rho_{1} m_{2} / \\rho_{2}+a \\sqrt{\\rho_{1} / \\rho_{2}}\\left(\\rho_{1}-\\rho_{2}\\right) \\] \\[ \\left(\\frac{a}{\\sqrt{\\rho_{2}}}+\\frac{a}{\\sqrt{\\rho_{0}}}\\right) z^{2}+\\left(\\frac{m_{2}}{\\rho_{2}}-\\frac{m_{0}}{\\rho_{0}}\\right) z-a\\left(\\sqrt{\\rho_{2}}+\\sqrt{\\rho_{0}}\\right)=0 \\] Plugging in the specified values for \\(q_0\\) and \\(q_2\\) yields the following coefficients: \\[ \\begin{aligned} \\frac{a}{\\sqrt{\\rho_{2}}}+\\frac{a}{\\sqrt{\\rho_{0}}} = 2\\\\ \\frac{m_{2}}{\\rho_{2}}-\\frac{m_{0}}{\\rho_{0}} = -3\\\\ a\\left(\\sqrt{\\rho_{2}}+\\sqrt{\\rho_{0}}\\right) = -2 \\end{aligned} \\] This yields the following roots: \\[ \\rho_1 = \\left\\{\\frac{1}{4}, 4\\right\\} \\\\ \\] \\[ m_1 =\\rho_{m} m_{r} / \\rho_{r}+a \\sqrt{\\rho_{m} / \\rho_{r}}\\left(\\rho_{m}-\\rho_{r}\\right) \\\\ \\] \\[ \\boxed{q_1 = \\begin{pmatrix}4 \\\\ 6\\end{pmatrix}} \\] In each region \\(i=0,1,2\\) , compute the characteristic speeds, which are the eigenvalues \\(\\lambda_{i1}\\) and \\(\\lambda_{i2}\\) of the Jacobian \\(J_i=DF(q_i)\\) . Also compute the fluid velocities \\(v_i\\) . \\[ DF(q_i)=\\begin{pmatrix} 0 & 1 \\\\ a^{2}-m_i^{2} / \\rho_i^{2} & 2 m_i / \\rho_i \\end{pmatrix} \\] State \\(i=0\\) \\[ DF(q_0) = \\begin{pmatrix}0 & 1\\\\ -8 & 6\\end{pmatrix} \\] \\[ \\lambda = \\{2,4\\} \\] \\[ \\mathbf{Q} = \\begin{pmatrix} -0.4472136 & -0.24253563\\\\ -0.89442719 & -0.9701425 \\end{pmatrix} \\] \\[ v_0 = 3 \\] State \\(i=1\\) \\[ \\lambda_1 = \\{1/2, 5/2\\} \\] \\[ \\mathbf{Q} = \\begin{pmatrix} -0.89442719& -0.37139068 \\\\ -0.4472136 & -0.92847669 \\end{pmatrix} \\] \\[ v_1 = 3/2 \\] \\[ \\dot s_1 = 1 \\] State \\(i=2\\) \\[ DF(q_2) = \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix} \\] \\[ \\lambda_2 = (1,-1) \\] \\[ \\mathbf{Q} = \\frac{1}{\\sqrt{2}}\\begin{pmatrix}1 & -1 \\\\ 1 & 1\\end{pmatrix} \\] \\[ v_2 = 0 \\] \\[ \\dot s_2 = 2 \\]","title":"P2"},{"location":"gallery/elle-0040/out/main/","text":"Problem 1 ( \\(\\mathbf{u}_t + A \\mathbf{u}_x = \\mathbf{0}\\) ) Consider the Riemann problem \\[ \\begin{gathered} \\begin{pmatrix} p \\\\ u \\end{pmatrix}_t + \\begin{pmatrix} 0 & c_0^2\\rho_0 \\\\ 1/\\rho_0 & 0 \\end{pmatrix} \\begin{pmatrix} p \\\\ u \\end{pmatrix}_x = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}, \\qquad (x\\in\\mathbb R\\;,\\; t>0) \\\\[5pt] p(x,0)=\\left\\{ \\begin{array}{cc} p_L & x<0 \\\\ p_R & x>0 \\end{array}\\right\\}, \\quad u(x,0)=\\left\\{ \\begin{array}{cc} u_L & x<0 \\\\ u_R & x>0 \\end{array}\\right\\} \\end{gathered} \\] describing linear acoustics. Compute the exact solution \\(p(x,t)\\) and \\(u(x,t)\\) for \\(x\\in\\mathbb R\\) , \\(t>0\\) . Here \\(c_0\\) and \\(\\rho_0\\) are positive constants while \\(u_L\\) , \\(u_R\\) , \\(p_L\\) and \\(p_R\\) are arbitrary real constants. \\[ A = Q\\Lambda Q^{-1} = \\begin{pmatrix} 1 & -c_0 \\rho_0 \\\\ \\frac{1}{c_0 \\rho_0} & 1 \\end{pmatrix} \\begin{pmatrix}c_0 & 0 \\\\ 0 & -c_0\\end{pmatrix} \\begin{pmatrix}1/2 & c_0 \\rho_0 /2 \\\\ \\frac{-1}{2 c_0 \\rho_0 } & 1/2\\end{pmatrix} \\] \\[ \\mathbf{w}(x,0)=\\left\\{ \\begin{array}{cc} \\mathbf{w}_L & x<0 \\\\ \\mathbf{w}_R & x>0 \\end{array}\\right. \\] Characteristics: \\[ x_i^0 = x - \\lambda_i t \\quad i=1,2 \\] \\[ w_i(x,t)=\\left\\{\\begin{array}{cc} w_i^L & x_0(x,t)<0 \\\\ w_i^R & x_0(x,t)>0 \\end{array}\\right. \\] Using \\(\\mathbf{w} = Q^{-1}\\mathbf{u}\\) \\[ w_1 = \\frac{p + c_0 \\rho_0 u}{2} \\\\ \\] \\[ w_2 = \\frac{u}{2} - \\frac{1}{ 2 c_0 \\rho_0 }p \\] where the superscript Decomposing \\(Q\\) into column vectors \\(\\mathbf{q}_j\\) , and summing on \\(j=1,2\\) : \\[ \\mathbf{u}(x,t)= \\left\\{\\begin{array}{cc} \\mathbf{q}_jw_j^L & x^0_i(x,t)<0\\\\ \\mathbf{q}_jw_j^R & x^0_i(x,t)>0 \\end{array} \\right. \\] Expanding for all regions yields \\[ \\mathbf{u}(x,t)= \\left\\{\\begin{array}{cc} \\mathbf{q}_1w_1^L + \\mathbf{q}_2w_2^L& x^0_2(x,t)<0\\\\ \\mathbf{q}_1w_1^L + \\mathbf{q}_2w_2^R& x^0_1(x,t)> 0 > x^0_2(x,t)\\\\ \\mathbf{q}_1w_1^R + \\mathbf{q}_2w_2^L& x^0_1(x,t)< 0 < x^0_2(x,t)\\\\ \\mathbf{q}_1w_1^R + \\mathbf{q}_2w_2^R& x^0_1(x,t)>0 \\end{array} \\right. \\] The region \\(x_1^0 > 0 > x_2^0\\) is not valid for the eigenvalues \\(\\lambda = (c_0, -c_0)^T\\) so that the only intermediate state is \\[ \\mathbf{u}^M = \\mathbf{q}_1w_1^R + \\mathbf{q}_2 w_2^L , \\quad x^0_1(x,t)< 0 < x^0_2(x,t) \\] \\[ \\boxed{ \\begin{gathered} p^M = \\frac{1}{2}\\left(p^R+c_0 \\rho_0 u^R\\right) -\\frac{1}{2} \\left(c_0\\rho_0 u^L - p^L\\right) \\\\ u^M = \\frac{1}{2\\rho_0 c_0} \\left(p^R + \\rho_0 c_0 u^R\\right) + \\frac{u^R}{2} - \\frac{p^L}{2 \\rho_0 c_0} \\\\ \\mathbf{u}^M = \\begin{pmatrix} p^M \\\\ u^M\\end{pmatrix} \\\\ \\mathbf{u}(x,t)= \\left\\{\\begin{array}{cc} \\mathbf{u}^L & x^0_2(x,t)<0\\\\ \\mathbf{u}^M & x^0_1(x,t)< 0 < x^0_2(x,t)\\\\ \\mathbf{u}^R & x^0_1(x,t)>0\\\\ \\end{array} \\right.\\\\ \\end{gathered}} \\] Problem 2. Consider the nonlinear isothermal equations of gas dynamics, \\[ \\begin{pmatrix} \\rho \\\\ m \\end{pmatrix}_t + \\begin{pmatrix} m \\\\ \\frac{m^2}\\rho + a^2\\rho \\end{pmatrix}_x = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}. \\] Here \\(m\\) is the momentum and the velocity of the gas is \\(v=m/\\rho\\) . Let \\(a=1\\) and consider the Reimann problem \\(\\rho(x,0)=\\left\\{\\begin{array}{cc} \\rho_0 & x<0 \\\\ \\rho_2 & x>0 \\end{array}\\right\\}\\) , \\(m(x,0)=\\left\\{\\begin{array}{cc} m_0 & x<0 \\\\ m_2 & x>0 \\end{array}\\right\\}\\) , where \\[ q_0 = \\begin{pmatrix} \\rho_0 \\\\ m_0 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 3 \\end{pmatrix}, \\qquad q_2 = \\begin{pmatrix} \\rho_2 \\\\ m_2 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}. \\] Find an intermediate state \\(q_1=\\begin{pmatrix} \\rho_1 \\\\ m_1 \\end{pmatrix}\\) and shock speeds \\(\\dot s_1\\) and \\(\\dot s_2\\) such that \\[ F(q_i)-F(q_{i-1}) = \\dot s_i(q_i-q_{i-1}), \\qquad (i=1,2), \\qquad \\dot s_2>\\dot s_1. \\] Following [@leveque1992numerical] and beginning at the Rankine-Hugoniot condition, the following system of equations is obtained: \\[ \\begin{aligned} \\tilde{m}-\\hat{m} &=s(\\tilde{\\rho}-\\hat{\\rho}) \\\\ \\left(\\tilde{m}^{2} / \\tilde{\\rho}+a^{2} \\tilde{\\rho}\\right)-\\left(\\hat{m}^{2} / \\hat{\\rho}+a^{2} \\hat{\\rho}\\right) &=s(\\tilde{m}-\\hat{m}) \\end{aligned} \\] Graphical solution of the isothermal Riemann problem \\[ \\rho_{1} m_{0} / \\rho_{0}-a \\sqrt{\\rho_{1} / \\rho_{0}}\\left(\\rho_{1}-\\rho_{0}\\right)=\\rho_{1} m_{2} / \\rho_{2}+a \\sqrt{\\rho_{1} / \\rho_{2}}\\left(\\rho_{1}-\\rho_{2}\\right) \\] \\[ \\left(\\frac{a}{\\sqrt{\\rho_{2}}}+\\frac{a}{\\sqrt{\\rho_{0}}}\\right) z^{2}+\\left(\\frac{m_{2}}{\\rho_{2}}-\\frac{m_{0}}{\\rho_{0}}\\right) z-a\\left(\\sqrt{\\rho_{2}}+\\sqrt{\\rho_{0}}\\right)=0 \\] Plugging in the specified values for \\(q_0\\) and \\(q_2\\) yields the following coefficients: \\[ \\begin{aligned} \\frac{a}{\\sqrt{\\rho_{2}}}+\\frac{a}{\\sqrt{\\rho_{0}}} = 2\\\\ \\frac{m_{2}}{\\rho_{2}}-\\frac{m_{0}}{\\rho_{0}} = -3\\\\ a\\left(\\sqrt{\\rho_{2}}+\\sqrt{\\rho_{0}}\\right) = -2 \\end{aligned} \\] This yields the following roots: \\[ \\rho_1 = \\left\\{\\frac{1}{4}, 4\\right\\} \\\\ \\] \\[ m_1 =\\rho_{m} m_{r} / \\rho_{r}+a \\sqrt{\\rho_{m} / \\rho_{r}}\\left(\\rho_{m}-\\rho_{r}\\right) \\\\ \\] \\[ \\boxed{q_1 = \\begin{pmatrix}4 \\\\ 6\\end{pmatrix}} \\] In each region \\(i=0,1,2\\) , compute the characteristic speeds, which are the eigenvalues \\(\\lambda_{i1}\\) and \\(\\lambda_{i2}\\) of the Jacobian \\(J_i=DF(q_i)\\) . Also compute the fluid velocities \\(v_i\\) . \\[ DF(q_i)=\\begin{pmatrix} 0 & 1 \\\\ a^{2}-m_i^{2} / \\rho_i^{2} & 2 m_i / \\rho_i \\end{pmatrix} \\] State \\(i=0\\) \\[ DF(q_0) = \\begin{pmatrix}0 & 1\\\\ -8 & 6\\end{pmatrix} \\] \\[ \\lambda = \\{2,4\\} \\] \\[ \\mathbf{Q} = \\begin{pmatrix} -0.4472136 & -0.24253563\\\\ -0.89442719 & -0.9701425 \\end{pmatrix} \\] \\[ v_0 = 3 \\] State \\(i=1\\) \\[ \\lambda_1 = \\{1/2, 5/2\\} \\] \\[ \\mathbf{Q} = \\begin{pmatrix} -0.89442719& -0.37139068 \\\\ -0.4472136 & -0.92847669 \\end{pmatrix} \\] \\[ v_1 = 3/2 \\] \\[ \\dot s_1 = 1 \\] State \\(i=2\\) \\[ DF(q_2) = \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix} \\] \\[ \\lambda_2 = (1,-1) \\] \\[ \\mathbf{Q} = \\frac{1}{\\sqrt{2}}\\begin{pmatrix}1 & -1 \\\\ 1 & 1\\end{pmatrix} \\] \\[ v_2 = 0 \\] \\[ \\dot s_2 = 2 \\] Confirm that \\(\\lambda_{01}>\\dot s_1>\\lambda_{11}\\) and \\(\\lambda_{12}>\\dot s_2>\\lambda_{22}\\) , which are Lax\u2019s entropy conditions for this system. Also confirm that \\(v_0>\\dot s_1\\) , \\(v_1>\\dot s_1\\) , \\(\\dot s_2>v_1\\) and \\(\\dot s_2>v_2\\) , which means fluid particles move from the original states \\(q_0\\) and \\(q_2\\) to the auxiliary state \\(q_1\\) as the shocks propagate through space and time. Problem 3 ( \\(-\\alpha u_{xx} + Au = f\\) ) Write a 1d finite element code to solve the modified Poisson equation \\[ -\\alpha u_{xx} + Au = f, \\quad (0\\le x\\le 1), \\qquad u(0)=0,\\; u(1)=0, \\] where \\(\\alpha>0\\) and \\(A\\ge0\\) . Use 4th order finite elments on a uniformly spaced grid, \\[ x_j = j/M, \\qquad\\quad 0\\le j\\le M \\] where \\(M\\) is divisible by 4 and the \\(r\\) th element includes nodes \\(x_{4r+i}\\) for \\(0\\le r<M/4\\) and \\(0\\le i\\le 4\\) . Part A Multiplying by a test function \\(v\\) and integrating over the domain (applying integration by parts) yields: \\[ \\int_\\Omega -\\alpha u_{xx} v + \\gamma u v = \\int_\\Omega f v \\] \\[ \\int \\alpha u_x v_x dx - \\left. \\alpha u_x v \\right| + \\gamma \\int u v dx = \\int f v dx \\] For test functions which vanish on the boundary one obtains: \\[ \\int_\\Omega \\alpha u_x v_x + \\gamma u v = \\int_\\Omega f v \\] \\[ a(\\alpha u,v) + \\langle Au,v \\rangle = \\langle f,v\\rangle \\] Fourth-order element A fourth order isoparametric 1D element is developed by applying Lagrange interpolation over 5 equally spaced sampling points. Shape functions Convergence Do a convergence study for \\(\\alpha=1/100\\) , \\(A=0\\) and \\(f(x)=\\frac{\\pi^2}{100}\\sum_{k=0}^4 \\sin\\big((2k+1)\\pi x \\big)\\) . The exact integral for this problem is as follows: \\[ \\frac{1}{\\alpha 100} \\sum{\\frac{1}{(2k+1)^2}\\sin{\\left((2k+1)\\pi x\\right)} } \\] Source curve \\(f\\) and exact solution \\(u\\) Convergence study for finite element solution of steady-state problem. Part B: Transient Analysis Solve \\(u_t=\\frac1{100}u_{xx}+f(x)\\sin(\\pi t)\\) from \\(t=0\\) to \\(t=1\\) with initial condition \\(u(x,0)=0\\) and the same \\(f\\) as in part (a). Use the 4th order implicit SDIRK timestepper with Butcher array given in problem 2 of HW 2. Use your finite element code above to solve the implicit equation for each stage of the timestepper. (I\u2019ll explain this in class). Make a convergence plot for several values of \\(M\\) and one choice of \\(\\nu=k/h\\) that you find works well. The exact solution of the transient problem was derrived using the sympy CAS library. A plot is shown below for various times. Analytic solution curves FEM solution SDIRK Implementation In HW2 a Runge-Kutta algorithm was implemented for problems with the following form: \\[ \\mathbf{u}_t + B\\mathbf{u} = \\mathbf{d}(t) \\] Where \\(B\\) is a linear operator . At stage \\(i\\) of a diagonal Runge-Kutta method one has \\[ \\ell_{i}=F\\left(t_{n}+c_{i} k, \\vec{u}_{n}+k \\sum_{j=1}^{i-1} a_{i j} \\ell_{j}+k a_{i j} \\ell_{i}\\right) \\] where \\(k=\\Delta t\\) . For problems of the aforementioned form, this simplifies to \\[ \\left(I - k a_{i i} B\\right) \\ell_{i} = B \\left(\\vec{u}_{n}+k \\sum_{j=1}^{i-1} a_{i j} \\ell_{j}\\right) + d(t_n+c_i k) \\] The following data is required to set up a particular scheme for \\(\\mathbf{u}\\in \\mathbb{R}^n\\) with \\(s\\in\\mathbf{Z^+}\\) stages: \\(\\mathcal{T}\\) A Butcher tableau with zero entries above the diagonal. \\(B, \\mathbb{R}^n \\rightarrow \\mathbb{R}^n\\) : Discrete space operator \\(\\mathbf{d}, \\mathbb{R} \\rightarrow \\mathbb{R}^n\\) Source term. The problem at hand is manipulated to fit the following form: \\[\\vec{u}_{t}=-\\frac{1}{100} {M}^{-1} A \\vec{u}+\\vec{f} \\sin \\pi t\\] so that \\[ \\begin{gathered} B=\\frac{-1}{100}M^{-1}A \\\\ \\mathbf{d}=M^{-1}b\\sin{\\pi t} \\end{gathered} \\] where \\(A\\) , \\(M\\) , and \\(b\\) are the stiffness, mass and load vectors as readily produced by the implementation for Part B. \\[ \\left(M+\\frac{k a_{i i}}{100} A\\right) l_{i} = -\\frac{1}{100} A\\left(\\vec{u}_{n}+k \\sum_{j=1}^{i-1} a_{i j} \\ell_{j}\\right) + M \\vec{f} \\sin \\pi\\left(t_{n}+c_{i} k\\right) \\] The tableau \\(\\mathcal{T}\\) is given as \\[ \\begin{array}{c|ccccc} 1/4 & 1/4 \\\\ 3/4 & 1/2 & 1/4 \\\\ 11/20 & 17/50 & -1/25 & 1/4 \\\\ 1/2 & 371/1360 & -137/2720 & 15/544 & 1/4 \\\\ 1 & 25/24 & -49/48 & 125/16 & -85/12 & 1/4 \\\\ \\hline & 25/24 & -49/48 & 125/16 & -85/12 & 1/4 \\end{array} \\] \\(u(x,t) = \\sum_j u_j(t)\\phi_j(x)\\) \\[u_{t}=\\frac{1}{100} u_{x x}+f(x) \\sin \\pi t\\] let \\(u_t = \\sum_ju_{j,t}\\phi_j\\) , and \\(v=\\phi_i\\) \\[ \\langle u_{t}, v\\rangle = -\\frac{1}{100} a(u, v)+\\langle f, v\\rangle \\sin \\pi t \\] \\[ M \\vec{u}_{t}=-\\frac{1}{100} A \\vec{u} + M \\vec{f} \\sin \\pi t \\] \\[ \\vec{u}_{t}=-\\frac{1}{100} {M}^{-1} A \\vec{u}+\\vec{f} \\sin \\pi t \\] Convergence Convergence studies are presented below for time discretizations using both the SDIRK scheme provided and the Crank-Nicolson scheme. Convergence study. Convergence study for Crank-Nicolson tableau. Appendix Key source code excerpts are provided below. The Python libraries elle , emme , anon and m228 which have been used throughout are self written and available either from PyPi.org via pip or on Github. Source Code Fourth-order Lagrange element # external imports import jax # internal imports import anon import anon.atom as anp from anon import quad @anon.dual.generator ( 5 ) def elem_0001(f = None ,a1 = 1.0 , a2 = 0.0 ,order = 4 ): \"\"\" Fourth order 1D Lagrange finite element with uniformly spaced nodes. Parameters ---------- f: Callable element loading. a1: float Stiffness coefficient a2: float Mass coefficient \"\"\" state = {} if f is None : f = lambda x: 0.0 def transf(xi: float ,x_nodes) -> float : return ( x_nodes[ 0 ] * ( + xi / 6 ) + x_nodes[ 1 ] * ( - 4 * xi / 3 ) + x_nodes[ 2 ] * ( + 1 ) + x_nodes[ 3 ] * ( + 4 * xi / 3 ) + x_nodes[ 4 ] * ( - xi / 6 ) ) def grad_transf(xi,x_nodes): return abs (x_nodes[ - 1 ] - x_nodes[ 0 ]) / 2 quad_points = quad.quad_points(n = order + 1 ,rule = \"gauss-legendre\" ) @jax.jit def jacx(u = None ,y = None ,state = None ,xyz = None , a1 = a1, a2 = a2): x_nodes = anp.linspace(xyz[ 0 ][ 0 ],xyz[ - 1 ][ 0 ], 5 ) grad = grad_transf( 0 ,x_nodes) return a1 * anp.array([ [ 985 / 378 , - 3424 / 945 , 508 / 315 , - 736 / 945 , 347 / 1890 ], [ - 3424 / 945 , 1664 / 189 , - 2368 / 315 , 2944 / 945 , - 736 / 945 ], [ 508 / 315 , - 2368 / 315 , 248 / 21 , - 2368 / 315 , 508 / 315 ], [ - 736 / 945 , 2944 / 945 , - 2368 / 315 , 1664 / 189 , - 3424 / 945 ], [ 347 / 1890 , - 736 / 945 , 508 / 315 , - 3424 / 945 , 985 / 378 ], ]) / grad + a2 * anp.array([ [ 292 / 2835 , 296 / 2835 , - 58 / 945 , 8 / 405 , - 29 / 2835 ], [ 296 / 2835 , 256 / 405 , - 128 / 945 , 256 / 2835 , 8 / 405 ], [ - 58 / 945 , - 128 / 945 , 208 / 315 , - 128 / 945 , - 58 / 945 ], [ 8 / 405 , 256 / 2835 , - 128 / 945 , 256 / 405 , 296 / 2835 ], [ - 29 / 2835 , 8 / 405 , - 58 / 945 , 296 / 2835 , 292 / 2835 ], ]) * grad @jax.jit def main(u,_,state,xyz,a1 = a1,a2 = a2): x_nodes = anp.linspace(xyz[ 0 ][ 0 ],xyz[ - 1 ][ 0 ], 5 ) external_term = sum ( anp.array([ [f(transf(xi,x_nodes)) * ( 2 * xi ** 4 / 3 - 2 * xi ** 3 / 3 - xi ** 2 / 6 + xi / 6 )], [f(transf(xi,x_nodes)) * ( - 8 * xi ** 4 / 3 + 4 * xi ** 3 / 3 + 8 * xi ** 2 / 3 - 4 * xi / 3 )], [f(transf(xi,x_nodes)) * ( 4 * xi ** 4 - 5 * xi ** 2 + 1 )], [f(transf(xi,x_nodes)) * ( - 8 * xi ** 4 / 3 - 4 * xi ** 3 / 3 + 8 * xi ** 2 / 3 + 4 * xi / 3 )], [f(transf(xi,x_nodes)) * ( 2 * xi ** 4 / 3 + 2 * xi ** 3 / 3 - xi ** 2 / 6 - xi / 6 )], ] ) * weight * grad_transf(xi,x_nodes) for xi, weight in zip ( * quad_points) ) resp = jacx(u,_,state,xyz,a1 = a1,a2 = a2) @ u + external_term return u, resp, state return locals () Analytic Transient Solution pi = anp.pi sin = anp.sin cos = anp.cos exp = anp.exp def cn(t): return [ pi ** 2 * (pi * alpha * sin(pi * t) / (pi ** 3 * alpha ** 2 + pi) - cos(pi * t) / (pi ** 3 * alpha ** 2 + pi)) / 100 + pi ** 2 / ( 100 * (pi ** 3 * alpha ** 2 * exp(pi ** 2 * alpha * t) + pi * exp(pi ** 2 * alpha * t))), pi ** 2 * ( 9 * pi * alpha * sin(pi * t) / ( 81 * pi ** 3 * alpha ** 2 + pi) - cos(pi * t) / ( 81 * pi ** 3 * alpha ** 2 + pi)) / 100 + pi ** 2 / ( 100 * ( 81 * pi ** 3 * alpha ** 2 * exp( 9 * pi ** 2 * alpha * t) + pi * exp( 9 * pi ** 2 * alpha * t))), pi ** 2 * ( 25 * pi * alpha * sin(pi * t) / ( 625 * pi ** 3 * alpha ** 2 + pi) - cos(pi * t) / ( 625 * pi ** 3 * alpha ** 2 + pi)) / 100 + pi ** 2 / ( 100 * ( 625 * pi ** 3 * alpha ** 2 * exp( 25 * pi ** 2 * alpha * t) + pi * exp( 25 * pi ** 2 * alpha * t))), pi ** 2 * ( 49 * pi * alpha * sin(pi * t) / ( 2401 * pi ** 3 * alpha ** 2 + pi) - cos(pi * t) / ( 2401 * pi ** 3 * alpha ** 2 + pi)) / 100 + pi ** 2 / ( 100 * ( 2401 * pi ** 3 * alpha ** 2 * exp( 49 * pi ** 2 * alpha * t) + pi * exp( 49 * pi ** 2 * alpha * t))), pi ** 2 * ( 81 * pi * alpha * sin(pi * t) / ( 6561 * pi ** 3 * alpha ** 2 + pi) - cos(pi * t) / ( 6561 * pi ** 3 * alpha ** 2 + pi)) / 100 + pi ** 2 / ( 100 * ( 6561 * pi ** 3 * alpha ** 2 * exp( 81 * pi ** 2 * alpha * t) + pi * exp( 81 * pi ** 2 * alpha * t))) ] def u(x,t): c = cn(t) return sum ( c[n] * anp.sin(xi * x) for n,xi in enumerate ([( 2 * k + 1 ) * anp.pi for k in range ( 5 )]) )","title":"Problem 1 ($\\mathbf{u}_t + A \\mathbf{u}_x = \\mathbf{0}$)"},{"location":"gallery/elle-0050/","text":"Part 1: Base case Consider the Dirichlet problem \\[ \\begin{aligned} -\\Delta u &= 4, & \\quad &\\text{in $\\Omega$} \\\\ u &= 0, & &\\text{on $\\partial\\Omega$} \\end{aligned} \\] on the unit disk \\(\\Omega=\\{(x,y)\\;:\\; x^2+y^2\\le 1\\}\\) The exact solution to this problem is \\[ \\boxed{u = 1 - x^2 - y^2} \\] A function implementing quadratic Lagrange interpolation over a reference triangle is implemented in the file interpolate.py which is used by the function poisson2 from poisson.py to create a finite element that locally evaluates the following variational Poisson problem \\[ \\sum_{j=1}^{n} \\mathbf{u}_{j} \\int_{\\Omega} \\nabla \\phi_{j} \\cdot \\nabla \\phi_{i}=\\int_{\\Omega} \\phi_{i} f+\\int_{\\partial \\Omega_{N}} \\phi_{i} g_{N}-\\sum_{j=n+1}^{n+n_{\\partial}} \\mathbf{u}_{j} \\int_{\\Omega} \\nabla \\phi_{j} \\cdot \\nabla \\phi_{i} \\] A model is constructed by loading a pre-defined mesh from the file mesh.m228 as follows: model = anabel.MeshGroup.read( f\"../dat/circle_iso/mesh.m228\" , cell = \"triangle6\" ) elem = poisson( * [lagrange_t6()] * 3 , f = f) U = model.compose(elem = elem, solver = \"sparse\" , verbose = True ) This builds a function U which accepts quadrature locations and weights as input. Given a particular quadrature rule, a solution may be computed and plotted as follows: quad = anon.quad.simplex.Simplex.load( f\"../dat/quadrature/gauss {g:02} .m\" ) model.plot(U(quad.points, quad.weights)) Finite element solution using order-2 Gaussian quadrature Closed-form solution to the stated Poisson problem. Convergence study. Nonlinear Source \\[ \\begin{aligned} -\\Delta u &= \\frac{\\pi^2}{4}\\left(\\cos\\frac{\\pi r}{2} + \\operatorname{sinc} \\frac{\\pi r}{2}\\right), & \\quad &\\text{in $\\Omega$} \\\\ u &= 0, & &\\text{on $\\partial\\Omega$} \\end{aligned} \\] where \\(\\Omega\\) is again the unit disk. The exact solution is \\(u(x,y)=\\cos \\frac{\\pi r}{2}\\) , where \\(r=\\sqrt{x^2+y^2}\\) . Plot of the given closed-form solution. Contributions from Errors \\[ \\iint_T \\nabla(u_{FE} - u_{exact}) \\cdot \\nabla(u_{FE} - u_{exact})\\,dx \\, dy, \\qquad (T\\in\\mathcal{T}) \\] The \\(H^1\\) semi-norm error in the finite element solution is the square root of the sum of all the errors shown here. Appendix Source Code of Interest","title":"Poisson Equation in 2D"},{"location":"gallery/elle-0050/convergence-tab/","text":"Table of errors in the L2 norm for problem 1 \\(h\\) 2 5 13 19 0.5 0.0024764578 0.0030141854 0.0029849953 0.0029849953 0.25 0.0002258162 0.00027375659 0.00027090969 0.00027090969 0.125 2.1527457e-05 2.5708536e-05 2.5448945e-05 2.5448945e-05 0.0625 1.9830323e-06 2.3460163e-06 2.3228069e-06 2.3228069e-06 0.03125 1.7587735e-07 2.0760524e-07 2.0555351e-07 2.0555351e-07 Table of errors in the L2 norm for problem 2 \\(h\\) 2 5 13 19 0.5 0.0099611923 0.0064076596 0.0071412137 0.0071412137 0.25 0.0013051996 0.00083984741 0.0009471105 0.0009471105 0.125 0.00016874334 0.00010830203 0.00012249798 0.00012249798 0.0625 2.1626624e-05 1.3882073e-05 1.5691434e-05 1.5691434e-05 0.03125 2.7380054e-06 1.756023e-06 1.9850051e-06 1.9850051e-06 Table of errors in the H1 norm for problem 1 \\(h\\) 2 5 13 19 0.5 0.033040555 0.05344312 0.053451002 0.053451002 0.25 0.0057268302 0.0091748492 0.0091751946 0.0091751946 0.125 0.0010299012 0.0016399388 0.0016399544 0.0016399544 0.0625 0.00018443725 0.00029237375 0.00029237444 0.00029237444 0.03125 3.254096e-05 5.152993e-05 5.1529961e-05 5.1529961e-05 Table of errors in the H1 norm for problem 2 \\(h\\) 2 5 13 19 0.5 0.050321736 0.087419539 0.087364004 0.087364004 0.25 0.013576873 0.024424342 0.024421502 0.024421502 0.125 0.0036081315 0.0065157661 0.006515551 0.006515551 0.0625 0.00093741811 0.0016853971 0.0016853811 0.0016853811 0.03125 0.00023986093 0.00042915864 0.00042915753 0.00042915753","title":"Convergence tab"},{"location":"gallery/elle-0050/gallery/","text":"Plots of Finite Element Solutions Finite element solution for problem 1 over mesh number 1 and order-2 numerical integration. Finite element solution for problem 1 over mesh number 1 and order-5 numerical integration. Finite element solution for problem 1 over mesh number 1 and order-8 numerical integration. Finite element solution for problem 1 over mesh number 1 and order-13 numerical integration. Finite element solution for problem 1 over mesh number 1 and order-19 numerical integration. Finite element solution for problem 1 over mesh number 2 and order-2 numerical integration. Finite element solution for problem 1 over mesh number 2 and order-5 numerical integration. Finite element solution for problem 1 over mesh number 2 and order-8 numerical integration. Finite element solution for problem 1 over mesh number 2 and order-13 numerical integration. Finite element solution for problem 1 over mesh number 2 and order-19 numerical integration. Finite element solution for problem 1 over mesh number 3 and order-2 numerical integration. Finite element solution for problem 1 over mesh number 3 and order-5 numerical integration. Finite element solution for problem 1 over mesh number 3 and order-8 numerical integration. Finite element solution for problem 1 over mesh number 3 and order-13 numerical integration. Finite element solution for problem 1 over mesh number 3 and order-19 numerical integration. Finite element solution for problem 1 over mesh number 4 and order-2 numerical integration. Finite element solution for problem 1 over mesh number 4 and order-5 numerical integration. Finite element solution for problem 1 over mesh number 4 and order-8 numerical integration. Finite element solution for problem 1 over mesh number 4 and order-13 numerical integration. Finite element solution for problem 1 over mesh number 4 and order-19 numerical integration. Finite element solution for problem 1 over mesh number 5 and order-2 numerical integration. Finite element solution for problem 1 over mesh number 5 and order-5 numerical integration. Finite element solution for problem 1 over mesh number 5 and order-8 numerical integration. Finite element solution for problem 1 over mesh number 5 and order-13 numerical integration. Finite element solution for problem 1 over mesh number 5 and order-19 numerical integration. Finite element solution for problem 1 over mesh number 1 and order-2 numerical integration. Finite element solution for problem 1 over mesh number 1 and order-5 numerical integration. Finite element solution for problem 1 over mesh number 1 and order-8 numerical integration. Finite element solution for problem 1 over mesh number 1 and order-13 numerical integration. Finite element solution for problem 1 over mesh number 1 and order-19 numerical integration. Finite element solution for problem 1 over mesh number 2 and order-2 numerical integration. Finite element solution for problem 1 over mesh number 2 and order-5 numerical integration. Finite element solution for problem 1 over mesh number 2 and order-8 numerical integration. Finite element solution for problem 1 over mesh number 2 and order-13 numerical integration. Finite element solution for problem 1 over mesh number 2 and order-19 numerical integration. Finite element solution for problem 1 over mesh number 3 and order-2 numerical integration. Finite element solution for problem 1 over mesh number 3 and order-5 numerical integration. Finite element solution for problem 1 over mesh number 3 and order-8 numerical integration. Finite element solution for problem 1 over mesh number 3 and order-13 numerical integration. Finite element solution for problem 1 over mesh number 3 and order-19 numerical integration. Finite element solution for problem 1 over mesh number 4 and order-2 numerical integration. Finite element solution for problem 1 over mesh number 4 and order-5 numerical integration. Finite element solution for problem 1 over mesh number 4 and order-8 numerical integration. Finite element solution for problem 1 over mesh number 4 and order-13 numerical integration. Finite element solution for problem 1 over mesh number 4 and order-19 numerical integration. Finite element solution for problem 1 over mesh number 5 and order-2 numerical integration. Finite element solution for problem 1 over mesh number 5 and order-5 numerical integration. Finite element solution for problem 1 over mesh number 5 and order-8 numerical integration. Finite element solution for problem 1 over mesh number 5 and order-13 numerical integration. Finite element solution for problem 1 over mesh number 5 and order-19 numerical integration. Errors in the \\(H^1\\) and \\(L2\\) norms","title":"Gallery"},{"location":"gallery/elle-0050/out/main/","text":"Problem 1. (12 points) Solve the Dirichlet problem \\[ \\begin{aligned} -\\Delta u &= 4, & \\quad &\\text{in $\\Omega$} \\\\ u &= 0, & &\\text{on $\\partial\\Omega$} \\end{aligned} \\] on the unit disk \\(\\Omega=\\{(x,y)\\;:\\; x^2+y^2\\le 1\\}\\) using quadratic isoparametric elements. A function implementing quadratic Lagrange interpolation over a reference triangle is implemented in the file interpolate.py which is used by the function poisson2 from poisson.py to create a finite element that locally evaluates the following variational Poisson problem \\[ \\sum_{j=1}^{n} \\mathbf{u}_{j} \\int_{\\Omega} \\nabla \\phi_{j} \\cdot \\nabla \\phi_{i}=\\int_{\\Omega} \\phi_{i} f+\\int_{\\partial \\Omega_{N}} \\phi_{i} g_{N}-\\sum_{j=n+1}^{n+n_{\\partial}} \\mathbf{u}_{j} \\int_{\\Omega} \\nabla \\phi_{j} \\cdot \\nabla \\phi_{i} \\] This is then integrated over the domain using a self-implemented system optimization package called anabel which leverages the JAX library to vectorize element state determination in a manner that can be accelerated on specialized hardware. Finite element solution using order-2 Gaussian quadrature What is the exact solution? The exact solution is \\[ \\boxed{u = 1 - x^2 - y^2} \\] Closed-form solution to the stated Poisson problem. Compute the \\(H^1\\) seminorm and \\(L^2\\) norm of the error for each of the meshes. Ignore the fringe error due to the piecewise parabolic mesh boundary not quite aligning with the circular domain. Turn in a table of your errors and \\(\\log\\) - \\(\\log\\) plots of the error vs.~the mesh parameter, \\(h\\) . Table of errors in the L2 norm for problem 1 \\(h\\) 2 5 13 19 0.5 0.0024764578 0.0030141854 0.0029849953 0.0029849953 0.25 0.0002258162 0.00027375659 0.00027090969 0.00027090969 0.125 2.1527457e-05 2.5708536e-05 2.5448945e-05 2.5448945e-05 0.0625 1.9830323e-06 2.3460163e-06 2.3228069e-06 2.3228069e-06 0.03125 1.7587735e-07 2.0760524e-07 2.0555351e-07 2.0555351e-07 Table of errors in the L2 norm for problem 2 \\(h\\) 2 5 13 19 0.5 0.0099611923 0.0064076596 0.0071412137 0.0071412137 0.25 0.0013051996 0.00083984741 0.0009471105 0.0009471105 0.125 0.00016874334 0.00010830203 0.00012249798 0.00012249798 0.0625 2.1626624e-05 1.3882073e-05 1.5691434e-05 1.5691434e-05 0.03125 2.7380054e-06 1.756023e-06 1.9850051e-06 1.9850051e-06 Table of errors in the H1 norm for problem 1 \\(h\\) 2 5 13 19 0.5 0.033040555 0.05344312 0.053451002 0.053451002 0.25 0.0057268302 0.0091748492 0.0091751946 0.0091751946 0.125 0.0010299012 0.0016399388 0.0016399544 0.0016399544 0.0625 0.00018443725 0.00029237375 0.00029237444 0.00029237444 0.03125 3.254096e-05 5.152993e-05 5.1529961e-05 5.1529961e-05 Table of errors in the H1 norm for problem 2 \\(h\\) 2 5 13 19 0.5 0.050321736 0.087419539 0.087364004 0.087364004 0.25 0.013576873 0.024424342 0.024421502 0.024421502 0.125 0.0036081315 0.0065157661 0.006515551 0.006515551 0.0625 0.00093741811 0.0016853971 0.0016853811 0.0016853811 0.03125 0.00023986093 0.00042915864 0.00042915753 0.00042915753 Problem 2 Repeat (1) for the problem \\[ \\begin{aligned} -\\Delta u &= \\frac{\\pi^2}{4}\\left(\\cos\\frac{\\pi r}{2} + \\operatorname{sinc} \\frac{\\pi r}{2}\\right), & \\quad &\\text{in $\\Omega$} \\\\ u &= 0, & &\\text{on $\\partial\\Omega$} \\end{aligned} \\] where \\(\\Omega\\) is again the unit disk. The exact solution is \\(u(x,y)=\\cos \\frac{\\pi r}{2}\\) , where \\(r=\\sqrt{x^2+y^2}\\) . Plot of the given closed-form solution. Problem 3 (6 points) Explain why the convergence rate for problem (1) is half an order higher than for problem (2). To understand what\u2019s going on, it may be helpful to plot the contribution to the \\(H^1\\) and \\(L^2\\) errors element by element. (see the sample file plot_errors.m ). For example, in problem 2, I got the following values when I integrated \\[ \\iint_T \\nabla(u_{FE} - u_{exact}) \\cdot \\nabla(u_{FE} - u_{exact})\\,dx \\, dy, \\qquad (T\\in\\mathcal{T}) \\] over the triangles in circle_iso/mesh3 : The \\(H^1\\) semi-norm error in the finite element solution is the square root of the sum of all the errors shown here. (I got \\(0.00400512\\) for the \\(H^1\\) error and \\(7.5355\\times10^{-5}\\) for the \\(L^2\\) error on this mesh). Appendix Solution plots Plots of Finite Element Solutions Finite element solution for problem 1 over mesh number 1 and order-2 numerical integration. Finite element solution for problem 1 over mesh number 1 and order-5 numerical integration. Finite element solution for problem 1 over mesh number 1 and order-8 numerical integration. Finite element solution for problem 1 over mesh number 1 and order-13 numerical integration. Finite element solution for problem 1 over mesh number 1 and order-19 numerical integration. Finite element solution for problem 1 over mesh number 2 and order-2 numerical integration. Finite element solution for problem 1 over mesh number 2 and order-5 numerical integration. Finite element solution for problem 1 over mesh number 2 and order-8 numerical integration. Finite element solution for problem 1 over mesh number 2 and order-13 numerical integration. Finite element solution for problem 1 over mesh number 2 and order-19 numerical integration. Finite element solution for problem 1 over mesh number 3 and order-2 numerical integration. Finite element solution for problem 1 over mesh number 3 and order-5 numerical integration. Finite element solution for problem 1 over mesh number 3 and order-8 numerical integration. Finite element solution for problem 1 over mesh number 3 and order-13 numerical integration. Finite element solution for problem 1 over mesh number 3 and order-19 numerical integration. Finite element solution for problem 1 over mesh number 4 and order-2 numerical integration. Finite element solution for problem 1 over mesh number 4 and order-5 numerical integration. Finite element solution for problem 1 over mesh number 4 and order-8 numerical integration. Finite element solution for problem 1 over mesh number 4 and order-13 numerical integration. Finite element solution for problem 1 over mesh number 4 and order-19 numerical integration. Finite element solution for problem 1 over mesh number 5 and order-2 numerical integration. Finite element solution for problem 1 over mesh number 5 and order-5 numerical integration. Finite element solution for problem 1 over mesh number 5 and order-8 numerical integration. Finite element solution for problem 1 over mesh number 5 and order-13 numerical integration. Finite element solution for problem 1 over mesh number 5 and order-19 numerical integration. Finite element solution for problem 1 over mesh number 1 and order-2 numerical integration. Finite element solution for problem 1 over mesh number 1 and order-5 numerical integration. Finite element solution for problem 1 over mesh number 1 and order-8 numerical integration. Finite element solution for problem 1 over mesh number 1 and order-13 numerical integration. Finite element solution for problem 1 over mesh number 1 and order-19 numerical integration. Finite element solution for problem 1 over mesh number 2 and order-2 numerical integration. Finite element solution for problem 1 over mesh number 2 and order-5 numerical integration. Finite element solution for problem 1 over mesh number 2 and order-8 numerical integration. Finite element solution for problem 1 over mesh number 2 and order-13 numerical integration. Finite element solution for problem 1 over mesh number 2 and order-19 numerical integration. Finite element solution for problem 1 over mesh number 3 and order-2 numerical integration. Finite element solution for problem 1 over mesh number 3 and order-5 numerical integration. Finite element solution for problem 1 over mesh number 3 and order-8 numerical integration. Finite element solution for problem 1 over mesh number 3 and order-13 numerical integration. Finite element solution for problem 1 over mesh number 3 and order-19 numerical integration. Finite element solution for problem 1 over mesh number 4 and order-2 numerical integration. Finite element solution for problem 1 over mesh number 4 and order-5 numerical integration. Finite element solution for problem 1 over mesh number 4 and order-8 numerical integration. Finite element solution for problem 1 over mesh number 4 and order-13 numerical integration. Finite element solution for problem 1 over mesh number 4 and order-19 numerical integration. Finite element solution for problem 1 over mesh number 5 and order-2 numerical integration. Finite element solution for problem 1 over mesh number 5 and order-5 numerical integration. Finite element solution for problem 1 over mesh number 5 and order-8 numerical integration. Finite element solution for problem 1 over mesh number 5 and order-13 numerical integration. Finite element solution for problem 1 over mesh number 5 and order-19 numerical integration. Errors in the \\(H^1\\) and \\(L2\\) norms Source Code of Interest # Claudio Perez # May 2021 import jax import anon.diff as diff from anabel.template import template import anabel.backend as anp @template ( 6 ) def poisson2(transf, test, trial, f = lambda x: 0.0 , ndim = 2 , points = None , weights = None , thickness = 1.0 , ** kwds): \"\"\" Parameters ---------- test, trial : Callable test and trial interpolants over the reference element. thickness : float http://people.inf.ethz.ch/arbenz/FEM17/pdfs/0-19-852868-X.pdf \"\"\" state = {} det = anp.linalg.det slv = anp.linalg.solve jacn_test = diff.jacx(test) jacn_trial = diff.jacx(trial) def transf(xi, xyz): return test(xi) @ xyz def jacn_transf(xi,xyz): return jacn_test(xi) @ xyz def jacx_test(xi,xyz): return slv(jacn_transf(xi,xyz), jacn_test(xi)) def dvol(xi, xyz): return 0.5 * thickness * ( abs (det(jacn_transf(xi,xyz)))) def stif(u,xyz,xi,wght, ** kwds): dNdx = jacx_test(xi,xyz) return (dNdx.T @ dNdx) * dvol(xi,xyz) * wght fj = jax.vmap(f, 0 ) def resp(u,xyz,xi,wght, ** kwds): dNdx = jacx_test(xi,xyz) N = test(xi)[:, None ] p = (dNdx.T @ dNdx) @ u * dvol(xi,xyz) * wght - (N @ N.T) @ fj(xyz)[:, None ] * dvol(xi,xyz) * wght return p integral = jax.vmap(resp,( None , None , 0 , 0 )) jac_integral = jax.vmap(stif,( None , None , 0 , 0 )) def jacx(u,__,___,xyz,points,weights): return sum (jac_integral(u,xyz,points,weights)) def main(u,__,___,xyz,points,weights): return sum (integral(u,xyz,points,weights)) return locals () @template ( 1 ) def L2(transf,test,trial,u,quad_point = None , thickness = 1.0 ): state = None det = anp.linalg.det slv = anp.linalg.solve du = lambda x: diff.jacfwd(u)(x)[:, None ] jacn_test = diff.jacx(test) jacn_trial = diff.jacx(trial) def transf(xi, xyz): return test(xi) @ xyz def jacn_transf(xi,xyz): return jacn_test(xi) @ xyz dvol = lambda xi, xyz: 0.5 * thickness * abs (det(jacn_transf(xi,xyz))) def resp(U,xyz,xi, wght): N = test(xi)[:, None ] tmp = u(transf(xi,xyz)) - N.T @ U q = tmp.T @ tmp * dvol(xi,xyz) * wght return q integral = jax.vmap(resp,( None , None , 0 , 0 )) def main(u,__,___,xyz,points,weights): return sum (integral(u,xyz,points,weights)) return locals () @template ( 1 ) def H1_v1(transf,test,trial,u,quad_point = None , thickness = 1.0 ): state = None det = anp.linalg.det slv = anp.linalg.solve du = lambda x: diff.jacfwd(u)(x)[:, None ] jacn_test = diff.jacx(test) jacn_trial = diff.jacx(trial) def transf(xi, xyz): return test(xi) @ xyz def jacn_transf(xi,xyz): return jacn_test(xi) @ xyz jacx_test = lambda xi,xyz: slv(jacn_transf(xi,xyz), jacn_test(xi)) dvol = lambda xi, xyz: 0.5 * thickness * abs (det(jacn_transf(xi,xyz))) def resp(U,xyz,xi, wght): tmp = du(transf(xi,xyz)) - jacx_test(xi,xyz) @ U q = tmp.T @ tmp * dvol(xi,xyz) * wght return q integral = jax.vmap(resp,( None , None , 0 , 0 )) def main(u,__,___,xyz,points,weights): return sum (integral(u,xyz,points,weights)) return locals () @template ( 1 ) def H1(transf,test,trial,u,quad_point = None , thickness = 1.0 ): state = None det = anp.linalg.det slv = anp.linalg.solve du = lambda x: diff.jacfwd(u)(x)[:, None ] jacn_test = diff.jacx(test) jacn_trial = diff.jacx(trial) def transf(xi, xyz): return test(xi) @ xyz def jacn_transf(xi,xyz): return jacn_test(xi) @ xyz jacx_test = lambda xi,xyz: slv(jacn_transf(xi,xyz), jacn_test(xi)) dvol = lambda xi, xyz: 0.5 * thickness * abs (det(jacn_transf(xi,xyz))) def resp(U,xyz,xi, wght): tmp = jacx_test(xi,xyz) @ (U - u(transf(xi,xyz))) q = tmp.T @ tmp * dvol(xi,xyz) * wght return q integral = jax.vmap(resp,( None , None , 0 , 0 )) def main(u,__,___,xyz,points,weights): return sum (integral(u,xyz,points,weights)) return locals ()","title":"Main"},{"location":"gallery/matrix_analysis/","text":"Examples in Matrix Analysis","title":"Matrix Analysis"},{"location":"gallery/matrix_analysis/220_HW06_P1/","text":"Hyperstatic Truss - Compatibility import ema as em import matplotlib.pyplot as plt import numpy as np % config InlineBackend.figure_format = 'svg' mdl = em.Model( 2 , 2 ) n = mdl.dnodes e = mdl.delems mdl.node( '1' , 0.0 , 0.0 ) mdl.node( '2' , 8.0 , 0.0 ) mdl.node( '3' , 4.0 , 3.0 ) mdl.node( '4' , 4.0 , 6.0 ) mdl.truss( 'a' , n[ '1' ], n[ '3' ]) mdl.truss( 'b' , n[ '2' ], n[ '3' ]) mdl.truss( 'c' , n[ '1' ], n[ '4' ]) mdl.truss( 'd' , n[ '3' ], n[ '4' ]) mdl.truss( 'e' , n[ '2' ], n[ '4' ]) mdl.fix(n[ '1' ], [ 'x' , 'y' ]) mdl.fix(n[ '2' ], [ 'x' , 'y' ]) mdl.numDOF() [[5, 6], [7, 8], [1, 2], [3, 4]] fig1, ax1 = plt.subplots( 1 , 1 ) em.plot_structure(mdl, ax1) svg Part 1 Static-Kinematic Matrix Equivalence \\[V = A_f U_f\\] A = em.A_matrix(mdl) B = em.B_matrix(mdl) \\[P_f = B_f Q\\] B.f $a_1$ $b_1$ $c_1$ $d_1$ $e_1$ $1$ 0.8 -0.8 0.00000 -0.0 0.00000 $2$ 0.6 0.6 0.00000 -1.0 0.00000 $3$ 0.0 0.0 0.55470 0.0 -0.55470 $4$ 0.0 0.0 0.83205 1.0 0.83205 B.f.T - A.f 0 1 2 3 0 0.0 0.0 0.0 0.0 1 0.0 0.0 0.0 0.0 2 0.0 0.0 0.0 0.0 3 0.0 0.0 0.0 0.0 4 0.0 0.0 0.0 0.0 Part 2 Member d length The kinematic matrix, \\(A_f\\) , is given below: A.f $1$ $2$ $3$ $4$ $a_1$ 0.8 0.6 0.0000 0.00000 $b_1$ -0.8 0.6 0.0000 0.00000 $c_1$ 0.0 0.0 0.5547 0.83205 $d_1$ -0.0 -1.0 0.0000 1.00000 $e_1$ 0.0 0.0 -0.5547 0.83205 And the corresponding deformation vector is: V = em.V_vector(A) V.set_item( 'b_1' , 0.1 ) V.set_item( 'c_1' , 0.2 ) V $V_{{}}$ $a_1$ 0.0 $b_1$ 0.1 $c_1$ 0.2 $d_1$ 0.0 $e_1$ 0.0 The free dof displacement vector, \\(U_f\\) , is then computed as follows: \\[ U_f = A_f^{-1}V_\\epsilon \\] Ve = V[[ 0 , 1 , 2 , 4 ]] Ae = A.f[[ 0 , 1 , 2 , 4 ],:] U = Ae.inv @ Ve U.disp \\[\\left[\\begin{matrix}-0.0625\\\\0.0833333333333333\\\\0.180277563773199\\\\0.120185042515466\\end{matrix}\\right]\\] Finally the fully deformation vector is computed from \\(V=A_fU_f\\) , which gives the necessary deformation of element d. Veh = A.f @ U Veh.disp \\[\\left[\\begin{matrix}9.25185853854297 \\cdot 10^{-19}\\\\0.1\\\\0.2\\\\0.036851709182133\\\\1.66986849470959 \\cdot 10^{-17}\\end{matrix}\\right]\\] Element d must therefore elongated by 0.037 . Satisfy Compatibility The matrix \\(\\bar{B}_x\\) is computed as follows: mdl.redundant(e[ 'd' ], '1' ) B.barx $d_1$ $a_1$ 0.833333 $b_1$ 0.833333 $c_1$ -0.600925 $d_1$ 1.000000 $e_1$ -0.600925 This is multiplied by the deformation vector as follows: residual = B.barx.T @ Veh print (residual) if residual < 10e-9 : print ( \"Compatibility is satisfied\" ) B.f.ker /- 0.56694671 B.ker /- 0.56694671","title":"Hyperstatic Truss - Compatibility"},{"location":"gallery/matrix_analysis/220_HW09_P1/","text":"Force Method - Truss import ema as em import matplotlib.pyplot as plt import numpy as np import sympy as sp % config InlineBackend.figure_format = 'svg' dm = em.Model( 2 , 2 ) # create instance of model object n = dm.dnodes e = dm.delems A1 = 10000 Ac = 20000 I = 1 dm.xsection( 'default' , A1, I) csec = dm.xsection( 'section-c' , Ac, I) n1 = dm.node( '1' , 0.0 , 0.0 ) n2 = dm.node( '2' , 16. , 0.0 ) n3 = dm.node( '3' , 8.0 , 6.0 ) n4 = dm.node( '4' , 0.0 , 6.0 ) a = dm.truss( 'a' , n3, n4) # add truss element to model object b = dm.truss( 'b' , n1, n3) c = dm.truss( 'c' , n2, n3, xsec = csec) dm.pin(n1) dm.pin(n4) dm.pin(n2) dm.numDOF() # Automatically number model dofs # em.utilities.export.FEDEAS(dm) [[3, 4], [5, 6], [1, 2], [7, 8]] prim = em.Model( 2 , 2 ) # create instance of model object np = prim.dnodes ep = prim.delems A1 = 10000 Ac = 20000 I = 1 prim.xsection( 'default' , A1, I) csec = prim.xsection( 'section-c' , Ac, I) prim.node( '1' , 0.0 , 0.0 ) prim.node( '2' , 16. , 0.0 ) prim.node( '3' , 8.0 , 6.0 ) prim.node( '4' , 0.0 , 6.0 ) prim.truss( 'a' , np[ '3' ], np[ '4' ]) # add truss element to model object prim.truss( 'c' , np[ '2' ], np[ '3' ], xsec = csec) prim.pin(np[ '1' ]) prim.pin(np[ '4' ]) prim.pin(np[ '2' ]) prim.numDOF() # Automatically number model dofs np[ '3' ].p[ 'x' ] = 30 np[ '3' ].p[ 'y' ] = 50 # Establish redundant member force dm.redundant(b, '1' ) fig, ax = plt.subplots() em.plot_structure(dm, ax) svg Part 1 : Nodal Loading Ufp = em.analysis.SolveDispl(prim) A = em.A_matrix(dm) A.f @ Ufp $V_{{fffffff}}$ $a_1$ 0.077333 $b_1$ 0.165400 $c_1$ 0.041667 b.q0[ '1' ] = 1 Uf = em.analysis.SolveDispl(dm) A = em.A_matrix(dm) A.f @ Uf $V_{{fffffffff}}$ $a_1$ -0.000361 $b_1$ -0.000718 $c_1$ -0.000141 # Create model matrices B = em.B_matrix(dm) P = em.P_vector(B) # Define nodal loading n[ '3' ].p[ 'x' ] = 30 n[ '3' ].p[ 'y' ] = 50 P.set_item( '1' , 50 ) P.set_item( '2' , 30 ) # Show full B matrix B $a_1$ $b_1$ $c_1$ $1$ 1.0 0.8 -0.8 $2$ -0.0 0.6 0.6 $3$ 0.0 -0.8 0.0 $4$ 0.0 -0.6 0.0 $5$ 0.0 0.0 0.8 $6$ 0.0 0.0 -0.6 $7$ -1.0 0.0 0.0 $8$ 0.0 0.0 0.0 # Show portion of B matrix corresponding to free dofs B.f $a_1$ $b_1$ $c_1$ $1$ 1.0 0.8 -0.8 $2$ -0.0 0.6 0.6 # Show portion of B matrix corresponding to primary system B.i $a_1$ $c_1$ $1$ 1.0 -0.8 $2$ -0.0 0.6 Find \\(Q_p\\) Qp = B.bari @ P.f Qp $Q_{{ffffff}}$ $a_1$ 90.0 $c_1$ 50.0 # create full 3x1 Qp vector from current 2x1 Qp vector Qp = em.Q_vector(B, Qp) Qp $Q_{{0}}$ $a_1$ 90.0 $b_1$ 0.0 $c_1$ 50.0 find \\((V_h)_p\\) # Initialize structure matrices A = em.A_matrix(dm) Fs = em.Fs_matrix(dm) Fs $a_1$ $b_1$ $c_1$ $a_1$ 0.0008 0.000 0.0000 $b_1$ 0.0000 0.001 0.0000 $c_1$ 0.0000 0.000 0.0005 Ve = Fs @ Qp Vhp = B.barx.T @ Ve Vhp C:\\Users\\claud\\Anaconda3\\lib\\site-packages\\IPython\\core\\formatters.py:371: FormatterWarning: text/html formatter returned invalid type <class 'ema.utilities.Structural_Vector'> (expected <class 'str'>) for object: Structural_Vector([-0.1402]) FormatterWarning Structural_Vector([-0.1402]) find \\((V_{h})_x\\) Ve_x = Fs @ B.barx Ve_x $b_1$ $a_1$ -0.00128 $b_1$ 0.00100 $c_1$ -0.00050 Vhx = B.barx.T @ Ve_x Vhx 0 0 0.003548 Qx = - Vhp / Vhx Qx C:\\Users\\claud\\Anaconda3\\lib\\site-packages\\IPython\\core\\formatters.py:371: FormatterWarning: text/html formatter returned invalid type <class 'ema.utilities.Structural_Vector'> (expected <class 'str'>) for object: Structural_Vector([[39.51521984]]) FormatterWarning Structural_Vector([[39.51521984]]) Part 2 : Thermal Loading Find \\((V_h)_p\\) # e['a'].e0['1'] = 100*2e-5 # e['b'].e0['1'] = 100*2e-5 # e['c'].e0['1'] = 100*2e-5 A = em.A_matrix(dm) A $1$ $2$ $3$ $4$ $5$ $6$ $7$ $8$ $a_1$ 1.0 -0.0 0.0 0.0 0.0 0.0 -1.0 0.0 $b_1$ 0.8 0.6 -0.8 -0.6 0.0 0.0 0.0 0.0 $c_1$ -0.8 0.6 0.0 0.0 0.8 -0.6 0.0 0.0 V0 = em.V0_vector(dm) V0 $V_{{ffffff}}$ $a_1$ 0.0 $b_1$ 0.0 $c_1$ 0.0 Vhp = B.barx.T @ V0 Vhp C:\\Users\\claud\\Anaconda3\\lib\\site-packages\\IPython\\core\\formatters.py:371: FormatterWarning: text/html formatter returned invalid type <class 'ema.utilities.Structural_Vector'> (expected <class 'str'>) for object: Structural_Vector([0.]) FormatterWarning Structural_Vector([0.]) Find \\(Q_x\\) Qx = - Vhp / Vhx Qx C:\\Users\\claud\\Anaconda3\\lib\\site-packages\\IPython\\core\\formatters.py:371: FormatterWarning: text/html formatter returned invalid type <class 'ema.utilities.Structural_Vector'> (expected <class 'str'>) for object: Structural_Vector([[-0.]]) FormatterWarning Structural_Vector([[-0.]])","title":"Force Method - Truss"},{"location":"gallery/matrix_analysis/220_HW09_P3_v2/","text":"Stiffness Method - Beam import ema as em import matplotlib.pyplot as plt import numpy as np % config InlineBackend.figure_format = 'svg' # used to make plots look nicer # Initialize model dm = em.Model( 2 , 3 ) nodes = dm.nodes n = dm.dnodes # Define section properties A = 1 Iab = 200000 Ic = 300000 xs1 = dm.xsec( 'ab' , A, Iab) xs2 = dm.xsec( 'c' , A, Ic) xsecs = [xs1, xs1, xs2] # Define nodes dm.node( '1' , 0.0 , 0.0 ) dm.node( '2' , 15. , 0.0 ) dm.node( '3' , 35. , 0.0 ) dm.node( '4' , 50. , 0.0 ) # Create beams a, b, c = dm.girder(nodes, xsecs = xsecs) # Establish fixities dm.fix(n[ '1' ], [ 'x' , 'y' ]) dm.fix(n[ '2' ], [ 'y' ]) dm.fix(n[ '3' ], [ 'y' ]) dm.fix(n[ '4' ], [ 'y' ]) # uncomment line below to automatically print FEDEASLab input script # em.utilities.export.FEDEAS(dm) dm.numDOF() # automatically number dofs and print them as list [[8, 9, 1], [2, 10, 3], [4, 11, 5], [6, 12, 7]] fig, ax = plt.subplots() em.plot_beam(dm, ax) svg Part a) Distributed Loading Determine displacements of the free dofs. # set element loads a.w[ 'y' ] = - 10 b.w[ 'y' ] = - 10 A = em.A_matrix(dm) B = em.B_matrix(dm) V0 = em.V_vector(A).o Q0 = em.Q_vector(B).o Q0 $Q_{{}}$ $a_1$ 0.000000 $a_2$ 187.500000 $a_3$ -187.500000 $b_1$ 0.000000 $b_2$ 333.333333 $b_3$ -333.333333 $c_1$ 0.000000 $c_2$ 0.000000 $c_3$ 0.000000 P0 = B.f @ Q0 P0 $P_{{}}$ $1$ 187.500000 $2$ 0.000000 $3$ 145.833333 $4$ 0.000000 $5$ -333.333333 $6$ 0.000000 $7$ 0.000000 K = em.K_matrix(dm) K.f $U_{{1}}$ $U_{{2}}$ $U_{{3}}$ $U_{{4}}$ $U_{{5}}$ $U_{{6}}$ $U_{{7}}$ $P_{{1}}$ 53333.333333 0.000000 26666.666667 0.000000 0.0 0.000000 0.0 $P_{{2}}$ 0.000000 0.116667 0.000000 -0.050000 0.0 0.000000 0.0 $P_{{3}}$ 26666.666667 0.000000 93333.333333 0.000000 20000.0 0.000000 0.0 $P_{{4}}$ 0.000000 -0.050000 0.000000 0.116667 0.0 -0.066667 0.0 $P_{{5}}$ 0.000000 0.000000 20000.000000 0.000000 120000.0 0.000000 40000.0 $P_{{6}}$ 0.000000 0.000000 0.000000 -0.066667 0.0 0.066667 0.0 $P_{{7}}$ 0.000000 0.000000 0.000000 0.000000 40000.0 0.000000 80000.0 Uf = K.f.inv @ ( - P0) Uf $U_{{}}$ $U_{{1}}$ -0.002734 $U_{{2}}$ 0.000000 $U_{{3}}$ -0.001562 $U_{{4}}$ 0.000000 $U_{{5}}$ 0.003646 $U_{{6}}$ 0.000000 $U_{{7}}$ -0.001823 Determine element basic forces V = A.f @ Uf V $V_{{}}$ $a_1$ 0.000000 $a_2$ -0.002734 $a_3$ -0.001562 $b_1$ 0.000000 $b_2$ -0.001562 $b_3$ 0.003646 $c_1$ 0.000000 $c_2$ 0.003646 $c_3$ -0.001823 Q = K.s @ V + Q0 Q 0 0 0.000000e+00 1 2.842171e-14 2 -3.437500e+02 3 0.000000e+00 4 3.437500e+02 5 -2.187500e+02 6 0.000000e+00 7 2.187500e+02 8 2.842171e-14 Part b) Thermal Loading a.w[ 'y' ] = 0.0 b.w[ 'y' ] = 0.0 b.e0[ '2' ] = - 1e-3 b.e0[ '3' ] = 1e-3 c.e0[ '2' ] = - 1e-3 c.e0[ '3' ] = 1e-3 V0 = em.V_vector(A).o V0 $V_{{0}}$ $a_1$ 0.0000 $a_2$ 0.0000 $a_3$ 0.0000 $b_1$ 0.0000 $b_2$ 0.0100 $b_3$ -0.0100 $c_1$ 0.0000 $c_2$ 0.0075 $c_3$ -0.0075 Q0 = em.Q_vector(B).o Q0 $Q_{{}}$ $a_1$ 0.0 $a_2$ 0.0 $a_3$ 0.0 $b_1$ 0.0 $b_2$ -200.0 $b_3$ 200.0 $c_1$ 0.0 $c_2$ -300.0 $c_3$ 300.0 c.f_matrix() $q_1$ $q_2$ $q_3$ $v_1$ 15.0 0.000000 0.000000 $v_2$ 0.0 0.000017 -0.000008 $v_3$ 0.0 -0.000008 0.000017","title":"Stiffness Method - Beam"},{"location":"gallery/matrix_analysis/220_HW10_P3/","text":"Problem 3 import ema as em import matplotlib.pyplot as plt import numpy as np % config InlineBackend.figure_format = 'svg' mdl = em.rModel( 2 , 3 ) mdl.material( 'default' , 1000 ) mdl.xsection( 'default' , 10000000 , 50 ) tsec = mdl.xsection( 'truss' , 20 , 1 ) n1 = mdl.node( '1' , 0.0 , 0.0 ) n2 = mdl.node( '2' , 8.0 , 0.0 ) n3 = mdl.node( '3' , 16. , 0.0 ) n4 = mdl.node( '4' , 0.0 , 6.0 ) a = mdl.beam( 'a' , n1, n2) b = mdl.beam( 'b' , n2, n3) c = mdl.beam( 'c' , n1, n4) d = mdl.truss( 'd' , n2, n4, xsec = tsec) n2.p[ 'y' ] = - 20 mdl.hinge(c, n4) mdl.roller(n1) mdl.fix(n3, [ 'x' , 'y' , 'rz' ]) mdl.fix(n4, [ 'rz' ]) # mdl.numDOF() mdl.DOF = [[ 5 , 6 , 1 ], [ 5 , 2 , 3 ], [ 5 , 7 , 8 ], [ 4 , 6 , 9 ]] # Manually number DOFs # em.utilities.export.FEDEAS(mdl) mdl.nt 9 fig, ax = plt.subplots() em.plot_structure(mdl, ax) <matplotlib.axes._subplots.AxesSubplot at 0x2094a461a88> svg K = em.K_matrix(mdl) K.f $1$ $2$ $3$ $4$ $P_{1}$ 50000.00000 -4687.50 12500.0 4166.66667 $P_{2}$ -4687.50000 3063.75 0.0 960.00000 $P_{3}$ 12500.00000 0.00 50000.0 0.00000 $P_{4}$ 4166.66667 960.00 0.0 1974.44444 Uf = em.analysis.SolveDispl(mdl) Uf $U_{{}}$ $1$ -0.002494 $2$ -0.014149 $3$ 0.000624 $4$ 0.012143 Compatibility A = em.A_matrix(mdl) V = A.f @ Uf V $V_{{}}$ $a_1$ 0.000000 $a_2$ -0.000726 $a_3$ 0.002392 $b_1$ 0.000000 $b_2$ -0.001145 $b_3$ -0.001769 $c_1$ 0.000000 $c_2$ -0.000470 $c_3$ 0.002024 $d_1$ -0.001225 mdl.redundant(b, '3' ) mdl.redundant(d, '1' ) B = em.B_matrix(mdl) np.around(B.barx, 5 ) --------------------------------------------------------------------------- LinAlgError Traceback (most recent call last) <ipython-input-10-5ef0eae70dd5> in <module> ----> 1 np.around(B.barx,5) ~\\OneDrive\\400_box\\Python\\myPackages\\ema\\matrices.py in barx(self) 550 nx = len(self.model.redundants) 551 --> 552 Bbarxi = self.barxi 553 554 Bbarx = Structural_Matrix(np.zeros((nQ,nx))) ~\\OneDrive\\400_box\\Python\\myPackages\\ema\\matrices.py in barxi(self) 541 def barxi(self): 542 Bx = self.f.x --> 543 Bbarxi = self.bari @ -Bx 544 Bbarxi.column_data = Bx.column_data 545 return Bbarxi ~\\OneDrive\\400_box\\Python\\myPackages\\ema\\matrices.py in bari(self) 568 @property 569 def bari(self): --> 570 return self.i.del_zeros().inv 571 572 @property ~\\OneDrive\\400_box\\Python\\myPackages\\ema\\matrices.py in inv(self) 212 @property 213 def inv(self): --> 214 mat = np.linalg.inv(self) 215 transfer_vars(self, mat) 216 mat.row_data = self.column_data <__array_function__ internals> in inv(*args, **kwargs) ~\\Anaconda3\\lib\\site-packages\\numpy\\linalg\\linalg.py in inv(a) 544 a, wrap = _makearray(a) 545 _assertRankAtLeast2(a) --> 546 _assertNdSquareness(a) 547 t, result_t = _commonType(a) 548 ~\\Anaconda3\\lib\\site-packages\\numpy\\linalg\\linalg.py in _assertNdSquareness(*arrays) 211 m, n = a.shape[-2:] 212 if m != n: --> 213 raise LinAlgError('Last 2 dimensions of the array must be square') 214 215 def _assertFinite(*arrays): LinAlgError: Last 2 dimensions of the array must be square B.barx ker = B.f.c.ker np.around(ker, 4 ) B.barx.T @ V K.f @ Uf Find element forces Q = K.s @ V Q --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) <ipython-input-11-b08c858beddb> in <module> ----> 1 Q = K.s@V 2 3 Q AttributeError: 'Stiffness_matrix' object has no attribute 's' em.plot_U(mdl, Uf, ax, scale = 100 , chords = False ) svg x = np.linspace( 0 , c.L, 100 ) v_tags = [c.tag + '_2' , c.tag + '_3' ] v = [V.get(v_tags[ 0 ]),V.get(v_tags[ 1 ])] y = c.Elastic_curve(x, v, scale = 1000 , global_coord = True ) plt.plot(y[ 0 ], y[ 1 ]) [<matplotlib.lines.Line2D at 0x2094b8c7d08>] svg Uf.row_data","title":"Problem 3"},{"location":"gallery/matrix_analysis/Force_Method/","text":"The Force Method import ema as em import matplotlib.pyplot as plt import numpy as np import sympy as sp % config InlineBackend.figure_format = 'svg' dm = em.Model( 2 , 2 ) # create instance of model object n = dm.dnodes e = dm.delems A1 = 10000 Ac = 20000 I = 1 dm.xsection( 'default' , A1, I) csec = dm.xsection( 'section-c' , Ac, I) n1 = dm.node( '1' , 0.0 , 0.0 ) n2 = dm.node( '2' , 16. , 0.0 ) n3 = dm.node( '3' , 8.0 , 6.0 ) n4 = dm.node( '4' , 0.0 , 6.0 ) a = dm.truss( 'a' , n3, n4) # add truss element to model object b = dm.truss( 'b' , n1, n3) c = dm.truss( 'c' , n2, n3, xsec = csec) dm.pin(n1) dm.pin(n4) dm.pin(n2) dm.numDOF() ; prim = em.Model( 2 , 2 ) # create instance of model object np = prim.dnodes ep = prim.delems A1 = 10000 Ac = 20000 I = 1 prim.xsection( 'default' , A1, I) csec = prim.xsection( 'section-c' , Ac, I) prim.node( '1' , 0.0 , 0.0 ) prim.node( '2' , 16. , 0.0 ) prim.node( '3' , 8.0 , 6.0 ) prim.node( '4' , 0.0 , 6.0 ) prim.truss( 'a' , np[ '3' ], np[ '4' ]) # add truss element to model object prim.truss( 'c' , np[ '2' ], np[ '3' ], xsec = csec) prim.pin(np[ '1' ]) prim.pin(np[ '4' ]) prim.pin(np[ '2' ]) prim.numDOF() ; # Automatically number model dofs # Establish redundant member force dm.redundant(b, '1' ) fig, ax = plt.subplots() em.plot_structure(dm, ax) svg Part 1 : Nodal Loading A = em.A_matrix(dm) np[ '3' ].p[ 'y' ] = 30 np[ '3' ].p[ 'x' ] = 50 Up = em.analysis.SolveDispl(prim) A.f @ Up $V_{{fffff}}$ $a_1$ 0.0720 $b_1$ 0.1402 $c_1$ 0.0250 \\(U_x\\) b.q0[ '1' ] = 1 np[ '3' ].p[ 'y' ] = 0.6 np[ '3' ].p[ 'x' ] = 0.8 Ux = em.analysis.SolveDispl(prim) V0 = em.V0_vector(dm) em.plot_U(dm, Ux, ax, scale = 500 ) Ux [0.0, 0.0] [0.0, 0.0] [0.00128, 0.0025399999999999997] [0.0, 0.0] $U_{{fffffffffffffffff}}$ $1$ 0.00128 $2$ 0.00254 svg A.f @ Ux + V0 super C:\\Users\\claud\\Anaconda3\\lib\\site-packages\\IPython\\core\\formatters.py:371: FormatterWarning: text/html formatter returned invalid type <class 'ema.matvecs.Deformation_vector'> (expected <class 'str'>) for object: Deformation_vector([0.00128 , 0.003548, 0.0005 ]) FormatterWarning Deformation_vector([0.00128 , 0.003548, 0.0005 ]) # Define nodal loading b.q0[ '1' ] = 0 n[ '3' ].p[ 'y' ] = 30 n[ '3' ].p[ 'x' ] = 50 UP = em.analysis.SolveDispl(dm) UP $U_{{fffffffff}}$ $1$ 0.021421 $2$ 0.037298 A.f @ UP $V_{{fffffffff}}$ $a_1$ 0.021421 $b_1$ 0.039515 $c_1$ 0.005242","title":"The Force Method"},{"location":"gallery/plastic_analysis/","text":"Examples in Plastic Analysis","title":"Plastic Analysis"},{"location":"gallery/plastic_analysis/220_HW11_P1b/","text":"Kinematics - Kernel Analysis import ema as em import matplotlib.pyplot as plt import numpy as np % config InlineBackend.figure_format = 'svg' # used to make plots look nicerbb mdl = em.Model( 2 , 3 ) n = mdl.dnodes e = mdl.delems mdl.node( '1' , 0.0 , 0.0 ) mdl.node( '2' , 8.0 , 0.0 ) mdl.node( '3' , 8.0 , 6.0 ) mdl.node( '4' , 16.0 , 6.0 ) mdl.beam( 'a' , n[ '1' ], n[ '2' ]) mdl.beam( 'b' , n[ '2' ], n[ '3' ]) mdl.beam( 'c' , n[ '3' ], n[ '4' ]) mdl.hinge(e[ 'a' ], n[ '1' ]) mdl.hinge(e[ 'b' ], n[ '3' ]) mdl.fix(n[ '1' ], [ 'x' , 'y' , 'rz' ]) mdl.fix(n[ '4' ], [ 'y' ]) mdl.numDOF() [[9, 10, 11], [1, 2, 3], [4, 5, 6], [7, 12, 8]] em.analysis.characterize(mdl) m = 1 s = 0 fig, ax = plt.subplots( 1 , 1 ) em.plot_structure(mdl, ax) svg A = em.A_matrix(mdl) A.f $1$ $2$ $3$ $4$ $5$ $6$ $7$ $8$ $a_1$ 1.000000 0.000 0.0 0.000000 0.000 0.0 0.0 0.0 $a_2$ 0.000000 -0.125 0.0 0.000000 0.000 0.0 0.0 0.0 $a_3$ 0.000000 -0.125 1.0 0.000000 0.000 0.0 0.0 0.0 $b_1$ -0.000000 -1.000 0.0 0.000000 1.000 0.0 0.0 0.0 $b_2$ -0.166667 0.000 1.0 0.166667 -0.000 0.0 0.0 0.0 $b_3$ -0.166667 0.000 0.0 0.166667 -0.000 1.0 0.0 0.0 $c_1$ 0.000000 0.000 0.0 -1.000000 -0.000 0.0 1.0 0.0 $c_2$ 0.000000 0.000 0.0 -0.000000 0.125 1.0 0.0 0.0 $c_3$ 0.000000 0.000 0.0 -0.000000 0.125 0.0 0.0 1.0 A_cm = A.c.ker / - 0.561490 A_cm $1$ $1$ -0.000 $2$ 1.000 $3$ 0.125 $4$ -0.750 $5$ 1.000 $6$ -0.125 $7$ -0.750 $8$ -0.125 em.plot_U(mdl, A_cm, ax, scale = 1 ) 1 2 3 4 5 6 7 8 svg","title":"Kinematics - Kernel Analysis"},{"location":"gallery/plastic_analysis/220_HW11_P1br/","text":"Problem 2 (See also HW-07 Problem 1) import ema as em import matplotlib.pyplot as plt import numpy as np % config InlineBackend.figure_format = 'svg' # used to make plots look nicerbb #Remove mdl = em.rModel( 2 , 3 ) n = mdl.dnodes e = mdl.delems mdl.node( '1' , 0.0 , 0.0 ) mdl.node( '2' , 8.0 , 0.0 ) mdl.node( '3' , 8.0 , 6.0 ) mdl.node( '4' , 16.0 , 6.0 ) mdl.beam( 'a' , n[ '1' ], n[ '2' ]) mdl.beam( 'b' , n[ '2' ], n[ '3' ]) mdl.beam( 'c' , n[ '3' ], n[ '4' ]) mdl.hinge(e[ 'a' ], n[ '1' ]) mdl.hinge(e[ 'b' ], n[ '3' ]) mdl.hinge(e[ 'c' ], n[ '3' ]) mdl.hinge(e[ 'c' ], n[ '4' ]) mdl.fix(n[ '1' ], [ 'x' , 'y' , 'rz' ]) mdl.fix(n[ '2' ], [ 'rz' ]) mdl.fix(n[ '4' ], [ 'y' , 'rz' ]) # mdl.numDOF() mdl.DOF = [[ 4 , 5 , 6 ], [ 4 , 1 , 2 ], [ 3 , 1 , 7 ], [ 3 , 8 , 9 ]] em.analysis.characterize(mdl) m = 1 s = 0 fig, ax = plt.subplots() em.plot_structure(mdl, ax) svg A = em.A_matrix(mdl).remove( 'frame-axial' ) A.c $1$ $2$ $3$ $a_3$ -0.125 1.0 0.000000 $b_2$ -0.000 1.0 0.166667 ker = A.c.ker A_cm = ker / ker[ 0 ] A_cm 0 0 1.000 1 0.125 2 -0.750 em.plot_U(mdl, ker, ax, scale = 0.5 ) svg A.f @ A_cm 0 0 -1.250000e-01 1 -1.804112e-16 2 -4.394633e-17 3 -1.250000e-01 4 1.250000e-01 5 1.250000e-01","title":"Problem 2"},{"location":"gallery/plastic_analysis/220_HW11_P2/","text":"Kinematics import ema as em import matplotlib.pyplot as plt import numpy as np import sympy as sp % config InlineBackend.figure_format = 'svg' import scipy.linalg as la mdl = em.Model( 2 , 3 ) n = mdl.dnodes e = mdl.delems mdl.node( '1' , 0.0 , 0.0 ) mdl.node( '2' , 0.0 , 5.0 ) mdl.node( '3' , 4.0 , 5.0 ) mdl.node( '4' , 8.0 , 5.0 ) mdl.node( '5' , 8.0 , 0.0 ) mdl.node( '6' , 8.0 , 10. ) mdl.beam( 'a' , n[ '1' ], n[ '2' ]) mdl.beam( 'b' , n[ '2' ], n[ '3' ]) mdl.beam( 'c' , n[ '3' ], n[ '4' ]) mdl.truss( 'd' , n[ '4' ], n[ '5' ]) mdl.beam( 'e' , n[ '4' ], n[ '6' ]) mdl.hinge(e[ 'a' ], n[ '1' ]) mdl.hinge(e[ 'c' ], n[ '3' ]) mdl.hinge(e[ 'e' ], n[ '6' ]) mdl.fix(n[ '1' ], [ 'x' , 'y' , 'rz' ]) mdl.fix(n[ '5' ], [ 'x' , 'y' , 'rz' ]) mdl.fix(n[ '6' ], [ 'x' , 'y' , 'rz' ]) mdl.numDOF() em.analysis.characterize(mdl) m = 1 s = 2 fig, ax = plt.subplots() em.plot_structure(mdl, ax) svg A = em.A_matrix(mdl) A.f $1$ $2$ $3$ $4$ $5$ $6$ $7$ $8$ $9$ $a_1$ 0.0 1.00 0.0 0.0 0.00 0.0 0.0 0.00 0.0 $a_2$ 0.2 -0.00 0.0 0.0 0.00 0.0 0.0 0.00 0.0 $a_3$ 0.2 -0.00 1.0 0.0 0.00 0.0 0.0 0.00 0.0 $b_1$ -1.0 -0.00 0.0 1.0 0.00 0.0 0.0 0.00 0.0 $b_2$ -0.0 0.25 1.0 0.0 -0.25 0.0 0.0 0.00 0.0 $b_3$ -0.0 0.25 0.0 0.0 -0.25 1.0 0.0 0.00 0.0 $c_1$ 0.0 0.00 0.0 -1.0 -0.00 0.0 1.0 0.00 0.0 $c_2$ 0.0 0.00 0.0 -0.0 0.25 1.0 0.0 -0.25 0.0 $c_3$ 0.0 0.00 0.0 -0.0 0.25 0.0 0.0 -0.25 1.0 $d_1$ 0.0 0.00 0.0 0.0 0.00 0.0 -0.0 1.00 0.0 $e_1$ 0.0 0.00 0.0 0.0 0.00 0.0 -0.0 -1.00 0.0 $e_2$ 0.0 0.00 0.0 0.0 0.00 0.0 -0.2 0.00 1.0 $e_3$ 0.0 0.00 0.0 0.0 0.00 0.0 -0.2 0.00 0.0 ker = A.c.ker ker = ker. round ( 6 ) / ker[ 0 ] ker $1$ $1$ 1.000001 $2$ -0.000000 $3$ -0.200000 $4$ 1.000001 $5$ -0.799999 $6$ -0.200000 $7$ 1.000001 $8$ 0.000000 $9$ 0.200000 em.plot_U(mdl, ker, ax, scale = 1 ) svg","title":"Kinematics"},{"location":"gallery/plastic_analysis/220_HW11_P3-FullMatrix/","text":"Kinematics 3 import ema as em import numpy as np import sympy as sp import matplotlib.pyplot as plt % config InlineBackend.figure_format = 'svg' #Remove mdl = em.Model( 2 , 3 ) n = mdl.dnodes e = mdl.delems mdl.node( '1' , 0.0 , 0.0 ) mdl.node( '2' , 6.0 , 0.0 ) mdl.node( '3' , 10. , 0.0 ) mdl.node( '4' , 6.0 , 6.0 ) mdl.node( '5' , 10. , 6.0 ) mdl.node( '6' , 6.0 , 10. ) mdl.beam( 'a' , n[ '1' ], n[ '2' ]) mdl.beam( 'b' , n[ '2' ], n[ '3' ]) mdl.beam( 'c' , n[ '2' ], n[ '4' ]) mdl.beam( 'd' , n[ '4' ], n[ '5' ]) mdl.beam( 'e' , n[ '4' ], n[ '6' ]) mdl.hinge(e[ 'a' ], n[ '1' ]) mdl.hinge(e[ 'b' ], n[ '2' ]) mdl.hinge(e[ 'b' ], n[ '3' ]) mdl.hinge(e[ 'c' ], n[ '4' ]) mdl.fix(n[ '1' ], [ 'x' , 'y' , 'rz' ]) mdl.fix(n[ '3' ], [ 'x' , 'y' , 'rz' ]) mdl.fix(n[ '5' ], [ 'y' ]) mdl.fix(n[ '6' ], [ 'x' ]) mdl.numDOF() em.analysis.characterize(mdl) mdl.DOF m = 1 s = 2 [[11, 12, 13], [1, 2, 3], [14, 15, 16], [4, 5, 6], [7, 17, 8], [18, 9, 10]] #Remove fig, ax = plt.subplots( 1 , 1 ) em.plot_structure(mdl, ax) svg # Matrices B = em.B_matrix(mdl) A = em.A_matrix(mdl) # Vectors Q = em.column_vector(B) V = em.V_vector(A) 3 Find \\(A_{cm}\\) ker = A.c.ker A_cm = ker / ker[ 5 ] A_cm $1$ $1$ 0.000000 $2$ -4.000000 $3$ -0.666667 $4$ 4.000000 $5$ -4.000000 $6$ 1.000000 $7$ 4.000000 $8$ 1.000000 $9$ -4.000000 $10$ 1.000000 em.plot_U(mdl, ker, ax, scale = 1 ) svg Part 4 A_m = A.f @ A_cm A_m $1$ $a_1$ 0.000000e+00 $a_2$ 6.666667e-01 $a_3$ 0.000000e+00 $b_1$ 0.000000e+00 $b_2$ -1.666667e+00 $b_3$ -1.000000e+00 $c_1$ 0.000000e+00 $c_2$ 0.000000e+00 $c_3$ 1.666667e+00 $d_1$ 1.000000e-14 $d_2$ -1.000000e-14 $d_3$ 0.000000e+00 $e_1$ 0.000000e+00 $e_2$ -1.000000e-14 $e_3$ 0.000000e+00","title":"Kinematics 3"},{"location":"gallery/plastic_analysis/220_HW12_P2r_E2E/","text":"Event to Event Analysis (220_HW12_P2r) import ema as em import numpy as np # import sympy as sp import matplotlib.pyplot as plt % config InlineBackend.figure_format = 'svg' mdl = em.rModel( 2 , 3 ) # reduced model in 2 dimensions with 3 dofs / node n = mdl.dnodes e = mdl.delems # pre-define element properties for convenience; these can alse be assigned indiviudally. mdl.material( 'default' , E = 1000 ) mdl.xsection( 'default' , 1e6 , 50 ) xt = mdl.xsection( 'truss' , 10 , 1 ) mdl.node( '1' , 0.0 , 0.0 ) mdl.node( '2' , 8.0 , 0.0 ) mdl.node( '3' , 8.0 , 6.0 ) mdl.node( '4' , 16. , 6.0 ) mdl.node( '5' , 16. , - 4. ) # elements mdl.beam( 'a' , n[ '1' ], n[ '2' ], Qpl = [ 1e6 , 120 , 120 ]) mdl.beam( 'b' , n[ '2' ], n[ '3' ], Qpl = [ 1e6 , 120 , 120 ]) mdl.beam( 'c' , n[ '3' ], n[ '4' ], Qpl = [ 1e6 , 120 , 120 ]) mdl.beam( 'd' , n[ '4' ], n[ '5' ], Qpl = [ 1e6 , 180 , 180 ]) mdl.truss( 'e' , n[ '2' ], n[ '4' ], xsec = xt, Qpl = [ 30 ]) # Fixities mdl.fix(n[ '1' ], [ 'x' , 'y' , 'rz' ]) mdl.fix(n[ '5' ], [ 'x' , 'y' , 'rz' ]) # Loading n[ '3' ].p[ 'y' ] = - 30 n[ '3' ].p[ 'x' ] = 50 mdl.DOF = mdl.numdofs() fig, ax = plt.subplots( 1 , 1 ) em.plot_structure(mdl, ax) svg ee = em.Event2Event(mdl) ee.run() ee.lamda array([0. , 1.26346229, 1.42471482, 1.53116075, 1.70774411, 1.75555556]) ee.Q[ - 1 ] # forces at last event $Q_{{}}$ $a_1$ 0.000000 $a_2$ 120.000000 $a_3$ -82.666667 $b_1$ 0.000000 $b_2$ 82.666667 $b_3$ 120.000000 $c_1$ 0.000000 $c_2$ -120.000000 $c_3$ -120.000000 $d_1$ 0.000000 $d_2$ 120.000000 $d_3$ 180.000000 $e_1$ 30.000000 ee.U # displacement vectors at each event .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 2 3 4 5 0 0.0 -0.016180 -0.020235 -0.026011 -0.054760 -0.068836 1 0.0 -0.004619 -0.005641 -0.006943 -0.013000 -0.016213 2 0.0 0.025365 0.030523 0.039657 0.080000 0.102720 3 0.0 -0.001066 -0.001211 0.000051 0.003645 0.005404 4 0.0 0.000290 0.000409 0.000051 -0.006000 -0.008272","title":"Event to Event Analysis"},{"location":"guides/","text":"Foundations Modeling Skeletal modeling PDEs over homogeneous domains System reliability Developing Development of an isoparametric element Elle reference library. Contributing","title":"Guides"},{"location":"guides/quick-start/","text":"Getting Started Installation The anabel Python package can be installed by running the following command: pip install anabel Building Models","title":"Getting Started"},{"location":"guides/foundations/","text":"[clad]: https://github.com/vgvassilev/clad {citeprgm=vassilev2015clad} Part I: Composition of Expressions In [@frostig2018compiling] , researchers from the Google Brain team begin their presentation of the revolutionary JAX project with a simple observation; machine learning workloads tend to consist largely of subroutines satisfying two simple properties: They are pure in the sense that their execution is free of side effects, and They are statically composed in the sense that they implement a computation which can be defined as a static data dependency on a graph of some set of primitive operations (This will be further explained). The exploitation of these properties with techniques such as automatic differentiation and just-in-time compilation has become a central component of tools like TensorFlow, Matlab and PyTorch, which in the recent decade have been at the forefront of an \u201cexplosion\u201d in the field of deep learning. The utility that these ground-breaking platforms provide is that they present researchers and developers with a high level platform for concisely staging mathematical computations with an intuitive \u201cneural network\u201d paradigm. By their structure, these resulting models admit analytic gradients which allows for the application of powerful optimization algorithms. Algorithmic differentiation (AD) is a class of computational methods which leverage the chain rule in order to exactly evaluate 1 the gradient of a mathematical computation which is implemented as a computer program. These methods are often further categorized into forward and reverse modes, the later of which further specializes to the backpropagation class of algorithms which has become ubiquitous in the field of machine learning. These methods generally leverage either (1) source code transformation techniques or (2) operator overloading so that such a gradient computation can be deduced entirely from the natural semantics of the programming language being used. Much of the early literature which explores applications of AD to fields like structural modeling [@ozaki1995higherorder; @martins2001connection] employ the first approach, where prior to compilation, an pre-processing step is performed on some source code which generates new code implementing the derivative of an operation. This approach is generally used with primitive languages like FORTRAN and C which lack built-in abstractions like operator overloading and was likely selected for these works because at the time, such languages were the standard in the field. Although these compile-time methods allow for powerful optimizations to be used, they can add significant complexity to a project. Languages like C++, Python and Matlab allow user-defined types to overload built-in primitive operators like + and * so that when they are applied to certain data types they invoke a user-specified procedure. These features allow for AD implementations which are entirely contained within a programming language\u2019s standard ecosystem. Building a Differentiable Model There are several approaches which may be followed to arrive at the same formulation of forward mode automatic differentiation [@hoffmann2016hitchhiker] . A particularly elegant entry point for the purpose of illustration is that used by [@pearlmutter2007lazy] which begins by considering the algebra of dual numbers . These numbers are expressions of the form \\(a + b\\varepsilon\\) , \\(a,b \\quad \\in \\mathbb{R}\\) for which addition and multiplication is like that of complex numbers, save that the symbol \\(\\varepsilon\\) be defined to satisfy \\(\\varepsilon^2 = 0\\) . Now consider an arbitrary analytic function \\(f: \\mathbb{R} \\rightarrow \\mathbb{R}\\) , admitting the following Taylor series expansion: \\[ f(a+b \\varepsilon)=\\sum_{n=0}^{\\infty} \\frac{f^{(n)}(a) b^{n} \\varepsilon^{n}}{n !} \\qquad(1)\\] By truncating the series at \\(n = 1\\) and adhering to the operations defined over dual number arithmetic, one obtains the expression \\[ f(a + b \\varepsilon) = f(a) + bf^\\prime (a) \\varepsilon, \\qquad(2)\\] This result insinuates that by elevating such a function to perform on dual numbers, it has effectively been transformed into a new function which simultaneously evaluates both it\u2019s original value, and it\u2019s derivative \\(f^\\prime\\) . For instance, consider the following pair of mappings: \\[ \\begin{aligned} f: & \\mathbb{R} \\rightarrow \\mathbb{R} \\\\ & x \\mapsto (c - x) \\end{aligned} \\qquad(3)\\] \\[ \\begin{aligned} g: & \\mathbb{R} \\rightarrow \\mathbb{R} \\\\ & x \\mapsto a x + b f(x) \\end{aligned} \\qquad(4)\\] One can use the system of dual numbers to evaluate the gradient of \\(g\\) at some point \\(x \\in \\mathbb{R}\\) , by evaluating \\(g\\) at the dual number \\(x + \\varepsilon\\) , where it is noted that the dual coefficient \\(b = 1\\) is in fact equal to the derivative of the dependent variable \\(x\\) . This procedure may be thought of as propagating a differential \\(\\varepsilon\\) throughout the computation. \\[ \\begin{aligned} g(x + \\varepsilon) & = a (x + \\varepsilon) + b f(x + \\varepsilon ) \\\\ & = a x + a \\varepsilon + b ( c - x - \\varepsilon) \\\\ & = (a - b) x + bc + (a - b) \\varepsilon \\end{aligned} \\qquad(5)\\] The result of this expansion is a dual number whose real component is the value of \\(g(x)\\) , and dual component, \\(a-b\\) , equal to the gradient of \\(g\\) evaluated at \\(x\\) . Such a system lends itself well to implementation in programming languages where an object might be defined to transparently act as a scalar. For example, in C, one might create a simple data structure with fields real and dual that store the real component, \\(a\\) and dual component, \\(b\\) of such a number as show in lst. 1. Listing 1: Basic dual number data type. typedef struct dual { float real , dual ; } dual_t ; Then, using the operator overloading capabilities of C++, the application of the * operator can be overwritten as follows so that the property \\(\\varepsilon = 0\\) is enforced, as show in lst. 2. Listing 2: Implementation of dual-dual multiplilcation in C++ dual_t dual_t :: operator * ( dual_t a , dual_t b ){ return ( dual_t ) { . real = a . real * b . real , . dual = a . real * b . dual + b . real * a . dual }; } Similar operations are defined for variations of the * , + , and - operators in a single-file library in the appendix. With this complete arithmetic interface implemented, forward propagation may be performed simply with statements like that of lst. 3. Listing 3: Dual number arithmetic in C++ through operator overloading. int main ( int argc , char ** argv ){ dual_t x ( 6.0 , 1.0 ); dual_t dg = a * x + ( c - x ) * b ; printd ( dA ); } Template Expressions The simple dual_t numeric type developed in the previous section allows both an expression, and its gradient to be evaluated simultaneously with only the minor penalty that each value stores an associated dual value. However, if such a penalty was imposed on every value carried in a modeling framework, both memory and computation demands would scale very poorly. In order to eliminate this burden, the concept of a template expression is introduced. This is again illustrated using the C++ programming language in order to maintain transparency to the corresponding machine instructions, but as expanded in the following part, this technique becomes extremely powerful when implemented in a context where access to the template expression in a processed form, such as an abstract syntax tree, can be readily manipulated. Examples of this might be through a higher-level language offering introspective capabilities (e.g., Python or most notably Lisp), or should one be so brave, via compiler extensions (an option which is becoming increasingly viable with recent developments and investment in projects like LLVM [@lattner2004llvm] ). In lst. 4, the function \\(g\\) has been defined as a template on generic types TA , TB , TC and TX . In basic use cases, like that shown in lst. 4, a modern C++ compiler will deduce the types of the arguments passed in a call to G so that dual operations will only be used when arguments of type dual_t are passed. Furthermore, such an implementation will produce a derivative of G with respect to whichever parameter is of type dual_t . For example, in the assignment to variable dg in lst. 4, a dual_t value is created from variable x within the call to G , which automatically causes the compiler to create a function with signature dual_t (*)( dual_t , real_t , real_t , real_t ) which propagates derivatives in x . Listing 4: Forward propagation using template metaprogramming template < typename TX , typename TB , typename TA , typename TC > auto G ( TX x , TB b , TA a , TC c ){ printd ( b * x ); printd ( c - x ); return a * x + ( c - x ) * b ; } int main ( int argc , char ** argv ){ real_t a = 60.0 , c = 18.0 , b = 18.0 ; real_t x = 6.0 ; real_t g = G ( x , b , a , c ); dual_t dg = G ( dual_t ( x , 1 ), b , a , c ); printd ( dg ); } In this minimal example, the set of operations for which we have explicitly defined corresponding dual operations constitute a set of primitive operations which may be composed arbitrarily in expressions which will implicitly propagate machine precision first derivatives. These compositions may include arbitrary use of control structures like while / for loops, branching via if statements, and by composition of such operations, numerical schemes involving indefinite iteration. A thorough treatment of AD for iterative procedures such as the use of the Newton-Raphson method for solving nonlinear equations is presented by [@beck1994automatic] , [@gilbert1992automatic] and [@griewank1993derivative] . Historic accounts of the development of AD can be found in [@iri2009automatic] . Such treatments generally begin with the work of Wengert (e.g. [@wengert1964simple] , ). A more recent work, [@elliott2009beautiful] develops an elegant presentation and implementation of forward-mode AD in the context of purely functional programming. Part II: The Finite Element Method The finite element method has become the standard method for modeling PDEs in countless fields of research, and this is due in no small part to the natural modularity that arises in the equations it produces. Countless software applications and programming frameworks have been developed which manifest this modularity, each with a unique flavor. A particularly powerful dialect of FE methods for problems in resilience is the composable approach developed through works like [@spacone1996fibre] where the classical beam element is generalized as a composition of arbitrary section models, which may in turn be comprised of several material models. Platforms like FEDEASLab and OpenSees are designed from the ground up to natively support such compositions [@mckenna2010nonlinear] . This study builds on this composable architecture by defining a single protocol for model components which can be used to nest or compose elements indefinitely. In order to establish an analogous structure to that of ANNs which is sufficiently general to model geometric and material nonlinearities, we first assert that such a FE program will act as a mapping, \\(\\Phi: \\Theta\\times\\mathcal{S}\\times\\mathcal{U}\\rightarrow\\mathcal{S}\\times\\mathcal{U}\\) , which walks a function, \\(f: \\Theta\\times\\mathcal{S}\\times\\mathcal{U}\\rightarrow\\mathcal{S}\\times\\mathcal{R}\\) (e.g. by applying the Newton-Raphson method), until arriving at a solution, \\((S^*,U^*)=\\Phi(\\Theta,S_0,U_0)\\) such that \\(f(\\Theta,S_0,U^*) = (S^*, \\mathbf{0})\\) in the region of \\(U_0\\) . In problems of mechanics, \\(f\\) may be thought of as a potential energy gradient or equilibrium statement, and the elements of \\(\\mathcal{U}\\) typically represent a displacement vector, \\(\\mathcal{R}\\) a normed force residual, \\(\\mathcal{S}\\) a set of path-dependent state variables, and \\(\\Theta\\) a set of parameters which an analyst may wish to optimize (e.g. the locations of nodes, member properties, parameters, etc.). The function \\(f\\) is composed from a set of \\(i\\) local functions \\(g_i: \\theta\\times s\\times u \\rightarrow s\\times r\\) that model the response and dissipation of elements over regions of the domain, which in turn may be comprised of a substructure or material function, until ultimately resolving through elementary operations, \\(h_j: \\mathbb{R}^n\\rightarrow\\mathbb{R}^m\\) (e.g. Vector products, trigonometric functions, etc.). In a mathematical sense, for a given solution routine, all of the information that is required to specify a computation which evaluates \\(\\Phi\\) , and some gradient, \\(D_\\Theta \\Phi\\) , of this model with respect to locally well behaved parameters \\(\\Theta\\) is often defined entirely by the combination of (1) a set of element response functions \\(g_i\\) , and (2) a graph-like data structure, indicating their connectivity (i.e., the static data dependency of [@frostig2018compiling] ) . For such problems, within a well-structured framework, the procedures of deriving analytic gradient functions and handling low-level machine instructions can be lifted entirely from the analyst through abstraction, who should only be concerned with defining the trial functions, \\(g_i\\) , and establishing their connectivity. The anabel Library An experimental library has been written in a combination of Python, C and C++ which provides functional abstractions that can be used to compose complex physical models. These abstractions isolate elements of a model which can be considered pure and statically composed (PSC), and provides an interface for their composition in a manner which allows for parameterized functions and gradients to be concisely composed. In this case, Python rarely serves as more than a configuration language, through which users simply annotate the entry and exit points of PSC operations. Once a complete operation is specified, it is compiled to a low-level representation which then may be executed entirely independent of the Python interpreter\u2019s runtime. Ideally such a library will be used to interface existing suites like FEDEASLab and OpenSees, but for the time being all experiments have been carried out with finite element models packaged under the elle namespace. Of particular interest, as expanded on in the conclusion of this report, would be developing a wrapper around the standard element API of OpenSees to interface with XLA, the back-end used by the anabel library. The anabel package is available on PyPi.org and can be pip installed, as explained in the online documentation. Functions in the anabel library operate on objects, or collections of objects, which implement an interface which can be represented as \\((S^*,U^*)=\\Phi(\\Theta,S_0,U_0)\\) , and generally can be classified as pertaining to either (1) composition or (2) assembly related tasks. Composition operations involve those which create new objects from elementary objects in a manner analogous to mathematical composition. These operations include the [anabel.template] decorator for creating composable operations. Assembly operations involve more conventional model-management utilities such as tracking and assigning DOFs, nodes and element properties. These are primarily handled by objects which subclass the anabel.Assembler through model building methods. These operations are generally required for the creation of OpenSees-styled models where, for example, a model may contain several types of frame elements, each configured using different section, material, and integration rules. Examples Two examples are presented which illustrate the composition of a physical model from a collection of PSC routines. In these examples, we consider a function, \\(F: \\mathbb{R}^9 \\rightarrow \\mathbb{R}^9\\) , that is the finite element model representation of the structure shown in fig. 1. For illustrative purposes, all model components are defined only by a single direct mapping, and properties such as stiffness matrices are implicitly extracted using forward mode AD. The example [@elle-0050] in the online documentation illustrates how components may define their own stiffness matrix operation, increasing model computational efficiency. Figure 1: Basic frame Columns measure \\(30 \\times 30\\) inches and the girder is cast-in-place monolithically with a slab as show in fig. 2. The dimensions \\(b_w\\) and \\(d - t_f\\) are known with reasonable certainty to both measure \\(18\\) inches, but due to shear lag in the flange and imperfections in the finishing of the slab surface, the dimensions \\(b_f\\) and \\(t_f\\) are only known to linger in the vicinity of \\(60\\) inches and \\(6\\) inches, respectively. Reinforcement is neglected and gross section properties are used for all members. Concrete with a \\(28\\) -day compressive strength of \\(f^\\prime_c=4\\) ksi is used, and the elastic modulus is taken at \\(3600\\) . Figure 2: Standard T-shaped girder cross section. We are equipped with the Python function in lst. 5 which contains in its closure a definition of the function beam implementing a standard linear 2D beam as a map from a set of displacements, \\(v\\) , to local forces \\(q\\) . Listing 5: Classical beam element implementation. @anabel.template ( 3 ) def beam2d_template( q0: array = None , E: float = None , A: float = None , I: float = None , L: float = None ): def beam(v, q, state = None , E = E,A = A,I = I,L = L): C0 = E * I / L C1 = 4.0 * C0 C2 = 2.0 * C0 k = anp.array([[E * A / L, 0.0 , 0.0 ],[ 0.0 ,C1,C2],[ 0.0 ,C2,C1]]) return v, k @ v, state return locals () Reliability Analysis Our first order of business is to quantify the uncertainty surrounding the dimensions \\(t_f\\) and \\(b_f\\) . We seek to approximate the probability that a specified displacement, \\(u_{max}\\) , will be exceeded assuming the dimensions \\(t_f\\) and \\(b_f\\) are distributed as given in tbl. 1 and a correlation coefficient of \\(0.5\\) . This criteria is quantified by the limit state function eq. 6 \\[ g(t_f, b_f) = u_{max} - \\Phi(t_f, b_f) \\qquad(6)\\] Table 1: Distributions of random variables. Variable Marginal Distribution Mean Standard Deviation \\(t_f\\) Lognormal \\(6\\) \\(0.6\\) \\(b_f\\) Lognormal \\(60\\) \\(6\\) To this end, a first order reliability analysis (FORM) is carried out, whereby the limit state function \\(g\\) is approximated as a hyperplane tangent to the limit surface at the so-called design point, \\(\\mathbf{y}^{*}\\) , by first-order truncation of the Taylor-series expansion. This design point is the solution of the following constrained minimization problem in a standard normal space, which if found at a global extrema, ensures that the linearized limit-state function is that with the largest possible failure domain (in the transformed space): \\[\\mathbf{y}^{*}=\\operatorname{argmin}\\{\\|\\mathbf{y}\\| \\quad | G(\\mathbf{y})=0\\}\\qquad(7)\\] where the function \\(G\\) indicates the limit state function \\(g\\) when evaluated in the transformed space. This transformed space is constructed using a Nataf transformation. At this point we find ourselves in a quandary, as our limit state is defined in terms of parameters \\(t_f\\) and \\(b_f\\) which our beam model in lst. 5 does not accept. However, as luck would have it, our analysis of eq. 4 might be repurposed as an expression for the area of a T girder. lst. 6 illustrates how an expression for A may be defined in terms of parameters tf and bf , and the instantiation of a beam_template instance which is composed of this expressions (The variable I is defined similarly. This has been omitted from the listing for brevity but the complete model definition is included as an appendix). In this study, the anabel.backend module, an interface to the JAX numpy API, will take on the role of our minimal C++ forward propagation library with additional support for arbitrary-order differentiation and linear algebraic primitives. Listing 6: Expression composition using `anabel` import anabel model = anabel.SkeletalModel(ndm = 2 , ndf = 3 ) bw, tw = 18 , 18 tf, bf = model.param( \"tf\" , \"bf\" ) # define an expression for the area area = lambda tf, bf: bf * tf + bw * tw # create a model parameter from this expression A = model.expr(area, tf, bf) ... # instantiate a `beam` in terms of this expression girder = beam_template(A = A, I = I, E = 3600.0 ) Once the remainder of the model has been defined, the compose method of the anabel.SkeletalModel class is used to build a function F which takes the model parameters tf and bf , and returns the model\u2019s displacement vector. A function which computes the gradient of the function F can be generated using the automatic differentiation API of the JAX library. This includes options for both forward and reverse mode AD. Now equipped with a response and gradient function, the limit state function can easily be defined for the FORM analysis. The FORM analysis is carried out using the self-implemented library aleatoire , also available on PyPi.org . The results of the reliability analysis are displayed in fig. 3, where the probability of exceeding a lateral displacement of \\(u_{max} = 0.2 \\text{inches}\\) is approximately \\(3.6\\%\\) . Figure 3: Design point obtained from first-order reliability analysis in the physical and transformed spaces, respectively. Cyclic Analysis In the final leg of our journey, the basic beam element in lst. 5 is replaced with that in lst. 7. This template accepts a sequence of functions \\(s: \\mathbb{R}^2 \\rightarrow \\mathbb{R}^2\\) representing cross sectional response. The function _B in the closure of this template is used to interpolate these section models according to an imposed curvature distribution. Additionally, each function \\(s_i\\) is composed of material fiber elements which are integrated over the cross section as depicted in fig. 4. Figure 4: Illustrative depiction of fiber section for T-shaped girder. Integration points enlarged to show detail . Listing 7: Expression template for fiber frame element. @anabel.template ( 3 ) def fiber_template( * sections, L = None , quad = None ): state = [s.origin[ 2 ] for s in sections] params = {...: [anon.dual.get_unspecified_parameters(s) for s in sections]} locs, weights = quad_points( ** quad) def _B(xi,L): x = L / 2.0 * ( 1.0 + xi) return anp.array([[ 1 / L, 0. , 0. ], [ 0.0 , ( 6 * x / L - 4 ) / L, ( 6 * x / L - 2 ) / L]]) def main(v, q = None ,state = state,L = L,params = params): B = [_B(xi,L) for xi in locs] S = [s(b @ v, None , state = state[i], ** params[...][i]) for i,(b,s) in enumerate ( zip (B, sections))] q = sum (L / 2.0 * w * b.T @ s[ 1 ] for b,w,s in zip (B,weights,S)) state = [s[ 2 ] for s in S] return v, q, state return locals () The results of a simple cyclic load history analysis are depicted in fig. 5. Figure 5: Cyclic response of portal frame with fiber girder. Conclusion An approach to finite element modeling was presented in which models are composed from trees of expressions which map between well-defined sets of inputs to outputs in a completely stateless manner. It was shown that this statelessness admits arbitrary compositions while maintaining mathematical properties/guarantees. These guarantees may be exploited through JIT compilation to extract unexpected performance from otherwise inherently slow programming languages/environments. Appendix Forward-mode AD Library for C++ Example Using Forward-mode AD in C++ Simple Portal Frame Composition Frostig, R., Johnson, M. J., and Leary, C. \u201c Compiling Machine Learning Programs via High-Level Tracing \u201d (2018): Available at https://cs.stanford.edu/~rfrostig/pubs/jax-mlsys2018.pdf Ozaki, I., Kimura, F., and Berz, M. \u201c Higher-Order Sensitivity Analysis of Finite Element Method by Automatic Differentiation \u201d (1995): 223\u2013234. doi: cqq274 Martins, J., Sturdza, P., and Alonso, J. \u201c The Connection Between the Complex-Step Derivative Approximation and Algorithmic Differentiation \u201d (2001): doi: 10.2514/6.2001-921 Hoffmann, P. H. W. \u201c A Hitchhiker \u2019s Guide to Automatic Differentiation \u201d (2016): 775\u2013811. doi: ggsd72 , Available at https://arxiv.org/abs/1411.0583 Pearlmutter, B. A. and Siskind, J. M. \u201c Lazy Multivariate Higher-Order Forward-Mode AD \u201d (2007): 155. doi: bpjm8z Lattner, C. and Adve, V. \u201c LLVM : A Compilation Framework for Lifelong Program Analysis Transformation \u201d (2004): 75\u201386. doi: d5brsd Beck, T. \u201c Automatic Differentiation of Iterative Processes \u201d (1994): 109\u2013118. doi: 10.1016/0377-0427(94)90293-3 Gilbert, J. C. \u201c Automatic Differentiation and Iterative Processes \u201d (1992): 13\u201321. doi: 10.1080/10556789208805503 Griewank, A., Bischof, C., Corliss, G., Carle, A., and Williamson, K. \u201c Derivative Convergence for Iterative Equation Solvers \u201d (1993): 321\u2013355. doi: 10.1080/10556789308805549 Iri, M. and Kubota, K. \u201c Automatic Differentiation: Introduction, History and Rounding Error estimationAutomatic Differentiation : Introduction , History and Rounding Error Estimation \u201d (2009): 153\u2013159. doi: 10.1007/978-0-387-74759-0_26 Wengert, R. E. \u201c A Simple Automatic Derivative Evaluation Program \u201d (1964): 463\u2013464. doi: bwkd4g Elliott, C. M. \u201c Beautiful Differentiation \u201d (2009): 12. doi: 10.1145/1631687.1596579 Spacone, E. and Filippou, F. C. \u201c Fibre Beam\u2013Column Model for Non\u2010linear Analysis of R / C Frames: Part I . Formulation \u201d (1996): 15. McKenna, F., Scott, M. H., and Fenves, G. L. \u201c Nonlinear Finite - Element Analysis Software Architecture Using Object Composition \u201d (2010): 95\u2013107. doi: 10.1061/(ASCE)CP.1943-5487.0000002 Perez, C. \u201c Parameterized Finite Element Analysis of a Poisson Problem in 2d \u201d (2021): Available at https://claudioperez.github.io/anabel/gallery/elle-0050/ Within machine precision \u21a9\ufe0e","title":"Index"}]}